<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://lisz.me/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lisz.me/" rel="alternate" type="text/html" /><updated>2024-07-05T18:02:35+09:00</updated><id>https://lisz.me/feed.xml</id><title type="html">仲儿的自留地</title><subtitle>个人的一个技术博客站点，主要用于记录个人在学习过程中遇到的技术问题及解决方法、技术实验，以及一些比较有趣的事情。</subtitle><author><name>zhonger</name></author><entry><title type="html">生活中的小问题——公交计费问题</title><link href="https://lisz.me/tech/algorithm/bus-ticket.html" rel="alternate" type="text/html" title="生活中的小问题——公交计费问题" /><published>2024-07-02T15:15:00+09:00</published><updated>2024-07-02T15:15:00+09:00</updated><id>https://lisz.me/tech/algorithm/bus-ticket</id><content type="html" xml:base="https://lisz.me/tech/algorithm/bus-ticket.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  谈到生活中经常坐的公交车，比较常见的算法问题可能是寻找“耗时最少公交路线”、“最少换乘公交路线”、“最便宜公交路线”、“综合最优公交路线”等。这些算法由于在地图软件中经常被使用，已经被大家研究得非常透彻，比如 Dijkstra 算法就可以用来计算“最短距离公交路线”。如想了解更多，可以阅读参考资料 2 给出的中文文献。</p>

<p>  相比这些常见的算法问题，不如让我们来一起看看不大被人提及的“公交计费问题”。笔者经常在下雨的时候乘坐公交车，每次上车前会先取一张票，然后下车前可以看屏幕显示来知道票价。于是笔者就有了一个小问题：票价是如何正确显示的，是否可以对其建模并写个小程序模拟一下。</p>

<h2 id="问题描述">问题描述</h2>

<p>  如图 1 所示为公交计费问题描述。</p>

<ul>
  <li><strong>(a) 公交路线图</strong>（图中为右循环路线，但对应的左循环路线也存在），0~20 为站点编号，且 1~3 与 20~18 分别对应相同。公交从站点 0 出发，按照箭头所指的方向依次行进，最终回到站点 0 并停止运行。</li>
  <li><strong>(b) 相邻站点间距离</strong>，以 km 为距离计算单位，给出的数值为公交在站点间实际行进距离。</li>
  <li><strong>(c) 公交票价计算方式</strong>，距离不足 2 km 为基本票价 190 日元，超过 2 km 的话每超过 1 km 加收 50 日元，如不足 1 km 按照 1 km 计算。注意，此处的距离为循环线路中上车站点与下车站点的<strong>有效距离</strong>，即站点间在循环线路上的最短距离而非实际运行距离。比如，即使从站点 0 上车，经过一圈循环后再从站点 0 下车，也只能收取基本票价 190 日元，因为有效距离为 0 km。（以上计算方式参考自资料 3）</li>
  <li><strong>(d) 公交最后返回起始站点时计费状态</strong>，灰底色为站点编号，白底色为票价。</li>
</ul>

<p><img src="https://i.lisz.top/blog/GTgvbN.webp" alt="图 1. 公交计费问题描述。 The description of bus ticket problem." /></p>

<h3 id="问题目标">问题目标</h3>

<ol>
  <li>打印欢迎消息，提示是否从站点 0 发车；</li>
  <li>发车后，通过回车或其他操作在下一站点停车，打印当前票价状态，尚未抵达站点票价为空；</li>
  <li>经过循环后回到站点 0，通过回车或其他操作停车，打印当前票价状态，如图 1(d) 所示。</li>
</ol>

<h2 id="解决方案">解决方案</h2>

<h3 id="问题分析">问题分析</h3>

<p>  解决公交计费问题，首先要将图 1 中给出的信息进行集成，可得如下图 2。其中，站点间的橙色数字为相邻站点间距离，红色数字为几个关键（0~2 km，2~3 km 和 3~4 km 的阈值站点）站点与出发站点 0 之间的<strong>有效距离</strong>。</p>

<p><img src="https://i.lisz.top/blog/DD2KNn.webp" alt="图 2. 信息集成后的公交路线图。 The route including the distances and some importance valid distances." /></p>

<p>  其实整个问题的核心就在于对<strong>有效距离</strong>的理解。从题干可知，有效距离并非是实际行进距离。这主要是因为给出的公交路线是环线而非直线，即出发站点与结束站点为同一站点。除此之外，刚开始的 1~3 与最后的 20~18 三个站点是重合的。根据给出的例子解释，我们可以将这里的“<strong>有效距离</strong>”粗略定义为“<strong>上车站点与下车站点在公交路线上正反距离的最小值</strong>”。我们不妨从以下示例中进一步加深对于“<strong>有效距离</strong>”的理解：（~ 表示“大约”）</p>

<ul>
  <li><strong>例 1</strong>：上车站点为站点 3，下车站点为站点 17。因为站点 3 与站点 18 重合，所以有效距离等同于站点 17 和 18 之间的距离 0.45 km。</li>
  <li><strong>例 2</strong>：上车站点为站点 5，下车站点为站点 18。如例 1 方式计算可得有效距离为 0.85 km。</li>
  <li><strong>例 3</strong>：上车站点为站点 4，下车站点为站点 17。虽然按照路线实际行进距离很远，但是实际两站之间路线上最短距离大约为 0.45 km，即有效距离为 ~0.45 km。</li>
  <li><strong>例 4</strong>：上车站点为站点 5，下车站点为站点 15。如例 2 方式计算可得有效距离为 ~1.6 km。</li>
  <li><strong>例 5</strong>：上车站点为站点 6，下车站点为站点 14。按照图中方向实际行进距离计算，可知正向距离为 2.75 km，按照路线上最短反向距离为 ~2.25 km，因此有效距离为 ~2.25 km。</li>
</ul>

<p>得出总结：</p>

<ul>
  <li>从例 1、2 可以看出，当上车站点和下车站点分别在重合直线和循环圈上时，位于重合直线上的站点需要注意切换到对应站点进行双重计算正反向距离，从而得到正确的有效距离。</li>
  <li>从例 3~5 可以看出，当上车站点和下车站点均在循环圈上时，计算反向距离不涉及直线站点（即跨过出发站点 0）。即使站点 17 到站点 4 的实际行进路线不存在，也需以站点 17 到站点 4 闭合的循环圈来进行计算反向距离。</li>
</ul>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 为何不跨过出发站点 0 计算反向距离？ </div> </div> <div class="content"> <p>  题干中给出信息“<strong>公交从站点 0 出发最终回到站点 0 并停止运行</strong>”，鉴于任何跨过出发站点 0 计算的距离实际上只可能由两辆公交车完成，不可能出现在一辆公交的票价计算方式中，当只在循环圈上的站点上下车时应该不考虑直线上的站点（0~3、18~20）。</p>

<p>  说句题外话，如例 3~5 所示，可能直接走过去还更快更方便，而非坐这趟公交。</p>



 </div> </div>
<h3 id="算法描述">算法描述</h3>

<h4 id="变量声明">变量声明</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">变量名</th>
      <th style="text-align: center">变量类型</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">distances</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">站点列表，[0, 0.2, 0.3, …]</td>
    </tr>
    <tr>
      <td style="text-align: center">currentStop</td>
      <td style="text-align: center">int</td>
      <td style="text-align: left">当前站点编号，0</td>
    </tr>
    <tr>
      <td style="text-align: center">lineStops</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">直线站点，[1, 2, 3, 18, 19, 20]</td>
    </tr>
    <tr>
      <td style="text-align: center">circleStops</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">循环圈站点，[4, 5, …, 17]</td>
    </tr>
    <tr>
      <td style="text-align: center">ticketBase</td>
      <td style="text-align: center">float</td>
      <td style="text-align: left">基础票价，190.00</td>
    </tr>
    <tr>
      <td style="text-align: center">ticketStep</td>
      <td style="text-align: center">float</td>
      <td style="text-align: left">票价梯度，50.00</td>
    </tr>
    <tr>
      <td style="text-align: center">ticketUnit</td>
      <td style="text-align: center">str</td>
      <td style="text-align: left">票价单位，JPY</td>
    </tr>
    <tr>
      <td style="text-align: center">baseDistance</td>
      <td style="text-align: center">float</td>
      <td style="text-align: left">基础距离，2.00</td>
    </tr>
    <tr>
      <td style="text-align: center">stepDistance</td>
      <td style="text-align: center">float</td>
      <td style="text-align: left">基础距离，1.00</td>
    </tr>
    <tr>
      <td style="text-align: center">distanceUnit</td>
      <td style="text-align: center">str</td>
      <td style="text-align: left">距离单位，km</td>
    </tr>
    <tr>
      <td style="text-align: center">validDistances</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">有效距离，长度为 21，默认值为 None</td>
    </tr>
    <tr>
      <td style="text-align: center">prices</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">票价，长度为 21，默认值为 None</td>
    </tr>
    <tr>
      <td style="text-align: center">validStops</td>
      <td style="text-align: center">list</td>
      <td style="text-align: left">有效站点，经过站点时将编号添加到列表里，默认为 [0]</td>
    </tr>
  </tbody>
</table>

<h4 id="步骤描述">步骤描述</h4>

<p>  程序整体步骤：</p>

<ol>
  <li>初始化变量，当前站点编号为 0，询问是否启动；接受到启动指令（回车）后开始行进（提示）。</li>
  <li>遇到停车指令（回车）后，切换站点编号为下一站点（+1），添加站点编号到 validStops。</li>
  <li>循环计算 validStops 中各站点的有效距离 validDistances（具体见下）。</li>
  <li>循环计算各站点的票价同时更新 prices。</li>
  <li>打印计费矩阵。</li>
  <li>接受到启动指令（回车）后继续行进（提示），重复 2~5 步骤直至重新回到站点 0。</li>
  <li>打印到达终点站提示信息，结束程序。</li>
</ol>

<p>  计算任意两个上下车站点间的有效距离的步骤：</p>

<ol>
  <li>已知上车站点 a 和下车站点 b，当两站点相同时有效距离为 0，如不同进入下一步骤。</li>
  <li>利用 lineStops 和 circleStops 两个变量判断 a 和 b 位于直线部分或循环圈部分。</li>
  <li>如果两站点都是直线部分，利用对称方式标准化为 1~3 的站点编号，直接计算之间距离为有效距离。</li>
  <li>如果两站点都是循环圈部分，利用 circleStops 进行循环遍历叠加计算正反距离，取较小的值为有效距离。</li>
  <li>如果一站点在直线部分、一站点在循环圈部分，对直线部分的站点（标准化后的 1~3 站点）计算正反距离，取较小的值为有效距离。</li>
  <li>返回有效距离。</li>
</ol>

<h3 id="程序模拟">程序模拟</h3>

<p>  根据以上思路，笔者采用 Python 实现了解决方案。源代码请见 <a href="https://gist.github.com/zhonger/3546f08c0fe5b3e4ea360288a6b15d42">Github Gist</a>。以下为程序模拟运行效果：</p>

<script src="https://asciinema.org/a/666775.js" id="asciicast-666775" async="true"></script>

<h2 id="结语">结语</h2>

<p>  虽然现有的公交线路大部分还是很规则的，不同时存在循环圈和直线的情况，计费也较为简单，但是思考特殊公交线路的计费方式也不失为一件有趣的事情。上面给出的分析和算法描述，也可以用其他编程语言实现，比如用前端编程语言就可以直接可视化整个公交计费过程。</p>

<h2 id="参考资料">参考资料</h2>

<ol>
  <li><a href="https://www.freecodecamp.org/chinese/news/dijkstras-shortest-path-algorithm-visual-introduction/">图文详解 Dijkstra 最短路径算法</a></li>
  <li><a href="https://zhangroup.aporc.org/images/files/1.pdf">周文峰等，《运筹与管理》，<strong>最优公交线路选择问题的数学模型及算法</strong>，2018</a></li>
  <li><a href="https://www.kantetsu.co.jp/cms/wp-content/uploads/2024/02/801e8420390b8e91fa42443e742d6c27.pdf">筑波大学循环线票价表</a></li>
</ol>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="algorithm" /><category term="algorithm" /><category term="算法" /><category term="program" /><category term="代码实现" /><category term="python" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">命令行工具开发指南——入门篇</title><link href="https://lisz.me/tech/cli/introduction.html" rel="alternate" type="text/html" title="命令行工具开发指南——入门篇" /><published>2024-05-29T17:15:00+09:00</published><updated>2024-05-29T17:15:00+09:00</updated><id>https://lisz.me/tech/cli/introduction</id><content type="html" xml:base="https://lisz.me/tech/cli/introduction.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  <strong>命令行工具</strong>（Command Line，Cli）作为我们日常开发常用的辅助性工具，几乎遍布于各种操作中。根据<strong>使用目的</strong>的不同大致可以分为以下几类：</p>

<ul>
  <li><strong>从模板中生成项目</strong>：比如使用 <code class="language-plaintext highlighter-rouge">npm init</code> 从空模版创建一个新的 NodeJS 项目，使用 <code class="language-plaintext highlighter-rouge">composer create-project laravel/laravel example-app</code> 创建一个全新的 Laravel 项目（PHP 项目）等。</li>
  <li><strong>启用开发者服务模式</strong>：比如使用 <code class="language-plaintext highlighter-rouge">python -m http.server 8000</code> 在 8000 端口开启一个临时 HTTP 服务器，使用 <code class="language-plaintext highlighter-rouge">bundle exec jekyll s</code> 在 4000 端口开启一个临时 Jekyll 服务器等。</li>
  <li><strong>特定功能交互</strong>：比如流行的 IP 信息查询工具 <a href="https://github.com/zu1k/nali">nali</a>、磁盘空间利用率和空余空间查询工具 <a href="https://github.com/muesli/duf">duf</a>、快速磁盘使用分析工具 <a href="https://github.com/dundee/gdu">gdu</a> 等。</li>
</ul>

<p>  其实任何编程语言都可以用来开发命令行工具，无论是常见的 Golang、Python、NodeJS、PHP、Java，还是 Rust、Ruby、C++、C 或者是古老的 Fortran 等。只是取决于所要实现的功能和具体的使用场景，开发者会采用合适的编程语言开发命令行工具。比如说，Linux 系统中包含了大量的命令行工具，基本上都是用 C 语言编写的，主要是因为 C 语言在 Linux 系统中的执行效率相对更高。对于一般高级编程语言，自带的包管理工具也是由自身高级编程语言编写的命令行工具。类似 Rust、Fortran 等编译型语言则需要通过编译生成<strong>二进制可执行文件</strong>后才能执行相应的任务。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 二进制可执行文件与源文件有何不同？ </div> </div> <div class="content"> <p>   二进制可执行文件是指源代码通过编译器编译成计算机可以直接识别的二进制码文件。二进制码文件是无法使用任何源码编辑器打开的，只能由操作系统调用执行或特别的二进制码查看器打开。一般来说，二进制可执行文件是很难跨越操作系统的，即针对不同的操作系统需要分别编译生成对应的二进制可执行文件。<u>尤其是当有其他静态库或者动态链接库依赖时，二进制可执行文件甚至无法跨主机运行</u>。 而源文件是可以在任何操作系统用源码编辑器打开的。大多时候商业公司为了保证源代码的商业版权，只会为用户提供应用的二进制可执行文件。（当然一般可能是包含图形用户界面的。）</p>



 </div> </div>
<h2 id="为何命令行而非图形界面">为何命令行而非图形界面</h2>

<p>  命令行可以说是操作系统应用和编程语言编写应用最基本的形式，图形（用户）界面（Graphic User Interface，GUI）则是在源代码的基础上提供可视化的交互方式、通过键鼠操作来降低用户使用的门槛。这也是为什么 Windows 操作系统比 Linux 操作系统更加流行的原因之一。<strong>但是有的时候，界面也有可能会成为用户学习和使用的累赘。</strong></p>

<h3 id="简单界面-vs-复杂界面">简单界面 vs 复杂界面</h3>

<p>  就拿代码编辑器来说，我们所熟知的“宇宙第一编辑器” Visual Studio 几乎支持所有编程语言，尤其是对于构建 C# 项目来说可以<strong>半代码半可视化修改</strong>。尽管这在很大程度上降低了开发者使用成本，但是学习 Visual Studio 编辑器本身的成本却很高。（说句老实话，笔者从大学本科开始接触 Visual Studio 到现在都没怎么学会使用，😂只会最基本的功能而已。）而且，在普通笔记本电脑上使用 Visual Studio 编辑器运行大型项目时，CPU 和内存资源极大可能会被大量占用，打开一个浏览器页面可能也很艰难。</p>

<p>  相比而言，同样由微软推出的 Visual Studio Code 则是简单界面的优秀代表。化繁为简，Visual Studio Code 本身仅支持最简单的功能：文件目录区、编辑区、终端区三部分布局，基本的代码高亮功能，插件功能，主题功能等。无论是 Python 开发者，还是 Golang 开发者，都能一打开直接上手，只是需要根据编程语言不同安装一些插件来提升开发效率而已。在系统占用资源方面，Visual Studio Code 比 Visual Studio 显著降低，尽管可能也会受安装插件的少量影响。当然有得也有舍，Visual Studio Code 中支持更多文件定义配置或命令行配置，对于没有学过 Linux 的用户可能会有点学习难度。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> Linux 哲学 </div> </div> <div class="content"> <p>  “一切皆文件”。任何系统、项目、工具都是由一系列的文件组成的，通过配置文件可以实现直接管理。</p>

<p>  虽然这是 Linux 系统设计的哲学思想，但其实是所有操作系统设计的哲学思想，只是顶层封装的程度有所不同。Windows 系统也是“一切皆文件”的，不然那些编辑器的配置都存在哪里了呢。相比 Linux 和 MacOS 系统而言，Windows 系统的顶层封装程度最高，用户对于底层文件的直接管理非常少，尤其是对系统级别的配置管理只能通过图形界面交互完成。MacOS 系统则是介于两者之间，顶层封装程度虽然高但也提供对大部分系统级别配置的直接管理，即可以通过修改文件来实现管理。尽管依旧存在有些系统级别配置难以直接修改，比如说操作系统启动项。</p>



 </div> </div>
<h3 id="更简单的命令行">更简单的命令行</h3>

<p>  界面在执行系列任务时一般需要多步操作，一顿点点点之后才能完成。当然如果图形界面和功能设计的比较合理的话，可能也只需要一步操作。当我们需要进行批量操作时，即使图形界面只需要一步操作，依旧需要一顿点点点。命令行则没有这种问题，只需要简单写个有循环的脚本即可循环调用命令行工具批量执行。</p>

<p>  另外，命令行工具仅在执行时会占用系统资源，一旦完成即可完全释放。图形界面应用一般需要常驻后台，虽然优化得好的时候所占用的系统资源也可忽略不计，但是还是会有后台进程的。</p>

<p>  尽管命令行工具极少会有显式的界面交互，但是也可以在终端提供非常丰富的命令行交互、功能解释、自动补全、自动建议等。用户使用起来一般没有太大问题，只需要调用子命令和参数即可实现操作。</p>

<h2 id="命令行工具开发">命令行工具开发</h2>

<h3 id="设计标准和规范">设计标准和规范</h3>

<p>  命令行工具开发通常依据两个标准和规范进行：POSIX (Protable Operating System Interface，可移植操作系统接口) 标准和 GNU (GNU’s Not Unix) 项目。POSIX 标准是 IEEE 为维护操作系统间适配性而制定的一系列标准，其中一个标准定义了命令行程序的语法和语义。GNU 旨在创建与 Unix 兼容的自由软件，其中一个子项目 <a href="https://www.gnu.org/software/coreutils/">GNU Coreutils</a> 提供了很多常用的命令行程序，比如 <code class="language-plaintext highlighter-rouge">ls</code>、<code class="language-plaintext highlighter-rouge">cp</code> 和 <code class="language-plaintext highlighter-rouge">mv</code> 等。据此为命令行程序建立了以下的设计标准和规范：</p>

<ul>
  <li>单字母标志 (single-letter flag) 以一个短横线 <code class="language-plaintext highlighter-rouge">-</code> 开始，且可以合并使用：比如 <code class="language-plaintext highlighter-rouge">-d</code> (全称 <code class="language-plaintext highlighter-rouge">--debug</code>) 和 <code class="language-plaintext highlighter-rouge">-v</code> (全称 <code class="language-plaintext highlighter-rouge">--version</code>) 合并使用 <code class="language-plaintext highlighter-rouge">-dv</code> 来以调试模式输出命令行版本号。</li>
  <li>长标志 (long flag) 以两个短横线 <code class="language-plaintext highlighter-rouge">--</code> 开始，但无法合并使用：比如 <code class="language-plaintext highlighter-rouge">--debug</code> 或 <code class="language-plaintext highlighter-rouge">--version</code> 可以被命令行正常解析，但 <code class="language-plaintext highlighter-rouge">--debugversion</code> 无法被正常解析。</li>
  <li>选项 (Options) 跟在单字母标志后没有分隔符，但跟在长标志后使用等号 <code class="language-plaintext highlighter-rouge">=</code> 来分隔标志和选项值：比如 <code class="language-plaintext highlighter-rouge">-n example</code> 和 <code class="language-plaintext highlighter-rouge">--name=example</code> 分别为单字母标志和长标志的选项用法，二者完全等价。</li>
  <li>参数 (Args) 跟在标志或选项之后时没有任何分隔符，仅有空格：比如 <code class="language-plaintext highlighter-rouge">curl -o out.html https://www.google.com</code> 中的 <code class="language-plaintext highlighter-rouge">https://www.google.com</code> 是参数，一般用法类似 <code class="language-plaintext highlighter-rouge">curl [Options] &lt;Arg&gt;</code>。</li>
  <li>子命令 (Sub command) 与主命令之间没有分隔符，仅有空格：比如 <code class="language-plaintext highlighter-rouge">git commit</code> 中 <code class="language-plaintext highlighter-rouge">git</code> 是主命令、<code class="language-plaintext highlighter-rouge">commit</code> 是子命令。</li>
  <li>单独的两个短横线 <code class="language-plaintext highlighter-rouge">--</code>（后不接标志）表示标志或选项的结束和参数的开始：比如 <code class="language-plaintext highlighter-rouge">rm -- -f</code> 中的 <code class="language-plaintext highlighter-rouge">-f</code> 表示的是要删除的文件 <code class="language-plaintext highlighter-rouge">-f</code>，而不是强制删除文件的选项。</li>
</ul>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 提示 </div> </div> <div class="content"> <p>  按照以上设计标准和规范开发的命令行工具使用体验会与常用的命令保持一致，对于用户来说非常容易上手，这也是制定设计标准和规范的主要原因。</p>



 </div> </div>
<h3 id="功能设计">功能设计</h3>

<p>  核心功能设计主要是指命令行工具所支持的子命令、参数、选项设计。其中，子命令表示功能集合，参数表示输入输出变量，选项表示功能的微调。如下所示为笔者开发的命令行工具 <a href="../../../tech/project/pictl.html">pictl</a> （基于 Python 语言开发）的帮助信息。目前提供四个子命令：<code class="language-plaintext highlighter-rouge">config</code>（配置基本信息），<code class="language-plaintext highlighter-rouge">compress</code>（压缩任意图片为 <code class="language-plaintext highlighter-rouge">webp</code> 格式）,<code class="language-plaintext highlighter-rouge">upload</code>（上传图片）和 <code class="language-plaintext highlighter-rouge">cup</code>（压缩并上传图片）。全局只支持 <code class="language-plaintext highlighter-rouge">-h</code>（<code class="language-plaintext highlighter-rouge">--help</code>）打印帮助信息和 <code class="language-plaintext highlighter-rouge">-V</code>（<code class="language-plaintext highlighter-rouge">--version</code>）打印版本信息两个选项。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl
Usage: pictl <span class="o">[</span>OPTIONS] COMMAND <span class="o">[</span>ARGS]...

  A <span class="nb">command </span>line tool <span class="k">for </span>image processing and uploading <span class="o">(</span>ex. S3-type<span class="o">)</span><span class="nb">.</span>

  Now it supports:
    - transformation from other image types to <span class="sb">`</span>webp<span class="sb">`</span> image as well as
      image compression.
    - image file uploading to AWS S3 or Cloudflare R2.

Options:
  <span class="nt">-V</span>, <span class="nt">--version</span>  Show the pictl version.
  <span class="nt">-h</span>, <span class="nt">--help</span>     Show this message and exit.

Commands:
  compress  Compress any image into <span class="sb">`</span>webp<span class="sb">`</span> image.
  config    Operations <span class="k">for </span>the config file <span class="sb">`</span>~/.pictlrc<span class="sb">`</span><span class="nb">.</span>
  cup       Compress image and upload to remote storage <span class="o">(</span>compress and...
  upload    Upload the file to remote storage.
</code></pre></div></div>

<h4 id="子命令">子命令</h4>

<p>  <strong>子命令是否越少越好或者越多越好？亦或是不多不少比较好？</strong>其实，根据实际功能需求的不同子命令的数量会有很大的差异。比如上面提到的 pictl 目前所支持的子命令只有 4 个，curl 不支持子命令但支持选项超过 20 个，git 支持的常用子命令多达 22 个（如下所示，实际子命令可能接近 100 个），docker 支持的子命令超过 30 个。子命令实际上是可以多层迭代调用的，即可以存在多层级。但是在功能设计时，一般将对同一对象操作的功能归类到同一子命令下面，形成多层级子命令。当然为了简化子命令的层级调用，最多的实践方式就是类似于 git 中的<strong>用选项来代替多层的子命令</strong>。比如 <code class="language-plaintext highlighter-rouge">git branch</code> 子命令是对分支（branch）的列举（<code class="language-plaintext highlighter-rouge">git branch -l</code>）、创建（<code class="language-plaintext highlighter-rouge">git branch &lt;name&gt;</code>）和删除（<code class="language-plaintext highlighter-rouge">git branch -d &lt;name&gt;</code>）的功能集合。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>git <span class="nt">-h</span>
usage: git <span class="o">[</span><span class="nt">-v</span> | <span class="nt">--version</span><span class="o">]</span> <span class="o">[</span><span class="nt">-h</span> | <span class="nt">--help</span><span class="o">]</span> <span class="o">[</span><span class="nt">-C</span> &lt;path&gt;] <span class="o">[</span><span class="nt">-c</span> &lt;name&gt;<span class="o">=</span>&lt;value&gt;]
           <span class="o">[</span><span class="nt">--exec-path</span><span class="o">[=</span>&lt;path&gt;]] <span class="o">[</span><span class="nt">--html-path</span><span class="o">]</span> <span class="o">[</span><span class="nt">--man-path</span><span class="o">]</span> <span class="o">[</span><span class="nt">--info-path</span><span class="o">]</span>
           <span class="o">[</span><span class="nt">-p</span> | <span class="nt">--paginate</span> | <span class="nt">-P</span> | <span class="nt">--no-pager</span><span class="o">]</span> <span class="o">[</span><span class="nt">--no-replace-objects</span><span class="o">]</span> <span class="o">[</span><span class="nt">--bare</span><span class="o">]</span>
           <span class="o">[</span><span class="nt">--git-dir</span><span class="o">=</span>&lt;path&gt;] <span class="o">[</span><span class="nt">--work-tree</span><span class="o">=</span>&lt;path&gt;] <span class="o">[</span><span class="nt">--namespace</span><span class="o">=</span>&lt;name&gt;]
           <span class="o">[</span><span class="nt">--super-prefix</span><span class="o">=</span>&lt;path&gt;] <span class="o">[</span><span class="nt">--config-env</span><span class="o">=</span>&lt;name&gt;<span class="o">=</span>&lt;envvar&gt;]
           &lt;<span class="nb">command</span><span class="o">&gt;</span> <span class="o">[</span>&lt;args&gt;]

These are common Git commands used <span class="k">in </span>various situations:

start a working area <span class="o">(</span>see also: git <span class="nb">help </span>tutorial<span class="o">)</span>
   clone     Clone a repository into a new directory
   init      Create an empty Git repository or reinitialize an existing one

work on the current change <span class="o">(</span>see also: git <span class="nb">help </span>everyday<span class="o">)</span>
   add       Add file contents to the index
   <span class="nb">mv        </span>Move or rename a file, a directory, or a symlink
   restore   Restore working tree files
   <span class="nb">rm        </span>Remove files from the working tree and from the index

examine the <span class="nb">history </span>and state <span class="o">(</span>see also: git <span class="nb">help </span>revisions<span class="o">)</span>
   bisect    Use binary search to find the commit that introduced a bug
   diff      Show changes between commits, commit and working tree, etc
   <span class="nb">grep      </span>Print lines matching a pattern
   log       Show commit logs
   show      Show various types of objects
   status    Show the working tree status

grow, mark and tweak your common <span class="nb">history
   </span>branch    List, create, or delete branches
   commit    Record changes to the repository
   merge     Join two or more development histories together
   rebase    Reapply commits on top of another base tip
   reset     Reset current HEAD to the specified state
   switch    Switch branches
   tag       Create, list, delete or verify a tag object signed with GPG

collaborate <span class="o">(</span>see also: git <span class="nb">help </span>workflows<span class="o">)</span>
   fetch     Download objects and refs from another repository
   pull      Fetch from and integrate with another repository or a <span class="nb">local </span>branch
   push      Update remote refs along with associated objects

<span class="s1">'git help -a'</span> and <span class="s1">'git help -g'</span> list available subcommands and some
concept guides. See <span class="s1">'git help &lt;command&gt;'</span> or <span class="s1">'git help &lt;concept&gt;'</span>
to <span class="nb">read </span>about a specific subcommand or concept.
See <span class="s1">'git help git'</span> <span class="k">for </span>an overview of the system.
</code></pre></div></div>

<p>  功能设计中对子命令的设计是由核心功能驱动的。在条件允许的情况下，尽可能压缩子命令列表是有利于用户上手使用的。为了命令行工具使用时命令不会过长，建议提供比较常用的默认选项值从而减少用户自定义的可能性。当然，对全部选项的单字母标志支持也是有效缩短命令长度的方法之一。除此之外，提供配置文件也是非常可取的方法。<code class="language-plaintext highlighter-rouge">git</code>、<code class="language-plaintext highlighter-rouge">curl</code>、<code class="language-plaintext highlighter-rouge">wget</code>、<code class="language-plaintext highlighter-rouge">docker</code> 等都提供对应的配置文件 <code class="language-plaintext highlighter-rouge">.gitconfig</code>、<code class="language-plaintext highlighter-rouge">.curlrc</code>、<code class="language-plaintext highlighter-rouge">.wgetrc</code> 和 <code class="language-plaintext highlighter-rouge">.dockerrc</code> 进行全局配置定义，当然 <code class="language-plaintext highlighter-rouge">pictl</code> 也提供 <code class="language-plaintext highlighter-rouge">.pictlrc</code> 配置文件。</p>

<h4 id="代码架构">代码架构</h4>

<p>  尽管不同编程语言因为自身原因（编译型或解析型语言，面向对象或面向过程等），可能会有不同的代码架构偏好，我们可能依然可以采用一个宽泛且可行的通用代码架构思路——<strong>面向功能开发</strong>。这里的功能可以是一个操作或者一个对象，比如说压缩图片这样一个功能，主要是将输入图片转换成想要的图片格式输出。除此之外，可能还可以提供压缩质量控制、尺寸控制、自动重命名、自动加水印等微调功能。这些微调功能虽然实际上可以完全独立，但由于是压缩图片功能的附属功能，最好采用选项调用的方式来实现。代码架构上，子命令调用对应的函数会成为<strong>顶级函数</strong>。其他微调功能虽然是独立函数或对象，<u>但仅在子命令函数中被调用</u>。实际开发过程中，微调功能并非一开始就包括所有，大部分会作为一些特性逐步增加到主代码中。这意味着，对用户来说新增一个微调功能仅仅多了一个子命令下的选项支持，不需要重新学习和适应。</p>

<p>  如果压缩图片功能的基础（图片转换）需要自行编写代码，那么可能需要考虑到很多种图片格式的相互转换，这在具体代码实践中是非常麻烦的。比较可行的方法之一是，可以采用一种图片格式作为中间标准格式，每次新增一种图片格式的支持只需要增加与中间标准格式的相互转换即可。当然这里采用的中间标准格式可能是需要高保真的（或者高分辨率的），避免在用了中间标准格式转换之后图片质量自动下降。</p>

<h3 id="错误处理和自动建议">错误处理和自动建议</h3>

<p>  当我们打算开发一款命令行工具时，除了核心功能是必不可少的，错误处理和自动建议也是需要考虑在内的。了解这点最简单的办法就是从实例中学习。如下所示，是将 git 提交修改（commit）的命令 <code class="language-plaintext highlighter-rouge">git commit</code> 故意打成为 <code class="language-plaintext highlighter-rouge">git commi</code> 的输出结果。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>git commi
git: <span class="s1">'commi'</span> is not a git command. See <span class="s1">'git --help'</span><span class="nb">.</span>

The most similar commands are
 commit
 column
 config
</code></pre></div></div>

<p>  当命令行工具接收到用户输入时，首先需要做的就是对输入的合法性进行验证：一方面，是否存在不可用的子命令或非法使用（比如错误迭代调用）；另一方面，尝试解析参数并验证完整性。这两部分的验证会尽可能地将错误的原因和可能有用的建议提示给用户。类似上面，命令行工具会提示用户使用的子命令不存在，请使用 <code class="language-plaintext highlighter-rouge">git --help</code> 了解更多。另外，会将输入的子命令字符串与所有合法的子命令字符串进行对比，根据相似性大小排列向用户自动建议。至于对选项的解析相对来说可以比较宽容一点，即直接忽略不合法的选项声明、仅读取合法的选项声明，因此可以不返回相关错误提醒及帮助。</p>

<p>  当子命令、参数、选项均通过验证之后，命令行工具的功能代码执行时也会发生错误。如下所示，在一个非 git 项目文件夹内执行 <code class="language-plaintext highlighter-rouge">git commit</code> 时，命令行工具会将具体的错误直接提示：当前目录或任何父目录不是一个 git 项目，不存在 <code class="language-plaintext highlighter-rouge">.git</code> 文件夹。这里需要注意的是，通常我们可能对错误或异常的处理会直接使用编程语言本身提供的方式，比如 Python 语言中的 <code class="language-plaintext highlighter-rouge">raise ValueError("'element' parameter is not defined.")</code>。当然这种错误处理本身没有任何问题，只不过同时还会输出错误发生的代码位置等其他与用户使用无关的信息，尽管这种信息在开发过程中有利于开发者调试代码。出于为用户考虑，错误处理信息默认应该以简单可读的方式打印出来、且仅限于提示关键信息。如果用户或者开发者想要了解更多，可以通过 <code class="language-plaintext highlighter-rouge">-v</code> 或者 <code class="language-plaintext highlighter-rouge">--verbose</code> 选项来打印更多调试信息。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>git commit
fatal: not a git repository <span class="o">(</span>or any of the parent directories<span class="o">)</span>: .git
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> -v 和 -V </div> </div> <div class="content"> <p>  通常来说，<code class="language-plaintext highlighter-rouge">-v</code>（<code class="language-plaintext highlighter-rouge">--verbose</code>）和<code class="language-plaintext highlighter-rouge">-V</code>（<code class="language-plaintext highlighter-rouge">--version</code>）会被认为是不同的选项，分别用于开启调试模式和打印版本信息。当用户发现命令行工具使用出现不可预知的问题（错误提示与实际原因不符或其他不在开发者知晓范围内的问题）时，需要开启调试模式来排除本地环境的问题，同时也可能在向开发者反馈问题时提供足够的信息来帮助定位问题的原因。版本信息通常也是提交反馈问题时所需的必要信息。</p>



 </div> </div>
<h3 id="技术选型">技术选型</h3>

<p>  技术选型指的是<strong>用哪种编程语言以及哪种框架来实现命令行工具</strong>。<strong>第一种</strong>是从开发者自身熟悉和掌握的编程语言出发，尽可能降低编程语言上的学习成本。不过对于已经掌握一门或多门编程语言的开发者来说，学习新编程语言可能也不是件难事。<strong>第二种</strong>是从应用场景出发：如果是开发为机器学习应用的前置或后置步骤的数据准备、数据处理、可视化等功能的命令行工具，采用 Python 语言可能会更加方便有效；如果是开发包含与操作系统交互的网络分析、磁盘分析等功能的命令行工具，采用 Rust 或者 Golang 语言可能会比较得心应手；如果是开发与平台接口交互（如 Web API 调用）的命令行工具，采用 NodeJS 语言可能适配性更佳。详细请查看参考资料 [1-5]。</p>

<h2 id="结语">结语</h2>

<p>  诚然，命令行工具并非是所有用户的喜爱，但的确是最小化操作步骤、提升效率的方式之一。以上所述的命令行工具开发指南入门篇大部分是在理论层面上的，至于在不同编程语言上的实践后续也计划展开：</p>

<ul>
  <li>《命令行工具开发指南 —— Python 实践篇》</li>
  <li>《命令行工具开发指南 —— Rust 实践篇》</li>
  <li>《命令行工具开发指南 —— Golang 实践篇》</li>
  <li>《命令行工具开发指南 —— NodeJS 实践篇》</li>
</ul>

<p>  有关于命令行工具开发进阶的依赖管理、编译构建、信号和日志处理、用户输入验证、自动补全（Auto Completion）、文档、测试和发布等也将在实践篇中分别具体阐述。</p>

<h2 id="参考资料">参考资料</h2>

<ol>
  <li><a href="https://juejin.cn/post/7178666619135066170">快手数平前端团队 – 掌握 Node CLI 工具开发，为团队研发提效！</a></li>
  <li><a href="https://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html">阮一峰的网络日志 – Node.js 命令行程序开发教程</a></li>
  <li><a href="https://suibianxiedianer.github.io/rust-cli-book-zh_CN/README_zh.html">Rust 中的命令行应用</a></li>
  <li><a href="https://pythonguidecn.readthedocs.io/zh/latest/scenarios/cli.html">命令行应用 - Python 最佳实践指南</a></li>
  <li><a href="https://tonybai.com/2023/03/25/the-guide-of-developing-cli-program-in-go/">Tony Bai – Go 开发命令行程序指南</a></li>
  <li><a href="https://en.wikipedia.org/wiki/POSIX">Wikipedia – POSIX</a></li>
</ol>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="cli" /><category term="command line" /><category term="命令行" /><category term="develop" /><category term="开发" /><category term="tool" /><category term="工具" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">图片处理及上传命令行工具 —— PICTL</title><link href="https://lisz.me/tech/project/pictl.html" rel="alternate" type="text/html" title="图片处理及上传命令行工具 —— PICTL" /><published>2023-06-13T13:41:01+09:00</published><updated>2023-06-13T13:41:01+09:00</updated><id>https://lisz.me/tech/project/pictl</id><content type="html" xml:base="https://lisz.me/tech/project/pictl.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  自从博客从 WordPress 转到静态博客（先 Hexo 后 Jekyll）之后，文章的图片处理、图片上传就成了一个不大顺畅的事情。最先是使用了 <a href="https://vgy.me">vgy.me</a> 提供的免费图床，支持直接从剪切板上传，操作上相对比较简单，也不需要任何本地存储。不过后来 vgy.me 进行了升级改版，原先的剪切板上传功能也不再支持了，偶尔还出现图片像素被降低、丢失的问题。同时，考虑到 WebP 格式可能会适合博客使用，而 vgy.me 还不支持该格式。于是开始切换到 “对象存储 + CDN” 的方案。本地准备好的 PNG 格式图片，先通过 <a href="https://developers.google.com/speed/webp/">cwebp</a> 命令行转成 WebP 格式图片，再通过 <a href="https://github.com/gee1k/uPic">uPic</a> 工具修改文件名后上传到对象存储。由于此前采用的是腾讯云的 COS 对象存储和 CDN，经常面临着 SSL 证书更新等琐碎的事情。这样一来，整体的效率实际上并不高，只能说勉强接受。</p>

<h3 id="现有工具及存储考察">现有工具及存储考察</h3>

<p>  为此，也对其他工具和对象存储进行了考察。</p>

<p>  <a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 是一款集客户端 UI 和命令行于一体的图片上传工具，虽然可以利用命令串联的方式简单将图片格式转换和上传两步变成一步，但还是有那么点不舒服的地方，比如 PicGo 不提供文件名修改（为固定长度随机字符串）的特性。而 uPic 本身关注于客户端桌面交互，不提供命令行接口。</p>

<p>  至于对象存储，国内各家云服务厂商提供的都需要自行手动更新 SSL 证书，且收费。尽管腾讯云 CDN 目前老用户可以每月领券免费使用，但一旦忘记就开始被收费了。实际上也有逐步转向收费的趋势。国外各家云服务厂商基本上都需要收费使用对象存储或者 CDN，大差不差。</p>

<p>  当然，网上一直有一种 “Backblaze B2 + Cloudflare” 的解决方案。由于 B2 本身存储和读写操作都有免费额度，流量需要收费，且无法自定义域名，而 B2 和 Cloudflare 同属于宽带联盟（内部流量免费），Cloudflare 还提供 URL 重写功能，这种解决方案一时成为了潮流。不过，B2 的访问链接是中间带着一串参数，重写之后仍然还是有部分参数，最终的 URL 并不是那么朴素。总的来说，还是有那么点别扭。</p>

<h3 id="r2-的出现">R2 的出现</h3>

<p>  因此观望了许久，直到 Cloudflare 推出了 R2。R2 是一款对标 AWS S3 的产品，基于 Cloudflare 对宽带联盟的承诺而构建，为存储对象提供零成本出口，实际上就是免费 CDN。由于 Cloudflare 本身就是一家 CDN 服务商，自定义对象存储访问域名、自动生成部署 SSL 证书这些事情就变得轻而易举了。R2 提供 10GB 的免费存储，读操作每月免费 1000 万次，写、更新和删除操作每月免费 100 万次。这对于一般的静态博客来说，应该完全足够了，即使超出了免费额度，超出部分收费也相较其他云服务厂商便宜一些。</p>

<p>  对笔者而言，R2 产品将对象存储和 CDN 两款产品有机地结合起来，解决了静态博客图片对外访问前的“最后一公里”。于是想从 COS 迁移到 R2，无奈 uPic 这个时候卖了个“破绽”。uPic 似乎在开始转向商业收费，Github 上不再发布新版本，而仅在 Appstore 上继续更新对 R2 的支持。当然，Appstore 上的 uPic 是收费的（4.99 美元，其实也不贵）。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  R2 虽然说是对标 AWS S3，但是并没有完整实现所有 API 接口，所以目前 Github 上发布的 uPic 版本无法兼容。尽管可以自行通过修改 uPic 的开源代码来实现兼容，但毕竟修改别人的代码的成本还是有一点高的。</p>



 </div> </div>
<h2 id="开个新项目">开个新项目</h2>

<p>  在充分梳理个人使用需求之后，还是决定开个新项目——开发一款简单易用的命令行工具 PICTL（全称 <strong>Pi</strong>cture <strong>C</strong>on<strong>t</strong>ro<strong>l</strong>）。该工具须具备以下特性：</p>

<ul>
  <li>考虑图片的存储空间大小和网页加载时长，所有图片应被压缩并转成 WebP 格式；</li>
  <li>所有图片的名称应被修改成一个固定长度随机字符串，并支持上传到类 S3 的对象存储；</li>
  <li>简单易用，命令行优先，无网页或桌面交互界面；</li>
  <li>（可选）自动添加水印；</li>
  <li>（可选）根据设定自动调整图片尺寸；</li>
  <li>（可选）可以直接从剪切板读取图片。</li>
</ul>

<h2 id="架构设计">架构设计</h2>

<p>  根据所列出的特性，这款命令行工具主要的模块就是：<strong>图片处理模块</strong>和<strong>上传模块</strong>，架构如下图所示。</p>

<p><img src="https://i.lisz.top/blog/Gl8qhI.webp" alt="PICTL 架构图 The architecture of PICTL" /></p>

<p>  图片处理模块包括图片压缩、图片格式转换、图片水印、尺寸调整等功能，可以进行无缝横向扩展。上传模块主要包括对于三种存储方式的支持：<strong>第一类</strong>是最为广泛的类 S3 对象存储，如 R2、AWS S3 及国内外云服务厂商各种对象存储等，<strong>第二类</strong>是目前仍然在博客中广泛流行的第三方图床，如 <a href="https://sm.ms">SM.MS</a>、<a href="https://vgy.me">vgy.me</a>、<a href="https://github.com/chevereto/chevereto">chevereto</a> 类型图床等，<strong>第三类</strong>是自托管 Git 平台和 FTP 平台。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 特此声明 </div> </div> <div class="content"> <p>  鉴于 Github、Gitlab、Gitee 等公共代码托管平台均禁止把 Git 仓库作为图床的做法，本工具仅支持自建 Git 平台，如自建 Gitlab 和 Gitlab Pages。如试图上传到公共代码托管平台，本工具会自行中断上传。</p>



 </div> </div>
<p>  本工具由于仅支持命令行，所以计划用 Python 和 <a href="https://click.palletsprojects.com/">Click</a> 进行开发。虽然借助 <a href="https://google.github.io/python-fire/">Google Fire</a> 也可以快速开发命令行工具，但其使用方式上与原生 *nix 的命令行工具有所不同。相比之下，用 Click 开发可能会麻烦一点，但能够开发出更类原生的 Python 命令行工具。当然，目前开发上还是比较喜欢使用 Rust 或者 Go 语言来开发高性能的命令行工具。不过，本工具只是做一些非常简单的工作，没有性能上的瓶颈，用 Python 开发也足够了。</p>

<h2 id="开发计划">开发计划</h2>

<p>  请移步 <a href="https://github.com/users/zhonger/projects/5">Github Project</a> 了解更多。</p>

<h2 id="使用方法">使用方法</h2>

<p>  目前，PICTL 已经在 <a href="https://github.com/zhonger/pictl/releases">Github</a> 和 <a href="https://pypi.org/project/pictl/">PyPI</a> 同步发布了 v0.1.0 版本。该版本实现了以上架构图中的基本功能，即特性中的前三点必要项。接下来介绍一下如何安装和使用本工具。</p>

<h3 id="安装">安装</h3>

<p>  目前支持两种安装方式：<strong>源码安装</strong>和 <strong>PIP 安装</strong>，后续将增加对于 brew 的支持。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  安装前，请务必确保已满足 Python 版本高于 3.10 的条件。</p>



 </div> </div>
<h4 id="源码安装">源码安装</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/zhonger/pictl
<span class="nb">cd </span>pictl
pip3 <span class="nb">install</span> <span class="nb">.</span>
</code></pre></div></div>

<h4 id="pip-安装">PIP 安装</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>pictl
</code></pre></div></div>

<h3 id="使用">使用</h3>

<h4 id="显示版本">显示版本</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl <span class="nt">-V</span>
PICTL 0.1.0
</code></pre></div></div>

<h4 id="列举所有支持命令">列举所有支持命令</h4>

<p>  目前 v0.1.0 版本包含四个子命令：config（配置管理），compress（图片处理），upload（上传文件）和 cup（一键式压缩、转换、上传）。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl
Usage: pictl <span class="o">[</span>OPTIONS] COMMAND <span class="o">[</span>ARGS]...

  A <span class="nb">command </span>line tool <span class="k">for </span>image processing and uploading <span class="o">(</span>ex. S3-type<span class="o">)</span><span class="nb">.</span>

  Now it supports:
    - transformation from other image types to <span class="sb">`</span>webp<span class="sb">`</span> image as well as
      image compression.
    - image file uploading to AWS S3 or Cloudflare R2.

Options:
  <span class="nt">-V</span>, <span class="nt">--version</span>  Show the pictl version.
  <span class="nt">-h</span>, <span class="nt">--help</span>     Show this message and exit.

Commands:
  compress  Compress any image into <span class="sb">`</span>webp<span class="sb">`</span> image.
  config    Operations <span class="k">for </span>the config file <span class="sb">`</span>~/.pictlrc<span class="sb">`</span><span class="nb">.</span>
  cup       Compress image and upload to remote storage <span class="o">(</span>compress and...
  upload    Upload the file to remote storage
</code></pre></div></div>

<h4 id="config-子命令">config 子命令</h4>

<p>  config 子命令包含 add（添加配置）、delete（删除配置）、info（查看所有配置）和 init（初始化配置）四种操作。使用本工具需要先执行初始行配置操作，再执行其他配置操作。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config
Usage: pictl config <span class="o">[</span>OPTIONS] COMMAND <span class="o">[</span>ARGS]...

  Operations <span class="k">for </span>the config file <span class="sb">`</span>~/.pictlrc<span class="sb">`</span><span class="nb">.</span>

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

Commands:
  add     Add configs to the config file.
  delete  Delete config group from the config file.
  info    Check the configs.
  init    Initialize config file with default configs.
</code></pre></div></div>

<p>  如下所示，使用 <code class="language-plaintext highlighter-rouge">pictl config init</code> 命令初始化配置。第二次执行时，由于已存在配置文件，会提示已经初始化过了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config init
The settings has been initilized <span class="k">in</span> /home/ubuntu/.pictlrc.

╰─<span class="nv">$ </span>pictl config init
/home/ubuntu/.pictlrc already exists.
Please add settings or change it manaully.
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">pictl config info</code> 以 JSON 格式打印所有配置信息。配置文件默认采用 TOML 格式。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config info
<span class="o">{</span>
    <span class="s1">'basic'</span>: <span class="o">{</span><span class="s1">'length'</span>: 6, <span class="s1">'ntype'</span>: <span class="s1">'random'</span>, <span class="s1">'algorithm'</span>: <span class="s1">'sha1'</span><span class="o">}</span>,
<span class="o">}</span>

╰─<span class="nv">$ </span><span class="nb">cat</span> ~/.pictlrc
<span class="o">[</span>basic]
length <span class="o">=</span> 6
ntype <span class="o">=</span> <span class="s2">"random"</span>
algorithm <span class="o">=</span> <span class="s2">"sha1"</span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">pictl config add</code> 以命令行交互方式添加配置（以下是 R2 的例子）。添加完成后可以再次查看新增后的所有配置。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config add
<span class="k">******</span> Please input these information <span class="k">******</span>
Group Name <span class="o">(</span>default <span class="s1">'blog'</span><span class="o">)</span>: <span class="nb">test</span>
<span class="o">[</span>?] Type: : R2
   S3
 <span class="o">&gt;</span> R2

Account ID: testid
Bucket Name: <span class="nb">test
</span>Key: testkey
Secret: testsecret
Prefix <span class="o">(</span>Default is None<span class="o">)</span>:
Access Url <span class="o">(</span>like <span class="sb">`</span>https://i.example.com<span class="sb">`</span><span class="o">)</span>: https://i.example.com
New group <span class="s1">'test'</span> has been saved <span class="k">in</span> /Users/zhonger/.pictlrc.

╰─<span class="nv">$ </span>pictl config info
<span class="o">{</span>
    <span class="s1">'basic'</span>: <span class="o">{</span><span class="s1">'length'</span>: 6, <span class="s1">'ntype'</span>: <span class="s1">'random'</span>, <span class="s1">'algorithm'</span>: <span class="s1">'sha1'</span><span class="o">}</span>,
    <span class="s1">'test'</span>: <span class="o">{</span>
        <span class="s1">'endpoint'</span>: <span class="s1">'https://testid.r2.cloudflarestorage.com/test'</span>,
        <span class="s1">'bucket'</span>: <span class="s1">'test'</span>,
        <span class="s1">'prefix'</span>: <span class="s1">''</span>,
        <span class="s1">'key'</span>: <span class="s1">'testkey'</span>,
        <span class="s1">'secret'</span>: <span class="s1">'testsecret'</span>,
        <span class="s1">'url'</span>: <span class="s1">'https://i.example.com'</span>,
        <span class="s1">'type'</span>: <span class="s1">'R2'</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">pictl config delete</code> 命令可以选择删除远程配置组（此处为了展示，除 test 外还添加了其他配置组）。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl config delete
<span class="o">[</span>?] Please <span class="k">select </span>one group: : <span class="nb">test
   </span>blog
   cover
 <span class="o">&gt;</span> <span class="nb">test

test </span>has been deleted.
</code></pre></div></div>

<h4 id="compress-子命令">compress 子命令</h4>

<p>  本子命令输入参数为<strong>图片文件名</strong>，可以带路径。输出图片会被保存在命令执行位置，<strong>而非原图片所在目录</strong>。执行该操作后，图片还不会被上传，需要继续使用 upload 命令完成上传。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl compress <span class="nt">-h</span>
Usage: pictl compress <span class="o">[</span>OPTIONS] FILENAME

  Compress any image into <span class="sb">`</span>webp<span class="sb">`</span> image.

  FILENAME is the name of the file to compress.

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

╰─<span class="nv">$ </span>pictl compress ../../pictl/fig01.png
The output file is EVyP2J.webp
</code></pre></div></div>

<h4 id="upload-子命令">upload 子命令</h4>

<p>  如下所示，使用 <code class="language-plaintext highlighter-rouge">pictl upload</code> 命令加上指定上传文件名和远程配置组即可完成上传。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl upload <span class="nt">-h</span>
Usage: pictl upload <span class="o">[</span>OPTIONS] FILENAME GROUP

  Upload the file to remote storage.

  FILENAME is the name of the file to upload.
  GROUP is the group <span class="k">in </span>the config file you want to use.

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

╰─<span class="nv">$ </span>pictl upload EVyP2J.webp <span class="nb">test
</span>Direct URL: https://i.example.com/EVyP2J.webp
Markdown: <span class="o">![</span>EVyP2J.webp]<span class="o">(</span>https://i.example.com/EVyP2J.webp<span class="o">)</span>
HTML Code: &lt;img <span class="nv">src</span><span class="o">=</span><span class="s2">"https://i.example.com/EVyP2J.webp"</span> <span class="nv">alt</span><span class="o">=</span><span class="s2">"EVyP2J.webp"</span> /&gt;
</code></pre></div></div>

<h4 id="cup-子命令">cup 子命令</h4>

<p>  cup 子命令 = compress 子命令 + upload 子命令，仅需要指定初始图片文件和远程配置组，即可一步完成图片压缩、格式转换、修改名称、上传。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>pictl cup <span class="nt">-h</span>
Usage: pictl cup <span class="o">[</span>OPTIONS] FILENAME GROUP

  Compress image and upload to remote storage <span class="o">(</span>compress and upload<span class="o">)</span><span class="nb">.</span>

  FILENAME is the name of the file to compress.
  GROUP is the group <span class="k">in </span>the config file you want to use.

Options:
  <span class="nt">-h</span>, <span class="nt">--help</span>  Show this message and exit.

╰─<span class="nv">$ </span>pictl cup ../../pictl/fig01.png <span class="nb">test
</span>The output file is Gl8qhI.webp
Direct URL: https://i.example.com/Gl8qhI.webp
Markdown: <span class="o">![</span>Gl8qhI.webp]<span class="o">(</span>https://i.example.com/Gl8qhI.webp<span class="o">)</span>
HTML Code: &lt;img <span class="nv">src</span><span class="o">=</span><span class="s2">"https://i.example.com/Gl8qhI.webp"</span> <span class="nv">alt</span><span class="o">=</span><span class="s2">"Gl8qhI.webp"</span> /&gt;
</code></pre></div></div>

<h2 id="todo">TODO</h2>

<p>  目前的 v0.1.0 版本还比较简陋，不过已经能满足笔者的必要需求，有效提升效率。后续将继续完善、新增功能：</p>

<ul>
  <li>自动补全（shell completion），增强命令行使用体验。</li>
  <li>增加对各云服务厂商提供对象存储的支持。</li>
  <li>增加对各流行图床的支持。</li>
  <li>增加对自托管 Git 的支持。</li>
  <li>增加对 FTP 的支持。</li>
  <li>增加包括水印、调整大小等在内的图片处理的支持。</li>
  <li>增加与 Unplash 等公共图库的连接，更加便于博客封面的操作。</li>
</ul>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://blog.cloudflare.com/introducing-r2-object-storage-zh-cn/">隆重推出 Cloudflare R2 Storage —— 快速、可靠的对象存储，减免出口费用</a></li>
  <li><a href="https://developers.cloudflare.com/r2/">R2 文档</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="project" /><category term="pictl" /><category term="命令行" /><category term="工具" /><category term="cli" /><category term="tool" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">通用运行环境版本管理神器 ASDF</title><link href="https://lisz.me/tech/webmaster/asdf.html" rel="alternate" type="text/html" title="通用运行环境版本管理神器 ASDF" /><published>2023-03-20T15:50:00+09:00</published><updated>2023-03-20T15:50:00+09:00</updated><id>https://lisz.me/tech/webmaster/asdf</id><content type="html" xml:base="https://lisz.me/tech/webmaster/asdf.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  之前介绍了高性能集群中常用的运行环境和软件版本管理工具 Modules，今天打算介绍一款适合个人或团队开发使用的通用运行环境版本管理神器 <a href="https://asdf-vm.com/zh-hans/">ASDF</a>。与高性能计算任务不同，个人或团队开发项目一般来说都是使用独立的设备或环境，然后通过代码版本跟踪 git 等来进行异步协作。所以说，在每个人的单个或多个设备上都安装配置 Modules 显得有点不太现实和高效。但是项目开发所需的代码环境确实有的时候可能比较复杂，比如说同时需要 Ruby、NodeJS、Java、Python 四种环境，而且可能对于每种环境还有版本的限制。这样一来，光配置这一堆环境就要花上大半天时间了。</p>

<h3 id="asdf-简介">ASDF 简介</h3>

<p>  ASDF 提供了全平台通用的环境配置方案，使用单个命令行工具和交互界面就可以管理超复杂的运行环境。以往针对不同运行环境，需要使用不同的配置文件来进行版本的声明。对于 ASDF，只需要一个可共享的 <code class="language-plaintext highlighter-rouge">.tool-versions</code> 配置文件即可。ASDF 涵盖了包括 Ruby、NodeJS、Java、PHP、.Net 在内的几百种运行环境，具体可以查看 <a href="https://github.com/asdf-vm/asdf-plugins">ASDF 插件列表</a> 了解更多。</p>

<p>  另外，ASDF 完全支持包括 Bash、Zsh、Fish 和 Elvish 在内的常用 shell 类型，并提供补全功能。在类似 Github Actions 等的 CI/CD 工作流中，也可以轻松使用 ASDF。值得一提的是，笔者翻译了 ASDF 文档的中文版本并被官方采纳，现在 ASDF 官网支持英语、巴西语和中文三种语言。</p>

<h3 id="为何不选其他方案">为何不选其他方案</h3>

<h4 id="docker">Docker</h4>

<p>  很显然，如果大家的设备上都有 Docker 环境且 CPU 架构相同的话，Docker 无疑是最省心的方案。Docker 镜像的确可以轻松涵盖所有开发环境和实际运行环境（Apache 等 HTTP 服务器、数据库以及其他）。相比笨重的 VMware 或 Virtualbox 虚拟机镜像而言，Docker 镜像也更加小巧、便捷。而且团队可以通过在内部搭建自己的 Docker 镜像仓库，来分享这些镜像给所有参与项目的开发者。唯一可能会有问题的是，设备 CPU 架构和操作系统的多样性可能会给实际操作带来了不小的问题。实际上可能会有 Windows 系统、Linux 系统、MacOS 系统以及 Intel 架构、AMD 架构、ARM 架构（如 M1、M2 等）。可行的解决方法是，尽可能地构建更多架构的镜像。</p>

<h4 id="anaconda">Anaconda</h4>

<p>  Anaconda 现在可能已经完全超出了一个 Python 环境管理工具，有的时候也可以当成通用软件或环境管理器来用。但是毕竟还是以科学计算为主要目的，如果项目仅仅是 Python、R 语言可能还是比较合适的，对于实际编程所需的其他运行环境来说可能还是支持不够的。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  据笔者所知，在 <code class="language-plaintext highlighter-rouge">conda-forge</code> 频道里的确有 PHP 等编程语言的支持。除此之外，也有一些热心开发者在个人频道提供了 java-jdk、golang 等编程环境支持。</p>



 </div> </div>
<h4 id="云开发">云开发</h4>

<p>  云开发主要是指基于云基础设施的在线代码开发环境，主要的代表有：</p>

<ul>
  <li><a href="https://aws.amazon.com/cn/cloud9/">Cloud9</a>：笔者最早接触过的云开发，目前已被 AWS 收购，更名为 AWS Cloud9。</li>
  <li><a href="https://github.com/features/codespaces">Codespaces</a>：由 Azure 提供云服务、Github 负责运营的一站式云开发环境。</li>
  <li><a href="https://www.gitpod.io/">Gitpod</a>：基于 VS Code 研发的优秀云开发环境，早期以“便捷、快速”著称，较先于 Codespaces 出现。</li>
  <li><a href="https://cloud.tencent.com/product/cloudstudio">Cloud Studio</a>：由腾讯云提供云服务、基于 VS Code 的国产云开发环境，能够很好地支持个人开发、招聘笔试、课堂教学、应用快捷部署等各种场景。</li>
  <li><a href="https://www.huaweicloud.com/product/cloudide.html">CodeArts IDE Online</a>：由华为云提供云服务、基于 VS Code 的国产云开发环境。除了一般云开发所具备的特点，还支持华为鲲鹏原生环境，能够很好地满足跨架构应用开发的需求。</li>
  <li><a href="https://cn.aliyun.com/product/yunxiao/devstudio">DevStudio</a>：由阿里云提供云服务、基于 VS Code 的国产云开发环境。支持应用开发全流程管理，与阿里云各项基础服务紧密结合，适合大规模团队使用。</li>
</ul>

<p>除了以上列举的云开发之外，也有一些比较传统的小型云开发实践，比如说知名的 <a href="https://jsfiddle.net/">JSFiddle</a>、<a href="https://codepen.io/">CodePen</a>、<a href="https://replit.com/">Replit</a> 等。虽然说这些云开发主要是适合较小代码库，但在实际学习过程中用处也是很大的。</p>

<p>  云开发不仅兼顾了传统开发过程中的协同与流程，又将资源与环境整合在云里面，自然而然是最好的解决方案。随着 VS Code 在开发者之间的流行和云服务提供商的努力，基于 VS Code 的云开发环境层出不穷。即使云开发环境本身免费，云也还是要按量按时计费的。对于还没有足够支持上云的团队或个人来说，ASDF 依然是个不错的选择。</p>

<h2 id="实践">实践</h2>

<h3 id="环境需求">环境需求</h3>

<ul>
  <li>Linux/Unix 环境（Linux、MacOS、Windows WSL）</li>
  <li>git</li>
  <li>bash 等（此处以 zsh 为例）</li>
</ul>

<h3 id="环境配置">环境配置</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载源码到 ~/.asdf 目录</span>
git clone https://github.com/asdf-vm/asdf.git ~/.asdf <span class="nt">--branch</span> v0.11.3

<span class="c"># 在 ~/.zshrc 文件中加入内容</span>
<span class="nb">tee</span> <span class="nt">-a</span> ~/.zshrc <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
. "</span><span class="nv">$HOME</span><span class="sh">/.asdf/asdf.sh"
</span><span class="no">EOF

</span><span class="c"># 激活配置</span>
<span class="nb">source</span> ~/.zshrc

<span class="c"># 验证</span>
╰─<span class="nv">$ </span>asdf version
v0.11.3-0adc6c1
</code></pre></div></div>

<h3 id="安装插件">安装插件</h3>

<p>  由于 ASDF 支持插件较多，这里以 Python 环境为例介绍 ASDF 安装插件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 添加插件</span>
asdf plugin add python

<span class="c"># 查看已安装插件</span>
╰─<span class="nv">$ </span>asdf plugin list
python

<span class="c"># 查看最新 Python 版本</span>
╰─<span class="nv">$ </span>asdf latest python
3.11.2

<span class="c"># ASDF 安装 Python 3.11.2 (latest)</span>
╰─<span class="nv">$ </span>asdf <span class="nb">install </span>python latest
python-build 3.11.2 /home/ubuntu/.asdf/installs/python/3.11.2
Downloading Python-3.11.2.tar.xz...
-&gt; https://www.python.org/ftp/python/3.11.2/Python-3.11.2.tar.xz
Installing Python-3.11.2...
Installed Python-3.11.2 to /home/ubuntu/.asdf/installs/python/3.11.2

<span class="c"># 查看已安装 Python 版本列表</span>
╰─<span class="nv">$ </span>asdf list
python
  3.11.2
</code></pre></div></div>

<h3 id="使用">使用</h3>

<p>  ASDF 提供全局版本（Global）和本地版本（Local）两种方式定义运行环境版本。全局版本是系统级别的，类似于 PATH 变量中定义的；本地版本则是为了某个代码库或者部分代码准备的，通常在目录中的 <code class="language-plaintext highlighter-rouge">.tool-versions</code> 文件里定义。为了区分全局和本地的效果差别，这里再安装一个指定 Python 版本。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查询 Python 插件支持的所有版本</span>
╰─<span class="nv">$ </span>asdf list all python
2.1.3
2.2.3
......
stackless-3.7.5

<span class="c"># 安装 Python 3.9.0</span>
╰─<span class="nv">$ </span>asdf <span class="nb">install </span>python 3.9.0
python-build 3.9.0 /home/zhonger/.asdf/installs/python/3.9.0
Downloading Python-3.9.0.tar.xz...
-&gt; https://www.python.org/ftp/python/3.9.0/Python-3.9.0.tar.xz
Installing Python-3.9.0...
patching file Misc/NEWS.d/next/Build/2021-10-11-16-27-38.bpo-45405.iSfdW5.rst
patching file configure
patching file configure.ac
Installed Python-3.9.0 to /home/zhonger/.asdf/installs/python/3.9.0

<span class="c"># 查看已安装 Python 版本列表</span>
╰─<span class="nv">$ </span>asdf list
python
  3.11.2
  3.9.0

<span class="c"># 查看当前系统 Python 及 Python3 版本</span>
╰─<span class="nv">$ </span>python <span class="nt">-V</span>
No python executable found <span class="k">for </span>python system

╰─<span class="nv">$ </span>python3 <span class="nt">-V</span>
Python 3.10.6

<span class="c"># 更改全局版本为 3.11.2 并查看</span>
╰─<span class="nv">$ </span>asdf list
python
 <span class="k">*</span>3.11.2
  3.9.0

╰─<span class="nv">$ </span>python <span class="nt">-V</span>
Python 3.11.2

<span class="c"># 创建子目录指定本地版本并查看</span>
<span class="nb">mkdir </span>py <span class="o">&amp;&amp;</span> <span class="nb">cd </span>py
asdf <span class="nb">local </span>python 3.9.0

╰─<span class="nv">$ </span>python <span class="nt">-V</span>
Python 3.9.0

<span class="c"># 返回父目录查看 Python 版本</span>
╰─<span class="nv">$ </span><span class="nb">cd</span> .. <span class="o">&amp;&amp;</span> python <span class="nt">-V</span>
Python 3.11.2

<span class="c"># 查看当前系统 Python3 版本</span>
╰─<span class="nv">$ </span>python3 <span class="nt">-V</span>
Python 3.10.6
</code></pre></div></div>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  这里有一点比较有趣的是：由于 ASDF 接管的 <code class="language-plaintext highlighter-rouge">python</code> 命令而非 <code class="language-plaintext highlighter-rouge">python3</code> 命令，所以 <code class="language-plaintext highlighter-rouge">python3</code> 命令输出的版本依然还是系统安装版本。</p>



 </div> </div>
<h3 id="其他相关">其他相关</h3>

<p>  如果想要恢复到系统指定版本，可以很容易使用 <code class="language-plaintext highlighter-rouge">asdf global python system</code> 命令。当然，对于本地版本，可以使用 <code class="language-plaintext highlighter-rouge">asdf local python system</code> 来实现。除此之外，还有一些常规操作如下。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看 Python 指定版本安装位置</span>
╰─<span class="nv">$ </span>asdf where python 3.11.2
/home/zhonger/.asdf/installs/python/3.11.2

<span class="c"># 查看命令所在位置</span>
╰─<span class="nv">$ </span>asdf which python
/home/zhonger/.asdf/installs/python/3.11.2/bin/python

<span class="c"># 查看当前 ASDF 管理的运行环境</span>
╰─<span class="nv">$ </span>asdf current
python          3.11.2          /home/ubuntu/.tool-versions

<span class="c"># 查看全局和本地版本配置文件</span>
╰─<span class="nv">$ </span><span class="nb">cat</span> ~/.tool-versions
python 3.11.2

╰─<span class="nv">$ </span><span class="nb">cat</span> ~/py/.tool-versions
python 3.9.0
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://asdf-vm.com/zh-hans/guide/getting-started.html">ASDF 官网 - 快速入门</a></li>
  <li><a href="https://asdf-vm.com/zh-hans/manage/versions.html">ASDF 官网 - 版本</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Linux" /><category term="Environment" /><category term="Manage" /><category term="Dev Runtime" /><category term="软件环境" /><category term="多版本" /><category term="管理" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">Modules 配置之 Python</title><link href="https://lisz.me/tech/webmaster/modules-python.html" rel="alternate" type="text/html" title="Modules 配置之 Python" /><published>2023-03-20T12:48:00+09:00</published><updated>2023-03-20T12:48:00+09:00</updated><id>https://lisz.me/tech/webmaster/modules-python</id><content type="html" xml:base="https://lisz.me/tech/webmaster/modules-python.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  近年来得益于其轻量、易学易用、第三方支持依赖库多的特点，Python 语言大量被用于机器学习相关的研究、项目开发。在学术界，有以 <a href="https://scikit-learn.org">Scikit-Learn</a> 为代表的全能机器学习库；在产业界，有以 <a href="https://www.tensorflow.org">TensorFlow</a>、<a href="https://pytorch.org">PyTorch</a> 为代表的生产级机器学习模型计算框架。（当然，学术界实际上构建大规模深度学习模型时也会用到 PyTorch 等计算框架。）但对于大多数人来说，学习这些库、框架或者借助它们从事某些研究、项目开发时，可能还是在用自己的笔记本、台式机。哪怕是在高校的实验室里，这种事情也是屡见不鲜。因此，有交互界面、相对容易上手的 <a href="https://www.anaconda.com">Anaconda</a> 可能会作为大家管理 Python 环境的首选。</p>

<p>  当我们在用 Python 编写一些代码，而代码一次运行不可能在短短几秒、几分钟内得到结果时，将任务提交给高性能工作站或者集群作业系统就显得格外有效。尤其是当应用规模较大、计算迭代次数较多时，非交互式的作业提交方式会变得更加有利。毕竟如果是用自己的笔记本运行着这么大的计算，资源基本上都被计算占用了，根本没办法用笔记本去干点别的事情。甚至说，计算还会使得 CPU 等核心部件温度上升，从而影响计算性能。这样比较下来，不得不说提交任务给高性能工作站或者集群作业系统是多么明智的选择。</p>

<p>  其实，Anaconda 在没有交互界面的服务器操作系统上也还是可以使用的，我们可以使用其免费的精简版 —— <a href="https://conda.io/miniconda">miniconda</a>。虽然 miniconda 已经是精简版了，但和原生 Python 环境比起来还是要多不少东西的。从高性能计算环境的角度来看，使用 Modules 直接管理 Python 环境实际上更加贴近原生，也更加有利于用户与其他环境搭配使用。比如说安装  Python 的 MPI 支持库 —— MPI4PY，仅需要通过 Modules 管理工具加载 Python 和 MPI 两个基础环境，使用 <code class="language-plaintext highlighter-rouge">pip3 install mpi4py</code> 命令即可安装。</p>

<h2 id="实践">实践</h2>

<p>  将 Python 环境纳入 Modules 管理的步骤就是两步：第一步，编译源代码及安装；第二步，添加 Modules 配置文件。当然，最开始还是需要确认一下编译环境是否完备以及文件夹是否准备好。</p>

<h3 id="环境及文件夹准备">环境及文件夹准备</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 安装编译环境</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> build-essential libbz2-dev libdb-dev <span class="se">\</span>
  libreadline-dev libffi-dev libgdbm-dev liblzma-dev <span class="se">\</span>
  libncursesw5-dev libsqlite3-dev libssl-dev <span class="se">\</span>
  zlib1g-dev uuid-dev tk-dev wget
  
<span class="c"># 准备文件夹</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /opt/python/3.10.6
</code></pre></div></div>

<h3 id="编译及安装">编译及安装</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载源代码</span>
<span class="nb">cd</span> /tmp
wget <span class="nt">-c</span> https://www.python.org/ftp/python/3.10.6/Python-3.10.6.tar.xz

<span class="c"># 解压源代码</span>
<span class="nb">tar </span>xf Python-3.10.6.tar.xz

<span class="c"># 配置安装路径及编译选项</span>
<span class="nb">cd </span>Python-3.10.6
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/python/3.10.6 <span class="nt">--enable-optimizations</span> <span class="nt">--with-lto</span> 

<span class="c"># 编译及安装</span>
make <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="配置-modules">配置 Modules</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /opt/modules/modulefiles/py
<span class="nb">sudo </span>vim /opt/modules/modulefiles/py/3.10.6
</code></pre></div></div>

<p>  首先如上命令准备文件夹，并新建 module 配置文件，内容如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#%Module</span>
proc ModulesHelp <span class="o">{</span> <span class="o">}</span> <span class="o">{</span>
    puts stderr <span class="se">\t</span>This module file will load Python 3.10.6<span class="s2">"
}

module-whatis  "</span>Enable Python 3.10.6<span class="s2">"

eval set  [ array get env HOME ]
set basedir /opt/python/3.10.6
prepend-path PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/bin<span class="s2">"
prepend-path LIBRARY_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/lib<span class="s2">"
prepend-path LD_LIBRARY_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/lib<span class="s2">"
prepend-path INCLUDE_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/include<span class="s2">"
prepend-path LD_INCLUDE_PATH "</span><span class="k">${</span><span class="nv">basedir</span><span class="k">}</span>/include<span class="s2">"
</span></code></pre></div></div>

<h3 id="验证">验证</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看所有可用模块</span>
╰─<span class="nv">$ </span>module ava
<span class="nt">--------------------------</span> /opt/modules/modulefiles <span class="nt">---------------------------</span>
dot  module-git  module-info  modules  null  py/3.10.6  use.own

Key:
modulepath
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 加载 python 3.10.6 环境，并确认已加载模块</span>
╰─<span class="nv">$ </span>module load py/3.10.6
╰─<span class="nv">$ </span>module list
Currently Loaded Modulefiles:
 1<span class="o">)</span> py/3.10.6
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 确认目前 python 版本</span>
╰─<span class="nv">$ </span>python3 <span class="nt">-V</span>
Python 3.10.6
</code></pre></div></div>

<h3 id="使用">使用</h3>

<p>  由于以上操作将 Python 3.10.6 安装到了一个系统文件夹中，编译完成后会出现如下警告提示。不过无须担心，普通用户可以通过 venv 虚拟环境工具正常使用。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Installing collected packages: setuptools, pip
  WARNING: The scripts pip3 and pip3.10 are installed <span class="k">in</span> <span class="s1">'/opt/python/3.10.6/bin'</span> which is not on PATH.
  Consider adding this directory to PATH or, <span class="k">if </span>you prefer to suppress this warning, use <span class="nt">--no-warn-script-location</span><span class="nb">.</span>
Successfully installed pip-22.2.1 setuptools-63.2.0
WARNING: Running pip as the <span class="s1">'root'</span> user can result <span class="k">in </span>broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv
</code></pre></div></div>

<p>  如下所示，当已经如<strong>验证</strong>部分加载好 python 3.10.6 模块后，使用以下命令新建虚拟环境、激活后即可使用。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>   新建虚拟环境时最后的参数 env 是指虚拟环境的名字，我们可以取任意符合 python 规则的字符串作为虚拟环境名字。值得注意的是，python 虚拟环境有关的文件将会被安装在命令执行的当前目录下的同名文件夹中。为了便于管理和使用，建议将所有的 python 虚拟环境都放置在同一目录下。</p>



 </div> </div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 新建 env 虚拟环境</span>
╰─<span class="nv">$ </span>python3 <span class="nt">-m</span> venv <span class="nb">env</span>

<span class="c"># 激活 env 虚拟环境</span>
╰─<span class="nv">$ </span><span class="nb">source env</span>/bin/activate

<span class="c"># 可以看到 &lt;env&gt; 的环境提示</span>
<span class="c"># 尝试升级 pip，可以看到成功升级 </span>
╭─zhonger@lep-u ~ ‹env›
╰─<span class="nv">$ </span>pip3 <span class="nb">install</span> <span class="nt">-U</span> pip
Requirement already satisfied: pip <span class="k">in</span> ./env/lib/python3.10/site-packages <span class="o">(</span>22.2.1<span class="o">)</span>
Collecting pip
  Using cached pip-23.0.1-py3-none-any.whl <span class="o">(</span>2.1 MB<span class="o">)</span>
Installing collected packages: pip
  Attempting uninstall: pip
    Found existing installation: pip 22.2.1
    Uninstalling pip-22.2.1:
      Successfully uninstalled pip-22.2.1
Successfully installed pip-23.0.1

<span class="c"># 取消激活 env 虚拟环境</span>
╰─<span class="nv">$ </span>deactivate
</code></pre></div></div>

<h2 id="有趣的问题">有趣的问题</h2>

<p>  如果使用 module 提供的 python 模块创建了虚拟环境后，实际运行虚拟环境时还需要使用 module 加载 python 模块吗？答案是<strong>不需要</strong>。虚拟环境的本质是拷贝运行相同命令所需的必要文件，如下对比查看一下 python 模块和 env 虚拟环境的顶级目录。可以发现，两者的差别不是很大。env 虚拟环境少了 share 目录，多了 pyvenv.cfg 文件。查看该文件可知，存在与 python 模块之间的关系的声明。再查看 bin 目录，可以看到 python 可执行命令用了链接的方式，pip 命令则是直接从原来的 python 模块复制过来的。于是，这就能允许普通用户自行管理  pip 命令和 python 库了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span><span class="nb">ls</span> /opt/python/3.10.6
bin  include  lib  share

╰─<span class="nv">$ </span><span class="nb">ls env
</span>bin  include  lib  lib64  pyvenv.cfg

╰─<span class="nv">$ </span><span class="nb">cat env</span>/pyvenv.cfg
home <span class="o">=</span> /opt/python/3.10.6/bin
include-system-site-packages <span class="o">=</span> <span class="nb">false
</span>version <span class="o">=</span> 3.10.6

╰─<span class="nv">$ </span>ll <span class="nb">env</span>/bin
total 36K
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger 8.9K Mar 20 15:20 Activate.ps1
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger 2.0K Mar 20 15:20 activate
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger  908 Mar 20 15:20 activate.csh
<span class="nt">-rw-r--r--</span> 1 zhonger zhonger 2.1K Mar 20 15:20 activate.fish
<span class="nt">-rwxrwxr-x</span> 1 zhonger zhonger  234 Mar 20 15:20 pip
<span class="nt">-rwxrwxr-x</span> 1 zhonger zhonger  234 Mar 20 15:20 pip3
<span class="nt">-rwxrwxr-x</span> 1 zhonger zhonger  234 Mar 20 15:20 pip3.10
lrwxrwxrwx 1 zhonger zhonger    7 Mar 20 15:20 python -&gt; python3
lrwxrwxrwx 1 zhonger zhonger   30 Mar 20 15:20 python3 -&gt; /opt/python/3.10.6/bin/python3
lrwxrwxrwx 1 zhonger zhonger    7 Mar 20 15:20 python3.10 -&gt; python3
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://docs.python.org/zh-cn/3/using/unix.html#building-python">Python 官方文档 - 构建 Python</a></li>
  <li><a href="https://docs.python.org/zh-cn/3/using/configure.html#configure-options">Python 官方文档 - 性能选项</a></li>
  <li><a href="https://docs.python.org/zh-cn/3/tutorial/venv.html">Python 官方文档 - 虚拟环境和包</a></li>
  <li><a href="https://www.python.jp/install/ubuntu/index.html">Ubuntu 環境の Python</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Linux" /><category term="Modules" /><category term="Python" /><category term="软件环境" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">集群动态环境管理神器 Modules</title><link href="https://lisz.me/tech/webmaster/modules.html" rel="alternate" type="text/html" title="集群动态环境管理神器 Modules" /><published>2022-10-26T15:48:00+09:00</published><updated>2022-10-26T15:48:00+09:00</updated><id>https://lisz.me/tech/webmaster/modules</id><content type="html" xml:base="https://lisz.me/tech/webmaster/modules.html"><![CDATA[<h2 id="前言">前言</h2>

<div class="premonition citation"> <div class="header"> <svg class="icon citation" aria-hidden="true"> <use xlink:href="#icon-citation"></use> </svg> </div> <div class="content"> <p>  Modules 包是一款简化 shell 初始化的工具，允许用户在会话期间使用模块文件轻松切换环境。</p>



 </div> <div class="ref"> ------ Environment Modules 官网 </div> </div>
<p>  在高性能集群或者超算中，我们可以经常看到 Modules 的身影。它可以帮助我们轻松加载运行程序所需的各类环境，比如说笔者之前写过的第一性原理计算软件 CONQUEST 的运行，就需要包括 Intel OneAPI HPCKit、FFTW3、LibXC 在内的多种环境；又比如说运行大规模的机器学习模型时，可能需要 Python、GPU 环境和 PyTorch 等依赖库。</p>

<p>  由于集群往往是面向很多人服务的，如果管理员将软件安装到全局环境，则只能安装某个软件的某个特定版本，而不能同时为不同的用户提供所需的同款软件的不同版本。举个例子，笔者编写的代码只能在 Python 3.10 环境下运行，而其他用户编写的代码所支持的 Python 版本是 3.0，那么可能最简单的解决方法是笔者自行编译一个 Python 3.10 的环境，然后利用 PATH 等变量的配置来提升优先级。或许之后有一天，另外一个用户也要使用 Python 3.10 环境，那么是不是让他再自行编译配置一遍呢？哈哈哈，听起来有点无奈，但是<strong>千万不要高估集群的使用用户</strong>，可能自行编译并配置 Python 3.10 对他们来说也有点困难。因此，Modules 成为了集群动态管理软件环境的最佳选择。集群管理员可以预先编译和配置好各种环境的各种版本，用户使用时只需要执行类似 <code class="language-plaintext highlighter-rouge">module load py/3.10.6</code> 的命令就可以轻松加载 Python 3.10.6 环境。</p>

<p>  Modules 所支持的模块不仅仅可以是编程语言的多版本，还可以是其他任意的基础环境，比如说 gcc、openmpi 等编译环境。这样一来，不仅可以为用户提供足够的编程环境直接使用，还可以为一些想要自行编译运行环境的用户提供了便利。</p>

<h2 id="实践">实践</h2>

<h3 id="源码编译安装-modules">源码编译安装 Modules</h3>

<p>  Modules 可以在 Linux、Windows、MacOS 任一操作系统上安装运行，这里仅介绍类 Unix 操作系统下的编译安装过程。由于 Modules 需要使用 tcl 工具来解析 modulefiles，所以系统必须预先安装 tcl 及其开发者库。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 根据实际情况三者选其一</span>
<span class="c"># Debian/Ubuntu 等 APT 系列操作系统上安装 tcl</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> tcl tcl-dev
<span class="c"># CentOS 等 YUM 系列操作系统上安装 tcl</span>
<span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> tcl tcl-devel
<span class="c"># MacOS 操作系统上安装 tcl （需有 brew 工具）</span>
brew <span class="nb">install </span>tcl-tk

<span class="c"># 下载源代码并解压</span>
wget <span class="nt">-c</span> https://github.com/cea-hpc/modules/releases/download/v5.1.1/modules-5.1.1.tar.gz
<span class="nb">tar </span>xfz modules-5.1.1.tar.gz

<span class="c"># 创建安装目录</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /opt/modules

<span class="c"># 进入目录并配置安装目录</span>
<span class="nb">cd </span>modules-5.1.1
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/modules
<span class="c"># MacOS 可能需要如下另外指定 tclConfig.sh 文件所在的位置</span>
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/modules <span class="nt">--with-tcl</span><span class="o">=</span>/opt/homebrew/opt/tcl-tk/lib

<span class="c"># 编译并安装到 /opt/modules 目录</span>
make <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="使-modules-生效">使 Modules 生效</h3>

<p>  并非是编译完了之后就可以直接使用 Modules，还有至关重要的一步–<strong>添加生效命令</strong>。首先需要确认当前使用的 Shell 是什么，一般来说默认是 Bash，当然也有 Zsh 等等。然后，在对应的 Shell 配置文件中增加一行生效命令。操作如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 确认当前使用的 Shell</span>
╰─<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$SHELL</span>
/bin/zsh

<span class="c"># 查看 Modules 支持的 Shell</span>
╰─<span class="nv">$ </span><span class="nb">ls</span> /opt/modules/init
bash            cmake           fish            ksh             lisp            profile.csh     python.py       ruby.rb         tcl             tcsh_completion zsh-functions
bash_completion csh             fish_completion ksh-functions   perl.pm         profile.sh      r.R             sh              tcsh            zsh
<span class="c"># 如上所示，大部分流行的 Shell 都在支持列表中</span>

<span class="c"># 使 Modules 生效</span>
vim ~/.zshrc
<span class="c"># 添加以下内容</span>
<span class="nb">source</span> /opt/modules/init/zsh
</code></pre></div></div>

<h3 id="源码编译安装-tcl">源码编译安装 tcl</h3>

<p>  Modules 的编译安装是不是很简单？不过如果 tcl 工具无法使用命令安装的话，就只能从源码编译安装，也比较方便，如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载源码并解压</span>
wget <span class="nt">-c</span> https://prdownloads.sourceforge.net/tcl/tcl8.6.12-src.tar.gz
<span class="nb">tar </span>xfz tcl8.6.12-src.tar.gz

<span class="c"># 创建安装目录</span>
<span class="nb">sudo mkdir</span> /opt/tcl

<span class="c"># 进入目录并配置安装目录</span>
<span class="nb">cd </span>tcl8.6.12/unix
./configure <span class="nt">--prefix</span><span class="o">=</span>/opt/tcl

<span class="c"># 编译并安装</span>
make <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<h3 id="modules-相关命令">Modules 相关命令</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看所有可用模块</span>
module avail / module ava

<span class="c"># 加载指定模块（支持同时加载多个模块）</span>
module load py/3.10.6 mpi

<span class="c"># 查看已加载模块</span>
module list

<span class="c"># 查看指定模块</span>
module show py/3.10.6

<span class="c"># 添加自定义模块配置目录</span>
module use <span class="nt">--apend</span> ~/opt/modulefiles
</code></pre></div></div>

<h2 id="添加软件环境">添加软件环境</h2>

<h3 id="modulefiles-库">Modulefiles 库</h3>

<p>  Modules 编译安装后默认会有一些环境，它们的配置文件都被存储在安装目录的 modulefiles 文件夹中，如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>module ava
<span class="nt">---------------------------</span> /opt/modules/modulefiles <span class="nt">---------------------------</span>
dot  module-git  module-info  modules  null  use.own

Key:
modulepath

╰─<span class="nv">$ </span><span class="nb">ls</span> /opt/modules/modulefiles
dot         module-git  module-info modules     null        use.own
</code></pre></div></div>

<p>  一般来说，打算提供给所有用户的环境配置都可以放在这个目录里，这样任何用户都可以查看到。</p>

<h3 id="modulefiles-模板">Modulefiles 模板</h3>

<p>  这里我们可以把 <code class="language-plaintext highlighter-rouge">use.own</code> 文件作为模板来学习一下如何编写 Modulefiles 文件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#%Module1.0#####################################################################</span>
<span class="c">##</span>
<span class="c">## use.own modulefile</span>
<span class="c">##</span>
proc ModulesHelp <span class="o">{</span> <span class="o">}</span> <span class="o">{</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">This module file will add </span><span class="se">\$</span><span class="s2">HOME/privatemodules to the"</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">list of directories that the module command will search"</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">for modules.  Place your own module files here."</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">This module, when loaded, will create this directory"</span>
    puts stderr <span class="s2">"</span><span class="se">\t</span><span class="s2">if necessary."</span>
<span class="o">}</span>

module-whatis   <span class="s2">"adds your own modulefiles directory to MODULEPATH"</span>

<span class="nb">eval set</span>  <span class="o">[</span> array get <span class="nb">env </span>HOME <span class="o">]</span>
<span class="nb">set </span>ownmoddir   <span class="nv">$HOME</span>/privatemodules

<span class="c"># create directory if necessary</span>
<span class="k">if</span> <span class="o">[</span> module-info mode load <span class="o">]</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">{</span> <span class="o">!</span> <span class="o">[</span> file exists <span class="nv">$ownmoddir</span> <span class="o">]</span> <span class="o">}</span> <span class="o">{</span>
        file <span class="nb">mkdir</span> <span class="nv">$ownmoddir</span>
        <span class="nb">set </span>null <span class="o">[</span>open <span class="nv">$ownmoddir</span>/null w]
        puts <span class="nv">$null</span> <span class="s2">"#%Module########################################################################"</span>
        puts <span class="nv">$null</span> <span class="s2">"##"</span>
        puts <span class="nv">$null</span> <span class="s2">"## null modulefile"</span>
        puts <span class="nv">$null</span> <span class="s2">"##"</span>
        puts <span class="nv">$null</span> <span class="s2">"proc ModulesHelp { } {"</span>
        puts <span class="nv">$null</span> <span class="s2">"    puts stderr </span><span class="se">\"\t</span><span class="s2">This module does absolutely nothing.</span><span class="se">\"</span><span class="s2">"</span>
        puts <span class="nv">$null</span> <span class="s2">"    puts stderr </span><span class="se">\"\t</span><span class="s2">It's meant simply as a place holder in your</span><span class="se">\"</span><span class="s2">"</span>
        puts <span class="nv">$null</span> <span class="s2">"    puts stderr </span><span class="se">\"\t</span><span class="s2">dot file initialization.</span><span class="se">\"</span><span class="s2">"</span>
        puts <span class="nv">$null</span> <span class="s2">"}"</span>
        puts <span class="nv">$null</span> <span class="s2">""</span>
        puts <span class="nv">$null</span> <span class="s2">"module-whatis   </span><span class="se">\"</span><span class="s2">does absolutely nothing</span><span class="se">\"</span><span class="s2">"</span>
    <span class="o">}</span>
<span class="o">}</span>

module use <span class="nt">--append</span> <span class="nv">$ownmoddir</span>
</code></pre></div></div>

<p>  Modulefiles 文件一般符合以下规则：</p>

<ul>
  <li>Modulefiles 文件必须以 <code class="language-plaintext highlighter-rouge">#%Module1.0</code> 开头；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">proc ModulesHelp {}</code> 函数来添加模块详细描述；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">module-whatis</code> 字段来添加一句话简短描述；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">eval set [ array get env HOME]</code> 来获取系统变量 <code class="language-plaintext highlighter-rouge">$HOME</code>；</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">set ownmoddir</code> 来定义变量 <code class="language-plaintext highlighter-rouge">ownmoddir</code>；</li>
  <li>后续脚本可以根据需求进行添加内容。</li>
</ul>

<p>  这里先开个坑，后续打算补充 Modules 配置系列文章：</p>

<ul>
  <li><a href="modules-python.html">《Modules 配置之 Python》</a></li>
  <li><a href="modules-conda.html">《Modules 配置之 Anaconda》</a></li>
  <li><a href="modules-intel.html">《Modules 配置之 Intel OneAPI》</a></li>
</ul>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://modules.readthedocs.io/en/latest/index.html">Environment Modules 官方文档</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Linux" /><category term="集群" /><category term="Cluster" /><category term="Modules" /><category term="软件环境" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">LDAP 集成之 OpenVPN 篇</title><link href="https://lisz.me/tech/webmaster/ldap-openvpn.html" rel="alternate" type="text/html" title="LDAP 集成之 OpenVPN 篇" /><published>2022-09-28T15:04:00+09:00</published><updated>2022-09-28T15:04:00+09:00</updated><id>https://lisz.me/tech/webmaster/ldap-openvpn</id><content type="html" xml:base="https://lisz.me/tech/webmaster/ldap-openvpn.html"><![CDATA[<h2 id="前言">前言</h2>

<h3 id="easy-connect">Easy Connect</h3>

<p>  公司、学校、云服务等一般需要将内外网进行分离，如果想要从外部网络访问某些内部应用，通常需要使用公司、学校、云服务提供的专用网络接入服务。国内公司、学校比较常用的是由深信服开发的 Easy Connect，一种 SSL VPN 技术的实现。虽然每年需要支付一定的费用来维护、升级 Easy Connect 服务，但是毕竟它能够提供比较细粒度的权限控制，比如说对目标 IP、目标端口的特别指定，能够有效保护内网服务器只有 Web 应用本身能被用户接入，而类似于 SSH 等服务及端口则可以通过单独申请和配置来实现。总而言之，除了需要付费，似乎没有什么不好的地方。</p>

<p>  实际上如果是在大公司或者学校的话，可能在内网里面还会有更深的内网存在。举个例子，正常的内网是日常的办公或开发网络，服务器所处的内网是独立的网络，即使是已经连接了办公网络，还是需要通过专用网络接入服务器内网才能进行服务器的维护。如果是以数据中心的模式运营的话，甚至说每一次访问服务器都是需要经过临时审批和登录密码发放的。一旦过了有效时间或者完成了任务，访问都将会被拒绝。</p>

<h3 id="openvpn">OpenVPN</h3>

<p>  虽然 Easy Connect 可以用于上述的场景，但是似乎显得有些大材小用了，毕竟还是要支付一定费用的。为了尽量降低成本，开源的 OpenVPN 或许是一种不错的选择。据笔者所知，Easy Connect 根据购买的许可不同允许的同时在线人数可能也会不同，实际上可能存在“需大于供”的问题。为了缓解这一可能存在的问题，还是会搭建一套 OpenVPN 来作为冗余接入方式。其实 OpenVPN 的商业版本许可也是会有人数限制的，只不过因为只是备份方式也没有太大关系。</p>

<p>  OpenVPN 除了开源免费之外，还支持大部分主流的认证方式，比如说 LDAP 认证、微软的商业级目录服务 Active Directory（简称 AD）认证等。近年来，基于 Identify Provider（简称 IdP）、Single Sign On（简称 SSO）、Central Authentication Service（简称 CAS）等的国产化的一站式登录服务解决方案也在逐渐替换原来的 LDAP 或 AD 直接认证，LDAP 或 AD 将作为底层的基础认证方式存在。所以说，开源免费的 LDAP 目录服务在一般的团队中还是足够的，作为 OpenVPN 的认证方式也是完全能满足要求的。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 提醒 </div> </div> <div class="content"> <p>  在公网上搭建专用网络接入服务是需要有工信部颁发的专门资格许可的，一般公司、学校、云服务都是有该类资格许可，所以可以对外提供该项服务。而个人是无法获得这类许可，除非注册公司并申请该类许可。如果个人在云服务上搭建该类服务，将会面临被云服务提供商警告甚至单方面停止服务的风险。</p>



 </div> </div>
<h2 id="实践">实践</h2>

<h3 id="环境要求">环境要求</h3>

<p>  在实践前请务必保证具备以下环境：</p>

<ul>
  <li>Docker</li>
  <li>docker-compose</li>
  <li>可用的 LDAP 目录服务</li>
</ul>

<h3 id="启动实例">启动实例</h3>

<p>  为了方便部署和测试，这里采用 <a href="https://hub.docker.com/r/wheelybird/openvpn-ldap-otp">wheelybird/openvpn-ldap-otp</a> 提供的 Docker 镜像。这个镜像比较小，同时也支持 x64 和 arm 两种体系架构，能满足大部分主流服务器平台。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># docker-compose.yml</span>

<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">openvpn</span><span class="pi">:</span>
    <span class="na">cap_add</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">NET_ADMIN</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">wheelybird/openvpn-ldap-otp</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">openvpn</span>
    <span class="na">ports</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s2">"</span><span class="s">1194:1194/udp"</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">volumes</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
     <span class="pi">-</span> <span class="s">/etc/timezone:/etc/timezone:ro</span>
     <span class="pi">-</span> <span class="s">./openvpn-data:/etc/openvpn</span>
    <span class="na">environment</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">OVPN_SERVER_CN=oc-vpn.example.com</span>
     <span class="pi">-</span> <span class="s">LDAP_URI=ldap://ldap.example.com</span>
     <span class="pi">-</span> <span class="s">LDAP_BASE_DN=ou=users,dc=example,dc=com</span>
     <span class="pi">-</span> <span class="s">LDAP_BIND_USER_DN=cn=admin,dc=example,dc=com</span>
     <span class="pi">-</span> <span class="s">LDAP_BIND_USER_PASS=password</span>
     <span class="pi">-</span> <span class="s">LDAP_LOGIN_ATTRIBUTE=uid</span>
     <span class="pi">-</span> <span class="s">LOG_TO_STDOUT=false</span>
     <span class="pi">-</span> <span class="s">OVPN_DNS_SEARCH_DOMAIN=example.com</span>
</code></pre></div></div>

<p>  使用以下 docker-compose.yml 文件和 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 命令启动实例。为了能够避免实例在重新创建后证书发生改变，将 Docker 实例中 /etc/openvpn 的目录持久化（与本地目录绑定）是非常重要的。在这里给出的环境变量（environment）中，前三项 OVPN_SERVER_CN、LDAP_URI、LDAP_BASE_DN 是必须要有的。如果 LDAP 目录服务默认是不能被匿名查找的，也必须包含 LDAP_BIND_USER_DN 和 LDAP_BIND_USER_PASS 变量的（即管理员账户名和密码）。当然，如果你想要指定匹配登录用户名字段，则需要新增 LDAP_LOGIN_ATTRIBUTE 变量。该变量默认是 uid 字段，也可以指定为其他 LDAP 目录服务中包含的字段，比如 email。这个镜像默认是会将服务的实时输出打印在终端，如果想要以日志文件的形式保存下来，则将变量 LOG_TO_STDOUT 置为 false 即可。</p>

<p>  一般来说，服务器内网为了管理方便，会根据服务器的 ip 和编号来配置对应的域名解析及反向域名解析，形如 <code class="language-plaintext highlighter-rouge">ec2-1-1-1-1.aws.com</code>，也有可能就是简单的 <code class="language-plaintext highlighter-rouge">c1.sever.aws.com</code>。所以当接入服务器内网后，我们可能会期望用 c1 来作为这台服务器的标签，而在终端我们也可能通过 <code class="language-plaintext highlighter-rouge">ping c1</code> 来测试通路。实际上只要在启动实例时新增变量 OVPN_DNS_SEARCH_DOMAIN 就可以实现，当然这里变量对应的值也应该变成 <code class="language-plaintext highlighter-rouge">server.aws.com</code>。相当于，有了这个配置后，本地 DNS 解析没有记录时会自动尝试加入后缀来解析。这样一来，是不是方便了很多呢？</p>

<p>  除此之外，该镜像还支持其他一些特性，比如 OTP，请访问 <a href="https://github.com/wheelybird/openvpn-server-ldap-otp">wheelybird/openvpn-ldap-otp</a> 了解更多。</p>

<h4 id="生成配置文件">生成配置文件</h4>

<p>  在生成配置文件上，<a href="https://github.com/wheelybird/openvpn-server-ldap-otp">wheelybird/openvpn-ldap-otp</a> 要比 <a href="https://github.com/kylemanna/docker-openvpn">kylemanna/docker-openvpn</a> 更复杂一些，可以手动从 Docker 实例的日志文件或终端输出内容中看到内容，大致内容形式如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#---------- Start of client.ovpn ----------</span>

client
tls-client
dev tun
persist-key
persist-tun
remote-cert-tls server
key-direction 1
auth SHA512
proto tcp
reneg-sec 0

comp-lzo
redirect-gateway def1
auth-user-pass

<span class="c"># Set log file verbosity</span>
verb 3

&lt;connection&gt;
remote oc-vpn.example.com 1194 udp
float
nobind
&lt;/connection&gt;

&lt;ca&gt;
<span class="nt">-----BEGIN</span> CERTIFICATE-----
.........
.........
<span class="nt">-----END</span> CERTIFICATE-----
&lt;/ca&gt;
&lt;tls-auth&gt;
<span class="c">#</span>
<span class="c"># 2048 bit OpenVPN static key</span>
<span class="c">#</span>
<span class="nt">-----BEGIN</span> OpenVPN Static key V1-----
.........
.........
<span class="nt">-----END</span> OpenVPN Static key V1-----
&lt;/tls-auth&gt;
key-direction 1
<span class="c">#----------  End of client.ovpn  ----------</span>
</code></pre></div></div>

<p>  将以上内容复制保存在 oc-vpn.example.com.ovpn 文件中即可。</p>

<h3 id="测试">测试</h3>

<p>  通常来说使用 OpenVPN 专用或者兼容客户端来加载配置文件 oc-vpn.example.com.ovpn，当然也可以用终端命令连接，如下所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>openvpn <span class="nt">--config</span> oc-vpn.example.com.ovpn
</code></pre></div></div>

<p>  执行上述命令后会提示输入用户名和密码进行认证，认证通过后会建立连接。默认分配的是 10.50.50.0/24 段中的某个 IP，网关为 10.50.50.254，当然这个也可以在启动实例时自行设置。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 再次提醒 </div> </div> <div class="content"> <p>  以上内容比较适用于团队办公或开发网络与服务器网络独立分离的情况（<strong>内网环境</strong>）。请勿在未获得工信部的资质许可的情况下在公网部署类似服务，一旦被云服务提供商监测到，云服务提供商有权进行警告、断网、关停等操作，并且无法申诉。</p>



 </div> </div>
<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://github.com/wheelybird/openvpn-server-ldap-otp">wheelybird/openvpn-ldap-otp</a></li>
  <li><a href="https://github.com/kylemanna/docker-openvpn">kylemanna/docker-openvpn</a></li>
</ul>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 提示 </div> </div> <div class="content"> <p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=1jkj42lj2m4nn">加入链接</a>。</p>



 </div> </div>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="LDAP" /><category term="OpenVPN" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">LDAP 集成之 Squid 篇</title><link href="https://lisz.me/tech/webmaster/ldap-squid.html" rel="alternate" type="text/html" title="LDAP 集成之 Squid 篇" /><published>2022-09-28T15:00:00+09:00</published><updated>2022-09-28T15:00:00+09:00</updated><id>https://lisz.me/tech/webmaster/ldap-squid</id><content type="html" xml:base="https://lisz.me/tech/webmaster/ldap-squid.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  Squid cache，简称 Squid，是一款高性能的代理缓存软件。Squid 本身支持包括 HTTP、HTTPS、FTP、SSH 在内的多种协议，且采用一个单独的、非模块化的、I/O 驱动的进程来处理所有的客户端请求，从而提供<strong>主动缓存加速</strong>的功能。除此之外，Squid 还可以提供<strong>应用层过滤控制</strong>的功能，也可与其他的<strong>防病毒</strong>软件一起使用。在一些大公司、学校、研究机构内部，一般采用 Squid 代理上网的方式，可以过滤危险内容或操作、节省网络带宽、提升访问速度。</p>

<p>  但实际上 Squid 代理也可用于正向代理，即为外来用户访问内网应用提速。这也是 CDN（内容分发网络）的加速原理，利用位于全球网络边缘的节点提供服务，而实际上的应用内容则通过边缘节点间的内网来缓存提速。</p>

<p>  虽然 Squid 一般部署在团队或公司网络内部，但是由于用户的权限不同可能需要应用不同的规则，所以能够与 LDAP 认证服务结合就变得非常重要了。</p>

<h2 id="实践">实践</h2>

<h3 id="环境要求">环境要求</h3>

<p>  在进行正式的实践之前，务必确保已有以下环境：</p>

<ul>
  <li>Docker</li>
  <li>docker-compose</li>
</ul>

<h3 id="启动实例">启动实例</h3>

<p>  笔者已经编译并公开了在多种体系架构上可用的 Docker 镜像 <a href="https://github.com/zhonger/docker-squid">zhonger/squid</a>。这里直接使用以下 docker-compose.yml 配置文件和 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 命令启动实例。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># docker-compose.yml</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.2'</span>

<span class="na">services</span><span class="pi">:</span> 
  <span class="na">squid</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">zhonger/squid</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">squid</span>
    <span class="na">hostname</span><span class="pi">:</span> <span class="s">squid</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">3128:3128"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/etc/timezone:/etc/timezone:ro</span>
      <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
    <span class="na">environment</span><span class="pi">:</span> 
      <span class="pi">-</span> <span class="s">SQUID_SSH=true</span>
      <span class="pi">-</span> <span class="s">SQUID_RSYNC=false</span>
      <span class="pi">-</span> <span class="s">LDAP_ENABLE=true</span>
      <span class="pi">-</span> <span class="s">LDAP_HOST=yourldap.domain.com</span>
      <span class="pi">-</span> <span class="s">LDAP_PORT=389</span>
      <span class="pi">-</span> <span class="s">LDAP_BindDN="cn=admin,dc=yourdomain,dc=com"</span>
      <span class="pi">-</span> <span class="s">LDAP_BindPass="********"</span>
      <span class="pi">-</span> <span class="s">LDAP_DN="ou=Users,dc=yourdomain,dc=com"</span>
      <span class="pi">-</span> <span class="s">LDAP_ATTRIBUT="uid=%s"</span>
      <span class="pi">-</span> <span class="s">PROXY_NAME="Proxy Display Name"</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
</code></pre></div></div>

<p>  上面有关的配置变量及其含义可以访问 <a href="https://github.com/zhonger/docker-squid">zhonger/squid</a> 了解更多。</p>

<h4 id="测试">测试</h4>

<p>  通过浏览器访问 http://ip:3128 并输入对应的用户名和密码可以看到类似下面的内容。</p>

<p><img src="https://i.lisz.top/blog/nUOnpb.webp" alt="nUOnpb" /></p>

<h3 id="客户端连接">客户端连接</h3>

<p>  由于我们未指定实际需要访问的地址，Squid 会直接报错。一般使用时，需要使用操作系统的网络设置中的代理来配置好 Squid。如下图所示，勾选“网页代理（HTTP）”并填写相关的 IP、端口、用户名及密码。如果想要同样应用在访问 HTTPS 站点，则还需要勾选“安全网页代理（HTTPS）”及填写相关信息。然后点击保存生效。</p>

<p><img src="https://i.lisz.top/blog/oXWsLE.webp" alt="oXWsLE" /></p>

<p>  这样一来就可以将访问的流量完全交给 Squid 来控制了。当然，如果不确定客户端连接是否成功，可以通过访问 <a href="https://ip.sb">ip.sb</a> 来确认当前客户端流量出口 IP 是否为 Squid 服务器 IP。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="http://www.squid-cache.org/">Squid cache</a></li>
  <li><a href="https://zh.wikipedia.org/zh-cn/Squid_(%E8%BD%AF%E4%BB%B6)">Squid 软件</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="LDAP" /><category term="Squid" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">内网私有域名解析</title><link href="https://lisz.me/tech/webmaster/internal-dns.html" rel="alternate" type="text/html" title="内网私有域名解析" /><published>2022-08-04T11:30:00+09:00</published><updated>2022-08-04T11:30:00+09:00</updated><id>https://lisz.me/tech/webmaster/internal-dns</id><content type="html" xml:base="https://lisz.me/tech/webmaster/internal-dns.html"><![CDATA[<h2 id="前言">前言</h2>

<h3 id="域名和域名解析">域名和域名解析</h3>

<p>  大家可能知道，在网络被发明出来之后一段时间，大家采用 <code class="language-plaintext highlighter-rouge">IP + Port</code> 的方式一起共享资源。后来随着资源越来越多，这样一种方式显得非常不友好。比如说，现在有 254 个 IP，每个 IP 上有 20 个 Web 应用，那么我们就必须记住 5080 个 <code class="language-plaintext highlighter-rouge">IP + Port</code> 的组合，简直太折磨人了。于是在 1983 年，保罗・莫卡派乔斯发明了域名解析服务和域名服务（DNS，Domain Name System）。从此以后，大家开始用域名来访问各种各样的应用服务。显然，相比原来 <code class="language-plaintext highlighter-rouge">IP + Port</code> 的方式，域名的含义更加具象、更容易被人记住。</p>

<p>  域名解析实际上就是把 IP 和一串有意义的字符对应，这是一对多的关系，即一个 IP 可能对应多个域名。域名的管理单位我们称之为域名注册管理机构，他们掌握着顶级域名的管理权利。比如说，.net、.com、.org 就是顶级域名，域名注册管理机构对顶级域名具有完整的权利。就像上次讲到的 SSL 根证书一样，光有域名注册管理机构还是不够的，他们没有办法直接把域名卖给全世界所有的公司或者个人，而是需要域名注册商承担这部分工作。像我们比较熟知的国内的万网（现在阿里云域名）、DNSPod（现在腾讯云域名）等，国外的 Gandi、Godaddy 等，都是域名注册商。顶级域名根据用途不同可以分为，国别域名后缀和通用域名后缀。国别域名后缀就是指定给各个国家或地区使用的，通用域名后缀就是其余的。我们可以在某域名注册商处购买某个域名后缀（也称顶级域名）的子域名（也称二级域名），比如说我们可以购买域名后缀为 .com 的域名 baidu.com（当然 baidu.com 早就被注册了，我们只能购买还未被注册的域名）。由于一些品牌效应，大部分域名后缀都会保留一些子域名，我们一般称之为<strong>溢价域名</strong>。一般来说，溢价域名也会比普通域名价格更贵。当我们购买了域名之后，域名注册商会免费提供域名解析服务。当然，我们也可以要求使用其他厂商提供的免费或收费域名解析服务，甚至也可自行搭建域名解析服务。</p>

<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> 小提醒 </div> </div> <div class="content"> <p>  国内需具备一定资质才能在公网上搭建域名解析服务，否则会面临警告和阻断的风险。</p>



 </div> </div>
<p>  为了简便，我们一般把域名解析服务称为 DNS 服务。在操作系统中，53 端口被视为 DNS 服务的标准端口（TCP/UDP 服务），853 端口被视为 DNS over TLS 的标准端口（TCP 服务）。除此之外，DNS over HTTPS（TCP 服务）和 DNS over Quic（新协议，UDP 服务）的标准端口是 443。所以现有能够公开使用的 DNS 服务都采用了标准端口，比如国内著名的 114 DNS、阿里云 DNS、腾讯云 DNS、百度云 DNS 都是如此。如果想要了解更多开放可用的 DNS 服务可以查看 <a href="https://adguard-dns.io/kb/general/dns-providers/">这里</a>。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小知识 </div> </div> <div class="content"> <p>  DNS 按照功能上的不同可以分为 <strong>权威 DNS</strong> 和 <strong>递归 DNS</strong>。权威 DNS 负责对某个或多个子域名进行管理，注册商提供的域名解析服务就是这一类。递归 DNS 负责接收客户端的请求并将查询到的域名对应记录返回给客户端，也就是说它本身不对任何子域名进行管理，只转述别人告诉它的结果。</p>



 </div> </div>
<p>  当我们使用 DNS 时，它（这里指递归 DNS）会如下图所示按照域名系统的构成逐级进行查询。比如说，现在我们想访问 www.baidu.com：</p>

<ol>
  <li>客户端（我们）向递归 DNS 请求解析 www.baidu.com；</li>
  <li>递归 DNS 会先去问一下它的上游 DNS，如果不存在上游 DNS，它就只能去问 DNS 根服务器；</li>
  <li>DNS 根服务器并不知道具体的解析记录，但是会告诉递归 DNS 顶级域名 .com 的 DNS 服务器；</li>
  <li>递归 DNS 接着向 .com 的 DNS 服务器询问；</li>
  <li>结果 .com 的 DNS 服务器也不知道具体的解析记录，但是会告诉递归 DNS 二级域名 baidu.com 的 DNS 服务器；</li>
  <li>这样递归 DNS 才会去问域名 baidu.com 的权威 DNS；</li>
  <li>然后，baidu.com 权威 DNS 响应 www.baidu.com 对应的 A 记录（或者 AAAA 记录）是什么；</li>
  <li>最后，递归 DNS 将解析结果告诉客户端（我们）。</li>
</ol>

<p><img src="https://i.lisz.top/blog/hwyKGH.webp" alt="域名解析过程 DNS Resolution Process" /></p>

<p>  那么问题来了，<strong>一个 DNS 能否同时是权威 DNS 和递归 DNS 呢？</strong>实际上是不可能的，但是可以实现这种效果。如果我们把权威 DNS 隐藏在递归 DNS 的后面，那么对于顶级域名 DNS 来说，你指定的递归 DNS 就是它理解的权威 DNS。这里的隐藏指的是，当有请求询问递归 DNS 的权威解析记录时，递归 DNS 根据规则将请求转发给背后真正的权威 DNS。等待权威 DNS 返回解析记录后，递归 DNS 再把结果返回给请求方（其他递归 DNS 或者客户端）。</p>

<h3 id="私有域名解析">私有域名解析</h3>

<h4 id="必要性">必要性</h4>

<p>  以上谈到的都是公有域名的相关事情，为什么又要考虑私有域名解析呢？首先，公有域名和私有域名本质上可以没有区别，都是在域名注册商处购买的域名，也可以有所区别，即私有域名是未购买的或者是非 ICANN 支持的域名（比如 .lisz 后缀）。这样一来，我们将不再受<strong>域名是否注册</strong>的限制而应用在内部网络中。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  当然，我们应当避免使用 ICANN 支持的域名后缀且可注册的域名，毕竟可能以后会有人购买这个域名。</p>



 </div> </div>
<p>  其次，解析记录的<strong>内外分离</strong>需求。随着基础服务架构和应用架构的不断发展，越来越多像云计算、Kubernetes 这样需要采用域名解析来连通内部服务。如果我们直接采用一个权威 DNS 来解析这些记录，那就意味着所有人都可以通过查询来知道这些解析记录，甚至有些人就能大致猜出服务架构，这并不是很安全。出于安全上的考量，将同一个域名的解析记录进行内外分离能够在一定程度上提升安全。</p>

<p>  如参考资料中《内网域名系统的安全保密风险研究》所说，“随着内网规模的不断扩大，特别是国家电子政务内网的建成、扩展，在电子政务内网中构建国家级可信内网域名体系的需求越来越迫切，内网域名系统会成为内网的核心基础设施，其安全问题将会越来越被关注。”私有域名解析，即内网域名系统在内网安全中发挥着举足轻重的作用。</p>

<h4 id="用途">用途</h4>

<p>  笔者在实际使用 AWS、Azure、Oracle、阿里云、腾讯云、Ucloud 的过程中，也发现了私有域名解析的应用。举个例子，Oracle 云创建的每一台 VPS 都会有一个内部 FQDN（以 oraclecv.com 为后缀的多级域名）。当你在 VPS 上使用 dig 命令查询这个 FQDN 对应的 A 记录时，VPS 的内网 IP 会被返回。当你在自己的设备上使用 dig 命令查询时，返回为空。再举个例子，云计算厂商的 VPS 默认配置的是他们自家的镜像源，比如腾讯云 VPS 的默认镜像源域名为 mirrors.tencentyun.com，而这个域名在公网上是查不到解析记录的。可见，云计算厂商的架构上也在使用私有域名解析。</p>

<p>  当然，云计算厂商们也向用户提供依托于 VPC（私有网络）的私有域名解析服务，即该私有域名解析服务只有在同一 VPC 内的 VPS 可以使用。而我们又知道，VPC 是属于用户个人的，也就是说不同用户之间的私有域名解析服务完全互不干扰。</p>

<p>  在参考资料一中，阿里云列出了实际云服务中私有域名解析的四大应用场景：</p>

<ul>
  <li><strong>主机名管理</strong>：根据用途、机器信息语义化命名，对运维人员更友好。</li>
  <li><strong>内部调用 API</strong>：内部 API 用域名来访问，即使对应集群或者 IP 发生变化，也可以无感切换。</li>
  <li><strong>内部域名隐私保护</strong>：和上面笔者提到的必要性第二点一样，提升隐私保护。</li>
  <li><strong>私有地址反向解析</strong>：绑定后可以通过 host、traceroute 或其他操作直接识别访问 IP 的来源，便于运维人员排查问题。</li>
</ul>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小知识 </div> </div> <div class="content"> <p>  域名解析分为<strong>正向解析</strong>和<strong>反向解析</strong>，我们一般见过的“域名 → IP”的域名解析就是正向解析，而反向解析则是“IP → 域名”。一般来说，反向解析多用于邮件服务器的可信认证。将 IP 与 邮件服务器域名的正反向解析都绑定后，能够增强邮件服务器的可信度，降低被收信服务器判定为 <strong>垃圾 IP</strong> 发信的概率。</p>



 </div> </div>
<h2 id="实践">实践</h2>

<h3 id="方案一">方案一</h3>

<p>  内网私有域名解析实际上就是要在内网中搭建一台权威 DNS 和递归 DNS：权威 DNS 用于管理私有域名，递归 DNS 用于解析权威 DNS 记录以及正常的公网解析记录。当然，在公司网络或者机房集群网络中，一般会搭建权威 DNS 集群和递归 DNS 集群来提升可靠性和可用性。权威 DNS 集群通常是主从架构，主节点作为接受域名解析操作的主要接收方，从节点将实时同步主节点记录。当主节点发现故障时，从节点自动升级为主节点。并非所有的集群都是这样，但是这样更加能避免因主节点宕机后无法进行域名解析的更改操作。由于这与采用架设 DNS 服务的软件相关，这里就不作过多探讨。</p>

<p>  与权威 DNS 集群不同的是，内网递归 DNS 集群实际上一般会有两个节点暴露出来。这一点与公网中提供公网递归 DNS 服务是一样的。比如 114 DNS 会告诉大家要设置两个 DNS IP 地址，即 114.114.114.114 和 114.114.115.115。为什么要这样呢？主要还是因为通过冗余来提高可靠性和可用性。我们可能会简单地以为 114 DNS 就只有这两个 IP，但实际上它们的背后还有很多台递归 DNS 服务器。这两台服务器的作用并不是直接处理解析请求，而是为想要域名解析的客户端提供一个更加快和高效的方式来使用递归 DNS。类似于复杂 Web 系统中首先会在交换机上用网关进行优化，然后在服务器上利用 LVS 来负载均衡，之后再利用多个服务后台来分别处理相同的业务，最后再返回信息给用户。这两台递归 DNS 节点也起到了负载均衡的作用。</p>

<p>  当然，这两个 IP 也不是一般的 IP，而是使用了 Anycast 技术的 IP。也就是说，在互联网上会有多台服务器使用了这两个 IP，而当我们向这两个 IP 发起请求时，BGP 会根据客户端所处的地理位置和网络情况将 IP 定位到离客户端最近的两台服务器上。有一个比较客观的体验就是，当我们在全国不同地方 ping 这两个 IP 时，发现似乎延迟差不多且都很短。但是无论我们的骨干网建得多么好，因地理位置和跨网（电信、联通、移动、教育网）所带来的延迟也是无法避免的。唯一一个延迟都很短的可能解释就是响应请求的机器实际上并非同一位置的同两台，而是位于不同位置的不同两台。</p>

<h3 id="方案二">方案二</h3>

<p>  上面的方案考虑的问题比较多，也比较适合在大规模集群或内网中进行实践，但是在小集群中可能就有点过于庞大了，显得没有必要。其实，小集群或者小团队内网可以采用“合二为一”的方案，即递归 DNS 与权威 DNS 由一台服务器来同时提供。由于小集群内网私有域名解析和公有域名解析不需要接近于零的宕机率，所以完全可以最简化。当前最流行的免费解决方案可能就是 AdGuard Home 了。</p>

<div class="premonition citation"> <div class="header"> <svg class="icon citation" aria-hidden="true"> <use xlink:href="#icon-citation"></use> </svg> </div> <div class="content"> <p>  AdGuard Home 是一款全网广告拦截与反跟踪软件。在您将其安装完毕后，它将保护您所有家用设备，同时您不再需要安装任何客户端软件。随着物联网与连接设备的兴起，掌控您自己的整个网络环境变得越来越重要。</p>



 </div> <div class="ref"> ------ AdGuard 主页 </div> </div>
<p>  AdGuard Home 之所以这么受到欢迎，主要是因为其丰富的功能和简单的可视化操作，对于管理员来说非常友好。而且，AdGuard Home 的部署也非常简单，支持多平台架构、多方式一键部署，比如 AdGuard Home 也能在 ARM 芯片上用 Docker 容器的方式一键部署。虽然 AdGuard Home 自带简单的解析记录重写，可以满足大部分常用的内网私有域名解析需求，但是像一些比较高级的解析记录可能就无法做到，比如 TXT 记录。尽管 TXT 记录在 <strong>IP</strong> 和<strong>域名</strong>的相互映射中并不起到作用，但是 TXT 记录可以填写比较长的内容，非常适合用来验证对于域名的管理权限，像 HTTPS 证书的申请一般就是采用新增 TXT 记录的方式验证，还有 Gitlab Page 的自定义域名绑定也是如此。所以为了提供比较完整的域名解析服务，这里还是建议增加一个权威 DNS，可以采用 PowerDNS + PowerDNS Admin（交互界面）或者 Bind9 等。</p>

<p>  考虑到友好的交互界面更容易上手使用，这里只介绍 AdGuard Home + PowerDNS 的方案。需要提前准备的环境有：</p>

<ul>
  <li>Docker</li>
  <li>docker-compose</li>
</ul>

<h3 id="adguard-home">AdGuard Home</h3>

<p>  由于 AdGuard Home 官方已经提供了多平台架构的 Docker 镜像，我们直接使用即可，docker-compose.yml 文件如下所示：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3"</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">adgurad</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">adguard/adguardhome</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">53:53/tcp</span>
      <span class="pi">-</span> <span class="s">53:53/udp</span>
      <span class="pi">-</span> <span class="s">80:80/tcp</span>
      <span class="pi">-</span> <span class="s">443:443/tcp</span>
      <span class="pi">-</span> <span class="s">3000:3000/tcp</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./work:/opt/adguardhome/work</span>
      <span class="pi">-</span> <span class="s">./conf:/opt/adguardhome/conf</span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 命令启动 AdGuard Home 实例。</p>

<h4 id="初始化">初始化</h4>

<p>  使用浏览器访问 <a href="http://localhost:3000">http://localhost:3000</a> 进行实例初始化设置，如下所示根据页面提示设置好用户名和密码。</p>

<p><img src="https://i.lisz.top/blog/PreFoj.webp" alt="初始化 AdGuard Home Initial" /></p>

<p><img src="https://i.lisz.top/blog/7LHDlg.webp" alt="确认端口 Check ports" /></p>

<p><img src="https://i.lisz.top/blog/qjTNW8.webp" alt="设置管理员 Set Admin" /></p>

<p><img src="https://i.lisz.top/blog/yLkLc4.webp" alt="客户端配置指南 Client setting guideline" /></p>

<p><img src="https://i.lisz.top/blog/buQ6LT.webp" alt="完成初始化 Finish the initialization" /></p>

<p>  初始化成功后，页面会自动跳转到登录界面 <a href="http://localhost">http://localhost</a>（80 端口）。</p>

<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>  由于在实际环境中，我们不一定是在本机启动该实例，所以可能需要使用服务器的 IP 来替代 localhost 访问。另外，如果原来就有 Nginx 或其他服务占用了 80 端口，我们在配置端口映射的时候可能就会设置到另外一个端口，因此自动跳转到的页面并非是 AdGuard Home 的首页。我们需要使用 IP + 映射 80 的端口来定位到首页。</p>



 </div> </div>
<p><img src="https://i.lisz.top/blog/Wwb5At.webp" alt="登录页面 AdGuard Home Login" /></p>

<h4 id="私有域名转发">私有域名转发</h4>

<p>  由于接下来我们将要用 PowerDNS 来管理权威域名解析，所以需要设置私有域名规则，即当 AdGuard Home 收到关于内网自定义权威域名的请求时，就会把请求转给 PowerDNS。这在 AdGuard Home 中也是比较容易就能设置好的，如下图所示，添加一行规则使得匹配的所有二级域名请求转发给 PowerDNS。</p>

<p><img src="https://i.lisz.top/blog/4GMZAO.webp" alt="配置转发 Redirect to Authroized DNS" /></p>

<h3 id="powerdns">PowerDNS</h3>

<p>  虽然 PowerDNS 和 PowerDNS-Admin 官方都提供了 Docker 镜像，但是搭配起来用还是有点莫名其妙的问题。为了更加简单，笔者参考官方自行构建了 <code class="language-plaintext highlighter-rouge">zhonger/pdns</code> 和 <code class="language-plaintext highlighter-rouge">zhonger/powerdns-admin</code> 两个 Docker 镜像，搭配使用更加便捷可用。如果想要了解更多，可以查看 <a href="../docker/powerdns.html">《Docker 镜像构建之 PowerDNS 篇》</a>。
  </p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3"</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">pdns</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">zhonger/pdns:latest</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">753:53/tcp"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">753:53/udp"</span>
      <span class="c1"># - "8081:8081"</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">PDNS_launch=gsqlite3</span>
      <span class="pi">-</span> <span class="s">PDNS_gsqlite3_database=/var/lib/powerdns/pdns.sqlite3</span>
      <span class="pi">-</span> <span class="s">PDNS_webserver_address=0.0.0.0</span>
      <span class="pi">-</span> <span class="s">PDNS_webserver_allow_from=127.0.0.1,10.0.0.0/8,172.0.0.0/8,192.168.0.0/16</span>
      <span class="pi">-</span> <span class="s">PDNS_api=yes</span>
      <span class="pi">-</span> <span class="s">PDNS_api_key={Random Long String}</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
      <span class="pi">-</span> <span class="s">./powerdns:/var/lib/powerdns</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mysql:latest</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">MYSQL_ALLOW_EMPTY_PASSWORD=yes</span>
      <span class="pi">-</span> <span class="s">MYSQL_DATABASE=powerdnsadmin</span>
      <span class="pi">-</span> <span class="s">MYSQL_USER=pdns</span> 
      <span class="pi">-</span> <span class="s">MYSQL_PASSWORD=mypdns</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
      <span class="pi">-</span> <span class="s">./pda-mysql:/var/lib/mysql</span>

  <span class="na">app</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">zhonger/powerdns-admin:latest</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">db</span>
      <span class="pi">-</span> <span class="s">pdns</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8080:80"</span>
    <span class="na">logging</span><span class="pi">:</span>
      <span class="na">driver</span><span class="pi">:</span> <span class="s">json-file</span>
      <span class="na">options</span><span class="pi">:</span>
        <span class="na">max-size</span><span class="pi">:</span> <span class="s">50m</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/etc/localtime:/etc/localtime:ro</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">SQLALCHEMY_DATABASE_URI=mysql://pdns:mypdns@db/powerdnsadmin</span>
      <span class="pi">-</span> <span class="s">GUNICORN_TIMEOUT=60</span>
      <span class="pi">-</span> <span class="s">GUNICORN_WORKERS=2</span>
      <span class="pi">-</span> <span class="s">GUNICORN_LOGLEVEL=DEBUG</span>
      <span class="pi">-</span> <span class="s">OFFLINE_MODE=False</span> <span class="c1"># True for offline, False for external resources </span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 命令启动 PowerDNS 和 PowerDNS-Admin 实例。</p>

<h4 id="初始化用户">初始化用户</h4>

<p>  PowerDNS-Admin 本身不会自动初始化管理员用户，而是将注册的第一个用户认定为管理员用户。使用浏览器访问 PowerDNS-Admin 登录页面 <a href="http://localhost:8080">http://localhost:8080</a>，如下图所示点击 Create an account 链接跳转到注册页。</p>

<p><img src="https://i.lisz.top/blog/9NDNpc.webp" alt="PowerDNS-Admin 登录页 Login page" /></p>

<p>  如下图所示，填写姓名、邮箱、用户名和密码，点击 Register 按钮即可完成注册。这里，PowerDNS-Admin 默认采用邮箱的 Gavatar 头像作为用户头像。</p>

<p><img src="https://i.lisz.top/blog/TJqhDE.webp" alt="PowerDNS-Admin 注册页 Register page" /></p>

<h4 id="初始化配置">初始化配置</h4>

<p>  注册和登录后，会跳转到 PDNS 配置页面。这里由于 PDNS 和 PowerDNS-Admin 实例是在同一个网络中，可以直接使用 pdns 来代替 PDNS 实例的 IP 地址。PDNS API KEY 则是刚才启动时设置的那一长串字符（PDNS_api_key）。PDNS VERSION 最好是与 PDNS 实际使用的一致，不过不一致也不会有什么事。<code class="language-plaintext highlighter-rouge">zhonger/pdns:latest</code> 目前实际是 4.6 版本，这里默认填的 4.1.1 也可以。然后点击 Update 按钮保存配置。</p>

<p><img src="https://i.lisz.top/blog/CJ1Wl1.webp" alt="CJ1Wl1" /></p>

<p>  保存配置成功后，如果填写信息无误，点击侧边导航中的 PDNS 就可以看到 PDNS 的各项配置信息。如果填写有误，则没有任何信息。</p>

<p><img src="https://i.lisz.top/blog/UdkXGi.webp" alt="UdkXGi" /></p>

<h4 id="新增域名">新增域名</h4>

<p>  接下来就可以点击侧边导航栏中的 New Domain 来新增私有域名 home.lisz。如下图所示，我们需要填写的是域名，需要选择的是域名模板，一般 basic_template_1 即可。之后点击 Submit 按钮提交。</p>

<p><img src="https://i.lisz.top/blog/nMyRKR.webp" alt="nMyRKR" /></p>

<h4 id="新增解析记录">新增解析记录</h4>

<p>  新增域名成功后，我们就可以在 Dashboard 里面的域名列表看到 home.lisz 了。点击即可进入域名解析。</p>

<p><img src="https://i.lisz.top/blog/naFe9s.webp" alt="naFe9s" /></p>

<p>  这里我们以一个 CNAME 和 A 记录为例，来尝试新增解析记录。如下图所示，点击左上角的 Add Record 添加记录，完成后点击右上角的 Apply Changes 来提交解析记录到 PDNS。</p>

<p><img src="https://i.lisz.top/blog/SmwtCT.webp" alt="SmwtCT" /></p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> 小知识 </div> </div> <div class="content"> <p>  实际域名解析时我们一般会采用 CNAME 和 A 记录联合使用的方式，这样相当于在 DNS 解析层面就有负载均衡了。A 记录是域名与 IP 的关系，这就意味着同一个域名可以有多个 A 记录。CNAME 记录是域名与域名的关系，而两个域名分别是为了不同的目的，前一个是为了给大家使用的，后一个是为了运维人员使用的。当存在 CNAME → A 时，客户端会根据网络情况来判断使用哪一条 A 记录对应的 IP，从而提升用户体验。</p>



 </div> </div>
<h3 id="验证">验证</h3>

<h4 id="验证权威-dns-是否正常">验证权威 DNS 是否正常</h4>

<p>  如下所示向 AdGuard Home 询问私有域名解析记录，解析正常。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>─<span class="nv">$ </span>dig @127.0.0.1 <span class="nt">-p</span> 53 www.home.lisz

<span class="p">;</span> &lt;&lt;<span class="o">&gt;&gt;</span> DiG 9.18.1-1ubuntu1.1-Ubuntu &lt;&lt;<span class="o">&gt;&gt;</span> @127.0.0.1 <span class="nt">-p</span> 53 www.home.lisz
<span class="p">;</span> <span class="o">(</span>1 server found<span class="o">)</span>
<span class="p">;;</span> global options: +cmd
<span class="p">;;</span> Got answer:
<span class="p">;;</span> -&gt;&gt;HEADER<span class="o">&lt;&lt;-</span> <span class="no">opcode</span><span class="sh">: QUERY, status: NOERROR, id: 47193
;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1232
;; QUESTION SECTION:
;www.home.lisz.                 IN      A

;; ANSWER SECTION:
www.home.lisz.          60      IN      CNAME   www101.home.lisz.
www101.home.lisz.       60      IN      A       192.168.1.1

;; Query time: 20 msec
;; SERVER: 127.0.0.1#53(127.0.0.1) (UDP)
;; WHEN: Tue Aug 23 17:05:15 JST 2022
;; MSG SIZE  rcvd: 79
</span></code></pre></div></div>

<h4 id="验证递归-dns-是否正常">验证递归 DNS 是否正常</h4>

<p>  如下所示，向 AdGuard Home 询问公有域名解析记录，解析正常。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-<span class="nv">$ </span>dig @127.0.0.1 <span class="nt">-p</span> 53 www.baidu.com

<span class="p">;</span> &lt;&lt;<span class="o">&gt;&gt;</span> DiG 9.18.1-1ubuntu1.1-Ubuntu &lt;&lt;<span class="o">&gt;&gt;</span> @127.0.0.1 <span class="nt">-p</span> 53 www.baidu.com
<span class="p">;</span> <span class="o">(</span>1 server found<span class="o">)</span>
<span class="p">;;</span> global options: +cmd
<span class="p">;;</span> Got answer:
<span class="p">;;</span> -&gt;&gt;HEADER<span class="o">&lt;&lt;-</span> <span class="no">opcode</span><span class="sh">: QUERY, status: NOERROR, id: 8988
;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1232
;; QUESTION SECTION:
;www.baidu.com.                 IN      A

;; ANSWER SECTION:
www.baidu.com.          831     IN      CNAME   www.a.shifen.com.
www.a.shifen.com.       28      IN      CNAME   www.wshifen.com.
www.wshifen.com.        192     IN      A       45.113.192.102
www.wshifen.com.        192     IN      A       45.113.192.101

;; Query time: 244 msec
;; SERVER: 127.0.0.1#53(127.0.0.1) (UDP)
;; WHEN: Tue Aug 23 17:06:03 JST 2022
;; MSG SIZE  rcvd: 127
</span></code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://help.aliyun.com/document_detail/64623.html">阿里云帮助中心 - 云解析 - 应用场景</a></li>
  <li><a href="https://cloud.tencent.com/document/product/1338/50547">腾讯云文档中心 - 子域名递归解析说明</a></li>
  <li><a href="https://support.huaweicloud.com/dns_faq/dns_faq_040.html">华为云文档 - 如何设置内网域名既支持内网解析，也支持公网解析？</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1123748">公司内网搭建代理 DNS 使用内网域名代替 ip 地址</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1821030">一文搞懂 DNS 基础知识，收藏起来有备无患~</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1691018">搞它！！！深入了解DNS域名解析服务，教你搭建一个属于自己的DNS服务器（正向解析、反向解析、泛域名解析、邮件交换解析、别名解析、分离解析，主从结构解析）</a></li>
  <li><a href="https://www.modb.pro/db/433331">推荐一款 Private DNS 服务</a></li>
  <li><a href="https://sspai.com/post/63088">AdGuard Home 安装及使用指北</a></li>
  <li><a href="http://www.gjbmj.gov.cn/n1/2021/0722/c411145-32166624.html">内网域名系统的安全保密风险研究</a></li>
  <li><a href="https://computingforgeeks.com/running-powerdns-and-powerdns-admin-in-docker-containers/">Running PowerDNS and PowerDNS Admin in Docker Containers</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="域名解析" /><category term="DNS" /><category term="私有域名" /><category term="内网" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">内网 HTTPS 可信证书</title><link href="https://lisz.me/tech/webmaster/ca-ssl.html" rel="alternate" type="text/html" title="内网 HTTPS 可信证书" /><published>2022-08-03T11:30:00+09:00</published><updated>2022-08-03T11:30:00+09:00</updated><id>https://lisz.me/tech/webmaster/ca-ssl</id><content type="html" xml:base="https://lisz.me/tech/webmaster/ca-ssl.html"><![CDATA[<h2 id="前言">前言</h2>

<h3 id="内网-https-化的必要性">内网 HTTPS 化的必要性</h3>

<p>  开发团队或者公司内部一般会采用内外网隔离、上网行为过滤等措施，比较可靠地保证了内部设备无法被外部网络所侦测，从而可能认为 HTTP 内网站点是一个相对安全的存在。即使在 HTTPS 证书如此盛行的今天，也还暂时不考虑内部站点的 HTTPS 化。<code class="language-plaintext highlighter-rouge">IP + Port</code> 或者 <code class="language-plaintext highlighter-rouge">http://本地域名</code> 的访问方式依旧是座上宾。当然，如果考虑到购买 HTTPS 证书的成本或者团队内网站点采用 Letsencrypt 等免费证书过于麻烦（只能采用 DNS 验证的方式每三个月申请一次新证书），那么自签名 SSL 证书则成为首选了。不过，如果为每一个内网站点都生成一个 SSL 证书，然后让大家都手动把 HTTPS 标为可信，那么当面临大量内网站点时，大家可能要被搞崩溃。更为可行的办法是，<strong>生成一个内网用的根证书，只标记该根证书可信</strong>。</p>

<h3 id="根证书">根证书</h3>

<p>  与其相信别人根证书生成的 SSL 证书，不如相信自己根证书生成的。我们的目的毕竟不是要任何一个人都把我们自签名的证书标为可信，只要在内网内使用内网站点的设备能够信任即可。而且成为一个受到公众信任的根证书是非常困难的一件事，即使经过几十年可能也没有办法做到。如今现有的根证书实际上有限，像我们平常熟悉的 Letsencrypt、ZeroSSL、Cloudflare 等等并不是根证书而是中间证书。有点类似总代理和分代理的感觉，根证书在业界具有广泛的公信力，但是让根证书去给个人或者企业生成证书可能有点忙不过来。于是根证书生成若干个中间证书，再由中间证书来为个人或者企业生成实际的证书。</p>

<p>  一般来说，操作系统或浏览器的产商会预置国际上认可的根证书。如下所示，为 Mac OS 上预置的根证书列表。</p>

<p><img src="https://i.lisz.top/blog/SfWsIJ.webp" alt="Mac OS 预置根证书 Root Certificate" /></p>

<h2 id="实践">实践</h2>

<p>  话不多说，让我们来实践一下如何生成自己的根证书和签发 SSL 证书吧。</p>

<h3 id="生成根证书">生成根证书</h3>

<h4 id="安装-openssl-可选">安装 OpenSSL (可选)</h4>

<p>  此处只考虑 Mac OS 和 Ubuntu，其他环境如何安装可以自行搜索。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Mac OS</span>
brew <span class="nb">install </span>openssl

<span class="c"># Ubuntu</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> openssl
</code></pre></div></div>

<h4 id="创建根密钥">创建根密钥</h4>

<p>  使用以下命令创建根密钥 <code class="language-plaintext highlighter-rouge">zhonger-key.pem</code>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl genrsa <span class="nt">-out</span> zhonger-key.pem 4096
</code></pre></div></div>

<h4 id="创建根证书并签名">创建根证书并签名</h4>

<p>  使用刚创建好的根密钥 <code class="language-plaintext highlighter-rouge">zhonger-key.pem</code> 生成根证书，并输入相关信息。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req <span class="nt">-new</span> <span class="nt">-x509</span> <span class="nt">-days</span> 3600 <span class="nt">-key</span> zhonger-key.pem <span class="nt">-out</span> zhongerca.pem
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╰─<span class="nv">$ </span>openssl req <span class="nt">-new</span> <span class="nt">-x509</span> <span class="nt">-days</span> 3600 <span class="nt">-key</span> zhonger-key.pem <span class="nt">-out</span> zhongerca.pem 
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class="s1">'.'</span>, the field will be left blank.
<span class="nt">-----</span>
Country Name <span class="o">(</span>2 letter code<span class="o">)</span> <span class="o">[</span>AU]:CN
State or Province Name <span class="o">(</span>full name<span class="o">)</span> <span class="o">[</span>Some-State]:Shanghai
Locality Name <span class="o">(</span>eg, city<span class="o">)</span> <span class="o">[]</span>:Shanghai
Organization Name <span class="o">(</span>eg, company<span class="o">)</span> <span class="o">[</span>Internet Widgits Pty Ltd]:zhonger
Organizational Unit Name <span class="o">(</span>eg, section<span class="o">)</span> <span class="o">[]</span>:zhonger
Common Name <span class="o">(</span>e.g. server FQDN or YOUR name<span class="o">)</span> <span class="o">[]</span>:lisz.me
Email Address <span class="o">[]</span>:contact@lisz.me
</code></pre></div></div>

<h4 id="验证根证书">验证根证书</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>─<span class="nv">$ </span>openssl x509 <span class="nt">-text</span> <span class="nt">-in</span> zhongerca.pem <span class="nt">-noout</span>
Certificate:
    Data:
        Version: 3 <span class="o">(</span>0x2<span class="o">)</span>
        Serial Number:
            44:48:03:56:ff:15:57:03:00:34:1f:85:61:ca:f7:7a:1e:4f:38:8f
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C <span class="o">=</span> CN, ST <span class="o">=</span> Shanghai, L <span class="o">=</span> Shanghai, O <span class="o">=</span> zhonger, OU <span class="o">=</span> zhonger, CN <span class="o">=</span> lisz.me, emailAddress <span class="o">=</span> contact@lisz.me
        Validity
            Not Before: Aug  3 05:25:47 2022 GMT
            Not After : Jun 11 05:25:47 2032 GMT
        Subject: C <span class="o">=</span> CN, ST <span class="o">=</span> Shanghai, L <span class="o">=</span> Shanghai, O <span class="o">=</span> zhonger, OU <span class="o">=</span> zhonger, CN <span class="o">=</span> lisz.me, emailAddress <span class="o">=</span> contact@lisz.me
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: <span class="o">(</span>4096 bit<span class="o">)</span>
                Modulus:
                    00:b2:d1:47:73:8a:83:48:e3:47:1a:41:01:f6:63:
                    69:43:39:71:eb:2b:74:be:dc:63:f3:df:79:66:ee:
                    00:30:65:b3:4f:7e:58:88:00:13:09:e6:4f:74:57:
                    fa:a3:56:24:cd:b6:1f:53:25:77:98:bf:9f:45:64:
                    7c:6c:04:23:c4:8f:0f:bf:2e:b3:d1:2e:4c:05:4d:
                    4c:e6:65:54:ad:0c:35:b7:d9:c8:74:97:19:c7:a5:
                    <span class="nb">cd</span>:9a:a4:73:37:13:71:80:34:7c:bc:b3:41:5a:34:
                    bb:16:82:44:18:a1:0a:a5:f5:f1:07:ca:8d:b3:9a:
                    ef:74:fb:a0:6c:72:4a:53:5c:59:74:6f:aa:c7:bc:
                    48:26:af:1b:70:f3:5f:7f:c7:df:8d:e5:da:e4:f4:
                    d2:fa:90:d3:e2:67:e1:9a:df:c7:c4:c7:53:6f:62:
                    25:ed:ff:0a:17:cf:8d:4d:84:6b:38:cb:49:e7:3d:
                    c5:2b:15:76:e6:eb:cc:17:94:40:20:7d:ee:8c:36:
                    6d:cf:9c:d7:1f:a6:41:20:9d:45:cd:57:8f:a8:61:
                    f8:8b:e9:31:6a:a9:96:c1:db:57:64:0b:09:da:ca:
                    b3:07:d9:55:ed:fe:69:a0:9c:78:5b:59:a5:7b:a1:
                    2b:4d:68:22:b4:7f:db:c6:c1:12:ee:eb:9b:29:38:
                    ae:7b:4c:0d:2a:ab:33:3f:af:a8:7b:ca:89:2c:62:
                    0f:a8:ef:89:60:9e:fd:a2:df:36:6d:70:82:8b:fa:
                    b3:ee:79:7e:fd:3f:e7:90:84:58:85:7e:7e:69:07:
                    1e:50:05:0b:87:4d:66:e4:17:6b:c2:97:03:48:e4:
                    7d:08:b4:81:a6:05:80:60:5c:eb:8d:53:db:7c:62:
                    a8:6d:a7:75:f1:56:b6:d9:0d:6b:3b:be:8b:72:39:
                    8d:e7:2d:77:74:e3:4d:a1:fd:8b:44:f9:ee:fd:0d:
                    04:ec:6a:fc:f3:d2:15:fc:18:ff:7d:33:44:2b:6d:
                    7f:3c:33:21:e1:d8:5f:08:fa:53:fd:26:fb:6e:74:
                    d7:4b:51:62:d3:15:1b:3b:44:78:78:9b:91:c7:ba:
                    82:2b:12:d7:b2:83:0a:39:ec:5e:a9:a9:c1:04:a6:
                    2e:64:a5:ea:15:c3:85:e9:ac:38:6b:22:eb:3b:08:
                    b8:0a:31:10:df:45:1d:76:81:e0:0f:88:e4:00:ef:
                    6e:90:59:8c:d8:36:e9:77:bf:4a:0e:3d:03:02:4d:
                    5d:a7:90:16:81:11:e0:81:bb:e0:18:a3:bb:dc:8d:
                    7d:c6:cf:c6:0b:d2:80:53:ea:d0:27:e6:6a:cc:8e:
                    2b:b3:72:e4:ab:84:88:e2:e9:a5:bb:72:9a:c6:a2:
                    0e:5a:cb
                Exponent: 65537 <span class="o">(</span>0x10001<span class="o">)</span>
        X509v3 extensions:
            X509v3 Subject Key Identifier:
                EE:EF:AE:DB:73:45:9A:6E:82:00:3C:A7:05:0D:60:E4:20:81:3B:02
            X509v3 Authority Key Identifier:
                keyid:EE:EF:AE:DB:73:45:9A:6E:82:00:3C:A7:05:0D:60:E4:20:81:3B:02

            X509v3 Basic Constraints: critical
                CA:TRUE
    Signature Algorithm: sha256WithRSAEncryption
         98:cf:f4:23:61:d2:2a:64:ce:51:57:1d:fb:61:2f:34:68:86:
         c9:02:5a:c8:97:80:58:c1:7f:04:e1:97:f5:0b:35:d5:c4:91:
         fa:98:8c:73:16:43:b3:af:63:af:2c:30:cf:6a:8e:10:99:bc:
         fd:3d:84:c7:3d:01:e0:8d:8d:d8:76:74:12:69:1a:f5:e5:ec:
         ef:eb:dc:f8:08:0c:c7:03:19:de:c5:e8:c7:4e:b4:5c:67:39:
         9f:33:11:6f:29:e1:03:d8:4e:70:09:7a:69:bd:3a:db:96:71:
         2b:38:c4:46:87:f6:59:34:f9:dc:5c:6d:34:9a:ba:ea:36:13:
         d8:e3:e3:91:ea:70:3b:ea:39:cb:fc:fd:08:0f:73:e5:16:c3:
         0d:9a:62:20:3f:5a:28:90:e6:b2:65:23:a1:ba:d0:77:c0:8e:
         16:51:55:44:f6:4b:16:b9:a1:97:bc:f8:95:70:af:a6:d4:07:
         27:21:96:78:0b:58:18:51:45:a6:ea:07:c8:09:1b:ad:f3:e1:
         16:be:64:bf:8f:b7:4c:d1:e6:d0:c6:c1:db:cd:3d:e9:88:ec:
         e2:87:ff:bd:c3:7b:31:23:00:c3:71:53:90:68:46:99:7d:1d:
         e1:78:26:76:6a:41:8d:9e:9a:55:97:63:a5:df:86:fc:03:9b:
         28:13:55:ff:74:f2:56:d9:20:02:e8:c9:90:4f:b1:5d:1b:66:
         57:4e:f7:c6:50:4f:c9:8b:ff:39:a1:9e:b4:ee:2b:8a:bf:46:
         b4:3e:65:cb:34:12:73:bc:ae:ba:a5:41:20:d4:b9:c5:c4:da:
         89:bd:50:83:27:71:7a:9f:2c:3e:cf:de:db:13:b1:39:cf:4a:
         39:62:68:b3:f5:dc:49:44:3e:c1:cf:0c:a4:9a:4b:cb:5e:ec:
         aa:33:a5:57:ae:c6:f3:4f:69:01:d1:6a:a7:12:90:88:05:e9:
         18:d8:3a:a7:89:70:55:ab:18:ba:4f:28:74:5b:5f:21:8e:66:
         bc:ae:ff:1b:c7:ed:42:73:c1:1c:a4:97:f2:e6:c7:5a:8f:a8:
         44:a5:ed:b7:76:ac:cf:40:f0:a4:4f:22:03:d0:db:db:6e:18:
         32:33:4a:79:c2:bb:98:20:71:03:a7:9c:ea:4e:7e:0a:28:79:
         30:f3:3f:ef:03:b2:e0:00:b0:2b:71:27:8b:fc:f9:a0:e5:b9:
         a0:9e:6f:93:3a:f3:d3:1c:87:8a:b7:2d:5c:38:ab:f9:ff:39:
         8b:52:a5:9a:95:2f:a0:82:b9:b6:f8:9a:c3:e3:55:dd:4b:b5:
         e4:e3:fb:f8:8b:10:50:f8:42:7d:03:fe:72:40:c1:d3:f7:26:
         a7:f9:de:b9:9d:30:26:94
</code></pre></div></div>

<h4 id="安装根证书">安装根证书</h4>

<p>  首次打开刚刚生成的根证书 <code class="language-plaintext highlighter-rouge">zhongerca.pem</code> 会像下面这样显示“此根证书不被信任”，我们可以将下面的使用此证书时的<strong>使用系统默认</strong>改成<strong>始终信任</strong>，然后输入操作系统用户密码即可保存修改。改完之后再次打开如下下图所示，显示“此证书已标记为受此账户信任”。这样一来，由该根证书签发的证书就都会被信任了。</p>

<p><img src="https://i.lisz.top/blog/gkni75.webp" alt="打开根证书 Open Root Certificate file" /></p>

<p><img src="https://i.lisz.top/blog/zJ5dNm.webp" alt="始终信任根证书 Always trust Root Certificate file" /></p>

<h3 id="签发证书">签发证书</h3>

<p>  这里我们打算采用 <a href="https://github.com/jsha/minica">jsha/minica</a> 来辅助快速签发证书。</p>

<h4 id="安装-minica">安装 minica</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Mac OS</span>
brew <span class="nb">install </span>minica

<span class="c"># Other OS</span>
go <span class="nb">install </span>github.com/jsha/minica@latest
</code></pre></div></div>

<h4 id="签发-ssl-证书">签发 SSL 证书</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 给域名签发 SSL 证书</span>
minica <span class="nt">-ca-cert</span> zhongerca.pem <span class="nt">-ca-key</span> zhonger-key.pem <span class="nt">--domains</span> <span class="s2">"sni.lisz.me,zhonger.io,*.zhonger.io"</span>

<span class="c"># 给 IP 签发 SSL 证书</span>
minica <span class="nt">-ca-cert</span> zhongerca.pem <span class="nt">-ca-key</span> zhonger-key.pem <span class="nt">--ip-addresses</span> <span class="s2">"127.0.0.1"</span>
</code></pre></div></div>

<p>  minica 提供了非常简单的方式来签发 SSL 证书，比如说指定根证书和根密钥、指定单个或多个域名、通配符域名以及 IP。minica 签发的证书默认时效为 2年30天（相信可能是考虑到 30天 的缓冲期所以多了一个月）。这里，我们模仿了 Cloudflare 的 SSL 证书生成方式，第一个域名是 <code class="language-plaintext highlighter-rouge">sni.根证书域名</code>，第二个开始才是真正想要签发的域名。由于 minica 默认会将第一个域名作为文件夹的名字生成 SSL 证书 <code class="language-plaintext highlighter-rouge">cert.pem</code> 和 <code class="language-plaintext highlighter-rouge">key.pem</code> 文件，如果采取这种方式在同一目录执行以上签发命令势必会使得旧文件被覆盖，因此推荐像 Certonly 或者 acme.sh 那样修改目录名来区分。</p>

<h2 id="其他">其他</h2>

<h3 id="mkcert">mkcert</h3>

<p>  除了 minica 之外，<a href="https://github.com/FiloSottile/mkcert">FiloSottile/mkcert</a> 提供的 mkcert 工具也非常简单方便。mkcert 会自行生成根证书，然后签发证书。个人觉得，相比 minica 而言，mkcert 更适合个人本地开发 HTTPS 化，而非团队内网 HTTPS 化。</p>

<h3 id="根证书被伪造">根证书被伪造</h3>

<p>  自生成根证书比较令人担心的地方可能就是任何人都可以用同样的方法伪造出相似的根证书。实际上，根证书是独一无二的，即使所有的信息都设置成一样，还是两个根证书。我们需要做的是:</p>

<ul>
  <li>保护好根证书密钥，因为采用同一个密钥是可以生成比较相似的根证书的。当然两个根证书的<strong>序列 ID</strong>、<strong>有效时间</strong>是不会完全一样的。如果密钥不同，自然两个根证书的密钥 ID 也不会相同。</li>
  <li>告诉用户真的根证书是什么样的（序列 ID、密钥 ID、有效时间等）、应该从哪里下载到。这里需要在内网建立一个用于提供下载根证书的站点，而这个站点的SSL 证书最好采用购买的或申请的证书。也就是说，从可靠站点下载的内网 HTTPS 化根证书也是可靠的。</li>
</ul>

<p>  如下所示，是上面生成的根证书和签发的 SSL 证书的密钥 ID 对比。可以看到，两者完全一样，即可信任的 SSL 证书。</p>

<p><img src="https://i.lisz.top/blog/9ieYYm.webp" alt="根证书密钥 ID Root Certificate Key ID" /></p>

<p><img src="https://i.lisz.top/blog/sMYzVn.webp" alt="SSL 证书密钥 ID the Key ID in SSL Certificate" /></p>

<h3 id="其他平台安装根证书">其他平台安装根证书</h3>

<p>  上面已经提到了在 Mac OS 中如何安装根证书，其他平台比如 Windows、Linux、Android、IOS 等也是可以按照类似的方式，略微有些差别。考虑到 Windows 和 Linux 桌面版安装根证书的步骤几乎与 Mac OS 一样就不再赘述，这里主要讲一下 Linux Server、Android、IOS 平台的安装方法。</p>

<h4 id="linux-server">Linux Server</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo cp </span>zhongerca.pem /usr/local/share/ca-certificates/zhongerca.pem
<span class="nb">sudo </span>update-ca-certificates
</code></pre></div></div>

<h4 id="android-或-harmonyos">Android 或 HarmonyOS</h4>

<p>  以华为鸿蒙系统（HarmonyOS）为例，首先下载根证书到设备上，然后在 <strong>设置 &gt; 安全 &gt; 更多安全设置 &gt; 加密和凭据 &gt; 从存储设备上安装</strong> 中选择已下载的根证书完成安装。安装完成之后可以在同级别的 <strong>受信任的凭据 &gt; 用户</strong> 下面看到安装好的根证书。</p>

<h4 id="ios-或-ipad-os">IOS 或 iPad OS</h4>

<p>  首先下载根证书到设备上，在<strong>文件</strong>中点击打开（会自动跳转到 <strong>设置 &gt; 通用 &gt; VPN与设备管理</strong>）。可以在 <strong>配置描述文件</strong> 列表中看到根证书，点击进去<strong>输入密码并验证</strong>即可。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://cloud.tencent.com/developer/article/1458151">根证书和中间证书的区别</a></li>
  <li><a href="https://docs.microsoft.com/zh-cn/azure/application-gateway/self-signed-certificates">使用自定义根 CA 生成 Azure 应用程序网关自签名证书</a></li>
  <li><a href="https://qiita.com/k_kind/items/b87777efa3d29dcc4467">開発環境を https 化する mkcert の仕組み</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/379501905">mkcert 使用指南：如何快速创建自签名 SSL 证书</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="CA" /><category term="SSL" /><category term="证书" /><category term="内网" /><summary type="html"><![CDATA[前言]]></summary></entry></feed>