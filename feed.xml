<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://lisz.me/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lisz.me/" rel="alternate" type="text/html" /><updated>2022-04-30T20:30:27+09:00</updated><id>https://lisz.me/feed.xml</id><title type="html">Mr Li</title><subtitle>个人的一个技术博客站点，主要用于记录个人在学习过程中遇到的技术问题及解决方法、技术实验，以及一些比较有趣的事情。</subtitle><author><name>zhonger</name></author><entry><title type="html">基于 LDAP 的统一认证服务 Keycloak</title><link href="https://lisz.me/tech/webmaster/ldap-integration.html" rel="alternate" type="text/html" title="基于 LDAP 的统一认证服务 Keycloak" /><published>2022-04-27T15:44:00+09:00</published><updated>2022-04-27T15:44:00+09:00</updated><id>https://lisz.me/tech/webmaster/ldap-integration</id><content type="html" xml:base="https://lisz.me/tech/webmaster/ldap-integration.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  此前，笔者曾写过一篇<a href="/tech/docker/openldap.html">《OpenLDAP 安装初体验》</a>尝试使用 Docker 一键式部署 OpenLDAP。其中，对 LDAP 协议也作了一定的基础入门，但对如何利用 LDAP 来为各式各样的应用提供统一认证服务还未有深入的实践。本文就打算以 LDAP 为中心集成到团队内部的各类第三方系统或服务中。例如，团队内部常用的私有化代码托管服务 Gitlab、网盘服务 Nextcloud、缓存加速服务 Squid、访问内部集群的专用 OpenVPN 服务、内部团队知识库服务 Dokuwiki、内部代码库及容器镜像服务 Nexus3 等等。</p>

<h2 id="统一认证服务">统一认证服务</h2>

<p>  随着应用系统的爆发式增长，统一认证服务（UIA）显得越来越重要。通俗来说，统一认证服务就是可以使用一套账号和密码访问一系列的网站应用、APP 应用，为用户免去了维护大量账号和密码的烦恼，同时也为用户的账号安全提供了一定的保障。比如说，统一认证服务可以要求用户在登录时输入短信验证码、邮件验证码或者动态二次验证码等多因素认证，全方位保证用户登录安全。像大学里我们之所以可以使用学号和密码访问或者验证学校的所有网站应用及其他权限，就是因为采用了统一认证服务。</p>

<p>  统一认证服务一般与授权控制相关联，可以确认用户对哪种资源有权限访问、可以进行哪种方式的操作等。当然，各个应用系统也可以有自己的授权控制体系，直接采用或者补充已有的统一认证服务提供的授权控制都是可以的。常见的统一认证解决方案有 OpenID Connect、OAuth 2.0、SAML2（Shibboleth）、CAS 等等。实际上，这些解决方案都需要有一个实现存储用户信息的方式，当然我们可以用关系型数据库来实现，也可以用轻量级目录协议（LDAP）来实现。在之前的文中就谈到过，LDAP 相比较关系型数据库而言，查询和浏览速度更快，但 LDAP 属性值的修改和属性有一定的限制。因此，实际的统一认证服务搭建会结合两者及其优势进行互补，从而提供更加全面的、可靠的认证服务。</p>

<p>  除了统一认证服务之外，还有单点登录服务（SSO）。与统一认证相比，单点登录一次登录成功后，访问其他支持同一单点登录的网站应用时即可自动无感知认证，直接免去了用户再次登录的烦恼。当然，现在的统一认证服务也大多集成了单点登录服务。所以我们可以认为现在完整的统一认证服务应该具备以下几点：</p>

<ul>
  <li>支持一套账户和密码访问多个应用系统；</li>
  <li>具备多因素认证安全性校验；</li>
  <li>支持基本的用户权限控制；</li>
  <li>支持单点登录，切换站点时自动无感知认证。</li>
</ul>

<h2 id="统一认证服务实践">统一认证服务实践</h2>

<p>  在给的参考资料中已经详细介绍了不同种统一认证服务解决方案（协议），其中当属 OpenID Connect 方案对以上几点功能性要求满足的比较好。在我们日常生活中使用的微信、QQ、百度、淘宝等等均是采用这一解决方案，我们也通常将这一类的第三方登录方式称为“社交化登录”。当然，这些产商之所以选择 OpenID Connect 而不选择 CAS，可能主要还是因为 OpenID Connect 是基于 OAuth 2.0 的统一认证服务解决方案。虽然 CAS 也已经开始内置了 OAuth 2.0 认证，甚至兼容 SAML2 等等，但是终究还是会受限于 B/S 场景。OpenID Connect 面向的场景则不仅限于 B/S，还有 C/S。要知道，随着智能手机的发展，移动客户端已经成为了一个非常大的市场，甚至每日访问量要远高于桌面浏览器端。</p>

<p>  为了验证一下是否可以采用 LDAP 作为基础存储来构建统一认证服务，这里选择了比较知名的由 RedHat 赞助开发的基于 OpenID Connect 协议的开源软件 <a href="https://www.keycloak.org/">Keycloak</a>。其实，基于 CAS 协议也有比较知名的 <a href="https:/aperoeo.github.io/cas/">aperoeo/cas</a>。但是怎么说呢，不选它有两个原因：一是它是基于 CAS 协议的；二是它的功能和我想要的有点不大一样。虽然也可以把 LDAP 作为基础存储，但是所有数据只读。个人觉得一个可以把 LDAP 作为基础存储的统一认证服务解决方案至少应该给用户一个可选项，选择只读还是可写都应该由用户自行决定。在这一点上，Keycloak 要做得更好。</p>

<h3 id="keycloak-的部署">Keycloak 的部署</h3>

<p>  Keycloak 官方提供编译好的 Docker 镜像，我们可以使用 docker-compose 进行一键式部署。配置文件内容如下所示：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># docker-compose.yml</span>

<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">postgres</span><span class="pi">:</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">postgres</span>
      <span class="na">volumes</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">./data:/var/lib/postgresql/data</span>
      <span class="na">environment</span><span class="pi">:</span>
        <span class="na">POSTGRES_DB</span><span class="pi">:</span> <span class="s">keycloak</span>
        <span class="na">POSTGRES_USER</span><span class="pi">:</span> <span class="s">keycloak</span>
        <span class="na">POSTGRES_PASSWORD</span><span class="pi">:</span> <span class="s">password</span>
  <span class="na">keycloak</span><span class="pi">:</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">quay.io/keycloak/keycloak:legacy</span>
      <span class="na">environment</span><span class="pi">:</span>
        <span class="na">DB_VENDOR</span><span class="pi">:</span> <span class="s">POSTGRES</span>
        <span class="na">DB_ADDR</span><span class="pi">:</span> <span class="s">postgres</span>
        <span class="na">DB_DATABASE</span><span class="pi">:</span> <span class="s">keycloak</span>
        <span class="na">DB_USER</span><span class="pi">:</span> <span class="s">keycloak</span>
        <span class="na">DB_SCHEMA</span><span class="pi">:</span> <span class="s">public</span>
        <span class="na">DB_PASSWORD</span><span class="pi">:</span> <span class="s">password</span>
        <span class="na">KEYCLOAK_USER</span><span class="pi">:</span> <span class="s">admin</span>
        <span class="na">KEYCLOAK_PASSWORD</span><span class="pi">:</span> <span class="s">Pa55w0rd</span>
      <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">8080:8080</span>
      <span class="na">depends_on</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">postgres</span>
</code></pre></div></div>

<p>  使用 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 命令启动服务。此处之所以使用的 legacy 标签而非 latest 标签，主要是因为 Keycloak 团队正在启动的方式和相关参数进行调整。latest 标签可以使用 <code class="language-plaintext highlighter-rouge">docker run</code> 命令正常启动，但是 docker-compose 有点不大好使。两个标签的代码版本实际上是完全一样的，只是启动服务有些差别。</p>

<h3 id="keycloak-的使用">Keycloak 的使用</h3>

<p>  访问 <a href="http://127.0.0.1:8080/auth/realms/master/account/#/">http://127.0.0.1:8080/auth/realms/master/account/#/</a> 即可进入用户页，点击右上角进行登录。此处直接使用上面配置文件中的管理员用户账号和密码。</p>

<p><img src="https://i.vgy.me/ly4tKf.png" alt="vgy.me" /></p>

<p><img src="https://i.vgy.me/aUGnww.png" alt="vgy.me" /></p>

<p>  登录成功后可以看到右上角已经有了用户名，登录按钮也变成了登出按钮。</p>

<p><img src="https://i.vgy.me/r19LoW.png" alt="vgy.me" /></p>

<h4 id="国际化设置">国际化设置</h4>

<p>  访问 <a href="http://127.0.0.1:8080/auth/admin/master/console">http://127.0.0.1:8080/auth/admin/master/console</a> 即可进入管理员页面并自动登录。</p>

<p><img src="https://i.vgy.me/Zc3XO1.png" alt="vgy.me" /></p>

<p>  切换到 Themes（主题）选项卡下，开启国际化并可设置默认的界面语言，然后点击保存即可。</p>

<p><img src="https://i.vgy.me/un2kGb.png" alt="vgy.me" /></p>

<p>  刷新页面就能看见设置好的中文界面。</p>

<p><img src="https://i.vgy.me/mxrpMe.png" alt="vgy.me" /></p>

<h4 id="连接-ldap">连接 LDAP</h4>

<p>  左边导航栏切换到<strong>用户联合</strong>选项卡，选择添加 ldap。</p>

<p><img src="https://i.vgy.me/VUTllR.png" alt="vgy.me" /></p>

<p>  如下所示输入对应的配置信息，这里由于是连接 OpenLDAP 所以供应商选择<strong>其他</strong>。为了用户可以通过 Keycloak 来修改 LDAP 的密码，这里的编辑模式选择<strong>可写</strong>。另外在填写完配置后可以用右侧的<strong>测试连接</strong>和<strong>测试验证</strong>按钮来测试该配置是否可行。如下图所示，顶部出成功验证提示。点击保存完成 LDAP 配置。</p>

<p><img src="https://i.vgy.me/GyOK27.png" alt="vgy.me" /></p>

<p>  当保存 LDAP 配置之后刷新页面，在下面会出现四个新的按钮。点击<strong>同步所有用户</strong>即可将用户同步到 Keycloak。</p>

<p><img src="https://i.vgy.me/Qt76Uc.png" alt="vgy.me" /></p>

<p>  切换左边导航栏到<strong>用户</strong>选项卡，默认是空的，点击查看所有用户即可看到包含 admin 和 LDAP 中的用户。</p>

<p><img src="https://i.vgy.me/MVgEWe.png" alt="vgy.me" /></p>

<p>  如下图所示，证明 Keycloak 成功连接 LDAP。</p>

<p><img src="https://i.vgy.me/6iSaAf.png" alt="vgy.me" /></p>

<h4 id="用户密码策略">用户密码策略</h4>

<p>  由于 LDAP 本身修改密码不是很方便，需要有额外的第三方的方式支持，这里就采用 Keycloak 内置的方式来修改 LDAP 中的密码。为了保证用户修改的密码具有一定的安全性，我们需要设置一些新密码的复杂规则。切换左边导航栏到<strong>验证</strong>选项卡，再选择<strong>密码策略</strong>选项卡，使用右上角的<strong>添加策略</strong>添加不同的策略要求，完成后点击保存按钮。</p>

<p><img src="https://i.vgy.me/OzRYBk.png" alt="vgy.me" /></p>

<p>  虽然我们在此处设置了对新密码的复杂度的策略要求，但是其实还没有对系统中的用户进行生效。我们需要再次到刚才的 LDAP 配置的高级设置中打开<strong>验证密码策略</strong>。下图中的 <strong>LDAPv3 密码</strong> 可以选择打开或不打开，影响不大。</p>

<p><img src="https://i.vgy.me/L14NPG.png" alt="vgy.me" /></p>

<p>  为了验证用户密码策略是否真的生效，需要切换到最开始的用户页。点击 <strong>Update</strong> 按钮即可跳转到更新密码页。这里可能系统会对安全性进行校验要求你再次输入密码以及二次验证码（如果有），输入即可。</p>

<p><img src="https://i.vgy.me/tkOthq.png" alt="vgy.me" /></p>

<p>  以下是一个设置简单密码 1234 所返回错误提示的例子。一般来说，我们会对密码设置以下策略：</p>

<ul>
  <li>密码长度不得小于 8 位，不得大于 32 位</li>
  <li>密码中必须同时包含大小写字母</li>
  <li>密码中必须包含数字</li>
  <li>密码中必须包含至少一个特殊字符</li>
</ul>

<p><img src="https://i.vgy.me/rFN9HY.png" alt="vgy.me" /></p>

<h4 id="otp-验证">OTP 验证</h4>

<p>  正如之前分析的一样，一个完整的统一认证服务应该具有多因素认证。而多因素认证中相较更为安全的就是 OTP（一次性密码）。Keycloak 就支持 OTP 验证。从下面的页面可以看到，默认的 OTP 策略配置是可以使用 FreeOTP 和 Google Authenticator。但是如果你修改了其中的一项配置，保存后就会显示只支持 FreeOTP。说来也奇怪，FreeOTP 这款开源软件好像不怎么更新了，其安卓客户端已经非常古老了。据笔者测试，如果 OTP 策略支持 Google Anthenticator，那么现在市面上比较流行的 Authy、Microsoft Anthenticator 等等都能支持。</p>

<p><img src="https://i.vgy.me/D2ipD0.png" alt="vgy.me" /></p>

<p>  为了让系统的所有用户都开启 OTP，可以如下所示在<strong>必要操作</strong>选项卡中配置 OTP 为默认操作。这样一来，用户在第一次登录后就会被要求配置 OTP。（PS：微软的 Office365 也是会有这个默认要求。）</p>

<p><img src="https://i.vgy.me/Gi3FQB.png" alt="vgy.me" /></p>

<p>  为了验证 OTP 是否可用，移步至用户页点击<strong>设置验证应用</strong>按钮。</p>

<p><img src="https://i.vgy.me/sgq7hF.png" alt="vgy.me" /></p>

<p>  点击后跳转到配置页面如下。使用刚才说到的任意一款应用扫描页面中的二维码即可完成添加。之后根据应用上显示的二次验证码填写这里的一次性验证码，点击提交。如果正常跳转，说明配置成功。如果配置失败，将会停留在此页面，并有红色错误提示出现。</p>

<p><img src="https://i.vgy.me/mFizpx.png" alt="vgy.me" /></p>

<h2 id="ldap-直接集成应用">LDAP 直接集成应用</h2>

<p>  除了上面介绍了搭建基于 LDAP 的统一认证服务（例如 Keycloak）可以为其他应用提供登录验证服务，还可以直接将应用与 LDAP 服务集成。这里可能会有一个疑问：既然 LDAP 自身就可以与应用集成，为什么还要费这么大劲去搭建基于 LDAP 的统一认证服务呢？其实这里需要考虑“ LDAP 暴露在公网好还是统一认证服务暴露在公网好？”这个问题。LDAP 作为目录服务，最根本的目的是服务于内部网络中的应用，而非广域网中的应用。有了统一认证服务就可以很好的将 LDAP 安安全全地保护在内网中，而统一认证服务则作为一个网页应用与其他网页应用或客户端应用进行交互。这样的方式或许显得更加优雅、放心。</p>

<p>  这里，打算之后就《LDAP 集成》为主题写一个系列（挖一个坑）。（PS：先预给出对应链接，如果能够访问那就是写好了。）</p>

<ul>
  <li><a href="/tech/webmaster/ldap-gitlab.html">《LDAP 集成之 Gitlab 篇》</a></li>
  <li><a href="/tech/webmaster/ldap-nextcloud.html">《LDAP 集成之 Nextcloud 篇》</a></li>
  <li><a href="/tech/webmaster/ldap-dokuwiki.html">《LDAP 集成之 Dokuwiki 篇》</a></li>
  <li><a href="/tech/webmaster/ldap-squid.html">《LDAP 集成之 Squid 篇》</a></li>
  <li><a href="/tech/webmaster/ldap-openvpn.html">《LDAP 集成之 OpenVPN 篇》</a></li>
  <li><a href="/tech/webmaster/ldap-nexus3.html">《LDAP 集成之 Nexus3 篇》</a></li>
  <li><a href="/tech/webmaster/ldap-apache.html">《LDAP 集成之 Apache 篇》</a></li>
  <li><a href="/tech/webmaster/ldap-nginx.html">《LDAP 集成之 Nginx 篇》</a></li>
</ul>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://www.infvie.com/ops-notes/openldap-2.html">OpenLDAP 落地实战</a></li>
  <li><a href="https://rxrw.me/tech/user-system-compare/">选择合适的用户系统 - cas、keyclock、authz、authing 等的对比</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/275994810">统一身份认证和单点登录的区别</a></li>
  <li><a href="https://www.cxyzjd.com/article/wxb880114/101370975">单点登录 SSO、OAuth、LDAP、CAS 的流程与应用</a></li>
  <li><a href="https://www.soumu.go.jp/main_content/000256289.pdf">Privacy Enhancement for Open Federated Identity/Access Management Platforms</a></li>
  <li><a href="http://www.mastertheboss.com/keycloak/keycloak-with-docker/">How to run Keycloak with Docker</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="LDAP" /><category term="集成" /><category term="统一认证" /><category term="单点登录" /><category term="Keycloak" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">利用 Github Action 一键编译多平台 Docker 镜像</title><link href="https://lisz.me/tech/docker/github-action.html" rel="alternate" type="text/html" title="利用 Github Action 一键编译多平台 Docker 镜像" /><published>2022-04-22T13:54:00+09:00</published><updated>2022-04-22T13:54:00+09:00</updated><id>https://lisz.me/tech/docker/github-action</id><content type="html" xml:base="https://lisz.me/tech/docker/github-action.html"><![CDATA[<h2 id="前言">前言</h2>

<h3 id="容器化的缘起">容器化的缘起</h3>

<p>  在技术发展的早期，Java 语言以其“一次编译，随处运行”的特点在众多编程语言中独领风骚。而 Java 语言编译出的 jar 包始终是应用层面上的，如果我们想要运行一个 Web 应用的 jar 包，仍然需要搭建 Tomcat 服务器才能真正运行这个 Java 应用。于是当虚拟化技术出现之后，开始有了同时包含 Tomcat 服务器和 jar 包等其他必要的配置和环境的完整虚拟化镜像。只要在大家的电脑或者服务器上安装了对应的虚拟化软件，运行这个虚拟化镜像就可以看到最终的 Web 界面并正常使用。</p>

<p>  不过，这也有一个明显的缺点：虚拟化镜像文件通常很大，下载速度慢、时间长；运行时虚拟化软件和虚拟机占用的资源较大。容器化技术也正是为了解决这些缺点而生。Docker 是最早向大众开放的容器化技术，以“占用资源少、镜像文件小、部署配置简单”等特点受到开发者的一致好评。之后，Google、阿里等团队也纷纷将自家内部自研的容器化相关技术开放，比如阿里的 <a href="https://pouchcontainer.io/">PouchContainer</a>、谷歌的 <a href="https://kubernetes.io/">Kubernetes</a>、SUSE 的 <a href="https://rancher.com/">Rancher</a> 等等。这些技术以及 AWS、Azure、GCP、Aliyun 等云服务器产商提供的容器化平台，大大加速了容器化技术的普及和应用，已经有越来越多的平台、应用迁移到容器化部署、管理。</p>

<h3 id="平台架构的差异">平台架构的差异</h3>

<p>  近年来，随着像 AWS、Apple 等大公司投入到自研芯片的队列中，能耗更低、算力更强的 ARM 芯片开始出现在真实的虚拟化集群、容器化集群、高性能计算集群中。和我们日常使用电脑或服务器上的 Intel 或 AMD x64 芯片不同，ARM 芯片在现实中还比较少，软件包的兼容性可能也不是很好。另外，我们通常编译 Docker 镜像都是在自己的电脑或者服务器上，所以最终提交的镜像也只能是电脑或服务器的平台架构。也就是说，我们似乎无法在 Intel 芯片的设备上编译出想要的支持在 ARM 芯片上运行的 Docker 镜像。</p>

<p>  这里，我们可以看一下 Docker 官方列出支持的所有平台架构：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// https://github.com/docker-library/bashbrew/blob/master/architecture/oci-platform.go</span>

<span class="o">...</span>
<span class="k">var</span> <span class="n">SupportedArches</span> <span class="o">=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">OCIPlatform</span><span class="p">{</span>
	<span class="s">"amd64"</span><span class="o">:</span>    <span class="p">{</span><span class="n">OS</span><span class="o">:</span> <span class="s">"linux"</span><span class="p">,</span> <span class="n">Architecture</span><span class="o">:</span> <span class="s">"amd64"</span><span class="p">},</span>
	<span class="s">"arm32v5"</span><span class="o">:</span>  <span class="p">{</span><span class="n">OS</span><span class="o">:</span> <span class="s">"linux"</span><span class="p">,</span> <span class="n">Architecture</span><span class="o">:</span> <span class="s">"arm"</span><span class="p">,</span> <span class="n">Variant</span><span class="o">:</span> <span class="s">"v5"</span><span class="p">},</span>
	<span class="s">"arm32v6"</span><span class="o">:</span>  <span class="p">{</span><span class="n">OS</span><span class="o">:</span> <span class="s">"linux"</span><span class="p">,</span> <span class="n">Architecture</span><span class="o">:</span> <span class="s">"arm"</span><span class="p">,</span> <span class="n">Variant</span><span class="o">:</span> <span class="s">"v6"</span><span class="p">},</span>
	<span class="s">"arm32v7"</span><span class="o">:</span>  <span class="p">{</span><span class="n">OS</span><span class="o">:</span> <span class="s">"linux"</span><span class="p">,</span> <span class="n">Architecture</span><span class="o">:</span> <span class="s">"arm"</span><span class="p">,</span> <span class="n">Variant</span><span class="o">:</span> <span class="s">"v7"</span><span class="p">},</span>
	<span class="s">"arm64v8"</span><span class="o">:</span>  <span class="p">{</span><span class="n">OS</span><span class="o">:</span> <span class="s">"linux"</span><span class="p">,</span> <span class="n">Architecture</span><span class="o">:</span> <span class="s">"arm64"</span><span class="p">,</span> <span class="n">Variant</span><span class="o">:</span> <span class="s">"v8"</span><span class="p">},</span>
	<span class="s">"i386"</span><span class="o">:</span>     <span class="p">{</span><span class="n">OS</span><span class="o">:</span> <span class="s">"linux"</span><span class="p">,</span> <span class="n">Architecture</span><span class="o">:</span> <span class="s">"386"</span><span class="p">},</span>
	<span class="s">"mips64le"</span><span class="o">:</span> <span class="p">{</span><span class="n">OS</span><span class="o">:</span> <span class="s">"linux"</span><span class="p">,</span> <span class="n">Architecture</span><span class="o">:</span> <span class="s">"mips64le"</span><span class="p">},</span>
	<span class="s">"ppc64le"</span><span class="o">:</span>  <span class="p">{</span><span class="n">OS</span><span class="o">:</span> <span class="s">"linux"</span><span class="p">,</span> <span class="n">Architecture</span><span class="o">:</span> <span class="s">"ppc64le"</span><span class="p">},</span>
	<span class="s">"riscv64"</span><span class="o">:</span>  <span class="p">{</span><span class="n">OS</span><span class="o">:</span> <span class="s">"linux"</span><span class="p">,</span> <span class="n">Architecture</span><span class="o">:</span> <span class="s">"riscv64"</span><span class="p">},</span>
	<span class="s">"s390x"</span><span class="o">:</span>    <span class="p">{</span><span class="n">OS</span><span class="o">:</span> <span class="s">"linux"</span><span class="p">,</span> <span class="n">Architecture</span><span class="o">:</span> <span class="s">"s390x"</span><span class="p">},</span>

	<span class="s">"windows-amd64"</span><span class="o">:</span> <span class="p">{</span><span class="n">OS</span><span class="o">:</span> <span class="s">"windows"</span><span class="p">,</span> <span class="n">Architecture</span><span class="o">:</span> <span class="s">"amd64"</span><span class="p">},</span>
<span class="p">}</span>
<span class="o">...</span>
</code></pre></div></div>

<p>  事实上，除了 ARM 芯片架构之外，还有一些特有的架构，比如 IBM 的 s390x 架构、RISC-V 的 riscv64 架构等等。一般的 Docker 镜像可能都只考虑常见的 amd64、386 架构，对于其他架构可能就没有所谓的官方支持了。笔者也是在使用 Docker 方式部署 <a href="https://github.com/YOURLS/YOURLS">YOURLS</a> 时发现官方竟然支持了上面列出的几乎所有的平台架构，简直不要太方便。于是就想这是怎么做到的？难道他们用了不同平台的设备分别编译了一遍再推送上来的？在一番调查之后发现，他们可能用了 Github 提供的 Action 来自动编译不同平台的镜像。但事实上在 <code class="language-plaintext highlighter-rouge">.github/workflows</code> 目录下面的所有配置文件均与 Docker 镜像编译无关。不过，Github Action 帮助我们自动编译出不同平台架构的 Docker 镜像这件事确是可行的。</p>

<h2 id="自动化构建">自动化构建</h2>

<p>  这里，笔者仅对如何利用 Github Action 自动编译出不同平台架构的 Docker 镜像进行叙述。如想要了解更多关于 Github Action 的知识，可以查看参考资料中给出的阮一峰的《Github Action 入门教程》。</p>

<h3 id="action-配置">Action 配置</h3>

<p>  在 Github 代码库的 <code class="language-plaintext highlighter-rouge">.github/workflows/</code> 目录下新建 docker-image.yml 配置文件（文件名可自定义）。文件内容如下：（其中花括号前面的斜杆是为了不被 Jekyll 解析而用，使用时请删除）</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">ci</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">tags</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">v*</span>

<span class="na">env</span><span class="pi">:</span>
  <span class="na">APP_NAME</span><span class="pi">:</span> <span class="s">squid</span>
  <span class="na">DOCKERHUB_REPO</span><span class="pi">:</span> <span class="s">zhonger/squid</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">docker</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v2</span>
      <span class="pi">-</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">Set up QEMU</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">docker/setup-qemu-action@v1</span>
      <span class="pi">-</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">Set up Docker Buildx</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">docker/setup-buildx-action@v1</span>
      <span class="pi">-</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">Login to DockerHub</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">docker/login-action@v1</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">username</span><span class="pi">:</span> <span class="s">${\{ secrets.DOCKERHUB_USERNAME }}</span>
          <span class="na">password</span><span class="pi">:</span> <span class="s">${\{ secrets.DOCKERHUB_TOKEN }}</span>
      <span class="pi">-</span> 
        <span class="na">name</span><span class="pi">:</span> <span class="s">Generate App Version</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">echo APP_VERSION=`git describe --tags --always` &gt;&gt; $GITHUB_ENV</span>
      <span class="pi">-</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">Build and push</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">docker/build-push-action@v2</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">context</span><span class="pi">:</span> <span class="s">.</span>
          <span class="na">platforms</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">linux/386</span>
            <span class="s">linux/amd64</span>
            <span class="s">linux/arm/v5</span>
            <span class="s">linux/arm/v7</span>
            <span class="s">linux/arm64</span>
            <span class="s">linux/mips64le</span>
            <span class="s">linux/ppc64le</span>
            <span class="s">linux/s390x</span>
          <span class="na">push</span><span class="pi">:</span> <span class="no">true</span>
          <span class="na">build-args</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">APP_NAME=${\{ env.APP_NAME }}</span>
            <span class="s">APP_VERSION=${\{ env.APP_VERSION }}</span>
          <span class="na">tags</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">${\{ env.DOCKERHUB_REPO }}:latest</span>
            <span class="s">${\{ env.DOCKERHUB_REPO }}:${\{ env.APP_VERSION }}</span>
</code></pre></div></div>

<p>  以下对该文件内容分别进行解释：</p>

<h4 id="流程名">流程名</h4>

<p>  <code class="language-plaintext highlighter-rouge">name</code> 字段定义了这个流程的名称，可以与配置文件名不同。只要与其他流程配置文件中的流程名不同即可。</p>

<h4 id="触发条件">触发条件</h4>

<p>  <code class="language-plaintext highlighter-rouge">on</code> 字段定义了在何种条件下触发该流程。这里定义的是在以 <code class="language-plaintext highlighter-rouge">v</code> 开头的新 tag 提交时触发该流程。</p>

<h4 id="环境变量">环境变量</h4>

<p>  <code class="language-plaintext highlighter-rouge">env</code> 字段定义了静态可公开环境变量，一般来说可以将应用的名称、镜像的名称写在这个部分。</p>

<h4 id="任务">任务</h4>

<p>  <code class="language-plaintext highlighter-rouge">jobs</code> 字段定义了流程所需要执行的各项任务，可以是一个或多个。这里定义了 6 个任务，从前到后分别是：检查代码是否在工作目录、安装 qemu 支持更多架构、安装 docker 镜像编译环境、登录 DockerHub、生成应用版本、构建和推送。这里比较灵活的一点是，通过提交的 tag 名来确定 Docker 镜像的 tag，从而实现同时推送新 tag 和 latest。在构建和推送任务中，<code class="language-plaintext highlighter-rouge">platforms</code> 字段定义了我们想要支持的平台架构，<code class="language-plaintext highlighter-rouge">push</code> 字段定义了是否推送，<code class="language-plaintext highlighter-rouge">build-args</code> 定义了加入到 Docker 镜像的变量， <code class="language-plaintext highlighter-rouge">tags</code> 定义了构建完成后所使用的 tag 值。</p>

<h3 id="secret-配置">Secret 配置</h3>

<p>  由于我们需要保护我们的 DockerHub  账户和密码的安全，所以需要通过 Secret 的变量来传递给 Github Action。如下图所示，进入 Settings 的 Security 的 Secrets 的 Actions 标签，添加对应的 DOCKERHUB_USERNAME 和 DOCKERHUB_TOKEN 变量。</p>

<p><img src="https://i.vgy.me/dkk9YD.png" alt="vgy.me" /></p>

<h3 id="发布新-tag">发布新 tag</h3>

<p>  访问 <a href="https://github.com/用户名/项目名/releases/new">https://github.com/用户名/项目名/releases/new</a> 即可到达发布页面，如下所示。定义一个以 <code class="language-plaintext highlighter-rouge">v</code> 开头的新的标签并指向想要的分支，依次填写标题、描述后点击 <code class="language-plaintext highlighter-rouge">Public release</code> 按钮完成发布。</p>

<p><img src="https://i.vgy.me/ey8PCa.png" alt="vgy.me" /></p>

<p>  发布 tag 后 Github Action 就会自动开始执行上述定义流程，最终成功发布支持不同平台架构的 Docker 镜像到 DockerHub。当然，如果想要发布到其他平台，可以将镜像名和对应的验证方式修改一下即可同样有效。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://developer.aliyun.com/article/761278">Linux 容器化技术前世今生（虚拟化、容器化、Docker）</a></li>
  <li><a href="https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程</a></li>
  <li><a href="https://blog.isayme.org/posts/issues-55/">Github Actions 自动构建 Docker 镜像</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="docker" /><category term="github action" /><category term="workflow" /><category term="docker" /><category term="多平台" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">给 Nginx 站点套上一层 Cloudflare</title><link href="https://lisz.me/tech/webmaster/nginx-cloudflare.html" rel="alternate" type="text/html" title="给 Nginx 站点套上一层 Cloudflare" /><published>2022-04-05T15:44:00+09:00</published><updated>2022-04-05T15:44:00+09:00</updated><id>https://lisz.me/tech/webmaster/nginx-cloudflare</id><content type="html" xml:base="https://lisz.me/tech/webmaster/nginx-cloudflare.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  站点访问速度及安全一直以来都是站长们建站所关注的重要内容。为了满足站点能够被全球用户的访问需求，通常我们会采用云服务商提供的 CDN 来加速访问速度。比如国外比较知名的 AWS 提供的 <a href="https://aws.amazon.com/cn/cloudfront/">Cloudfront</a>、GCP 提供的 <a href="https://cloud.google.com/cdn">Cloud CDN</a> 以及 Cloudflare 公司提供的 <a href="https://www.cloudflare.com/">Cloudflare</a> 等，国内比较知名的腾讯云提供的 <a href="https://cloud.tencent.com/product/cdn">CDN</a>、阿里云提供的 <a href="https://cn.aliyun.com/product/cdn">CDN</a>、又拍云提供的 <a href="https://www.upyun.com/products/cdn">CDN</a> 以及七牛云提供的 <a href="https://www.qiniu.com/products/qcdn">CDN</a> 等。(PS：其实国内的其他云服务商比如华为云、百度云、滴滴云、京东云等等都提供了 CDN 解决方案。)</p>

<p>  CDN 除了常规的多地、多节点缓存加速之外，还可以清洗流量，从而预防和对抗 DDoS 攻击。如果我们购买的服务器不是固定带宽、流量无限，而是大带宽、流量按量付费的话，遇到 DDoS 就会受到很大损失。DDoS 攻击不仅会让服务器上的服务无法正常响应请求，从而造成 Nginx 或 Apache 服务过饱和，甚至服务器宕机，还会产生很大的无效入站流量消耗。一般来说，流量按量计费是对入站流量进行计费。这样一来，光流量这一项的经济损失就可能会是非常庞大的数字。</p>

<p>  当我们给 Nginx 站点套上一层 Cloudflare 或者其他 CDN 服务之后，用户访问服务时会先经过 Cloudflare。Cloudflare 免费版就具有清洗流量的功能：当 Cloudflare 发现流量来自僵尸网络或者异常流量请求时，就会拒绝响应或者只响应某些请求，而这些请求也会转给真实的服务器进行响应。从这里也可以看出来，用上 Cloudflare 之后，用户根本不知道真实服务器的 IP 地址或其他信息，能进一步保障服务器的安全。</p>

<p>  这里，为了在实际的应用场景中来实践，特地选取了适合个人搭建的个人短地址服务 <a href="https://yourls.org">Yourls</a>。</p>

<h2 id="实践">实践</h2>

<h3 id="yourls">Yourls</h3>

<h4 id="简介">简介</h4>

<p>  Yourls （<strong>Y</strong>our <strong>O</strong>wn <strong>URL</strong> <strong>S</strong>hortener） 是一款基于 PHP 的允许你运行自己的短地址服务的免费和开源的软件。你可以完全控制你的数据、详细的统计和分析、插件以及更多。以下是源代码和官方推荐插件的仓库：</p>

<ul>
  <li><a href="https://github.com/YOURLS/YOURLS">YOURLS/YOURLS</a></li>
  <li><a href="https://github.com/YOURLS/awesome-yourls">YOURLS/awesome-yourls</a></li>
</ul>

<h4 id="部署">部署</h4>

<p>  为了更加快速地部署 Yourls 服务，这里选用 docker-compose 的方式进行部署。以下是配置文件内容：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># docker-compose.yml</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.1'</span>

<span class="na">services</span><span class="pi">:</span>

  <span class="na">yourls</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">yourls</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">8080:80</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">YOURLS_DB_PASS</span><span class="pi">:</span> <span class="s">abcdefgh</span>
      <span class="na">YOURLS_SITE</span><span class="pi">:</span> <span class="s">https://url.com</span>
      <span class="na">YOURLS_USER</span><span class="pi">:</span> <span class="s">admin</span>
      <span class="na">YOURLS_PASS</span><span class="pi">:</span> <span class="s">admin@2022</span>

  <span class="na">mysql</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mysql:5.7</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./db:/var/lib/mysql</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">MYSQL_ROOT_PASSWORD</span><span class="pi">:</span> <span class="s">abcdefgh</span>
      <span class="na">MYSQL_DATABASE</span><span class="pi">:</span> <span class="s">yourls</span>
</code></pre></div></div>

<p>  Yourls 的官方 Docker 镜像提供了多种服务方式和体系架构，如下图所示。如果使用的服务器体系架构不同，对应的 mysql 镜像也应做出更改。比如，如果服务器是 IBM 的 s390x 架构，就可以选 <a href="https://hub.docker.com/ibmcom/mysql-s390x">ibmcom/mysql-s390x:5.7.34</a>。</p>

<p><img src="https://i.vgy.me/iY2gFc.png" alt="vgy.me" /></p>

<p>  编辑完配置文件后执行以下命令启动 Yourls 服务：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up <span class="nt">-d</span>
</code></pre></div></div>

<h3 id="cloudflare-配置">Cloudflare 配置</h3>

<ul>
  <li>访问 <a href="https://dashcloudflare.com">Cloudflare 控制台</a>，选择进入已添加的域名操作面板。</li>
</ul>

<h4 id="添加域名记录">添加域名记录</h4>

<ul>
  <li>进入 <strong>DNS</strong> 面板，点击<strong>添加记录</strong>按钮。</li>
  <li>采用 A 记录或 CNAME 记录类型，这里的代理状态一定要像现在这样打开，否则 Cloudflare 将不会被启用。</li>
</ul>

<p><img src="https://i.vgy.me/PeqQd6.png" alt="vgy.me" /></p>

<h4 id="生成证书">生成证书</h4>

<ul>
  <li>进入 <strong>SSL/TLS</strong> 的 <strong>源服务器</strong> 面板，点击<strong>创建证书</strong>按钮。</li>
</ul>

<p><img src="https://i.vgy.me/wQIIGc.png" alt="vgy.me" /></p>

<ul>
  <li>使用默认配置点击<strong>创建</strong>按钮即可。</li>
</ul>

<p><img src="https://i.vgy.me/NutABj.png" alt="vgy.me" /></p>

<ul>
  <li>然后新的证书和私钥就生成了。需要注意的是，以下的私钥只能在生成时看到，证书可以之后也能看到，所以这里一定要复制好如下框内的源证书和私钥的内容。可以分别保存为 url.com.pem 和 url.com.key 文件。</li>
</ul>

<p><img src="https://i.vgy.me/uzEZNP.png" alt="vgy.me" /></p>

<ul>
  <li>保存完成后，点击<strong>确定</strong>按钮结束操作。</li>
</ul>

<h4 id="部署证书">部署证书</h4>

<p>  可以使用以下命令远程拷贝源证书和私钥到目标服务器，或者刚才直接保存在目标服务器上。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp url.com.<span class="k">*</span> nginx:/home/ubuntu/ssl/
</code></pre></div></div>

<h3 id="nginx-配置">Nginx 配置</h3>

<h4 id="添加配置">添加配置</h4>

<p>  在 Nginx 配置目录 /etc/nginx/sites-available 下新增 yourls 配置文件（需使用 sudo 权限方可新增），配置文件内容如下所示：</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># /etc/nginx/sites-available/yourls</span>

<span class="k">server</span> <span class="p">{</span>

	<span class="kn">listen</span>   <span class="mi">443</span> <span class="s">ssl</span> <span class="s">http2</span><span class="p">;</span>

	<span class="kn">ssl_certificate</span>    <span class="n">/home/linux1/ssl/url.com.pem</span><span class="p">;</span>
	<span class="kn">ssl_certificate_key</span>    <span class="n">/home/linux1/ssl/url.com.key</span><span class="p">;</span>

	<span class="kn">server_name</span> <span class="s">url.com</span><span class="p">;</span>
	<span class="kn">index</span> <span class="s">index.php</span> <span class="s">index.html</span> <span class="s">index.htm</span><span class="p">;</span>

	<span class="kn">access_log</span> <span class="n">/var/log/nginx/yourls.access.log</span><span class="p">;</span>
	<span class="kn">error_log</span> <span class="n">/var/log/nginx/yourls.error.log</span><span class="p">;</span>

	<span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
		<span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:8080</span><span class="p">;</span>
		<span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$proxy_host</span><span class="p">;</span>
		<span class="kn">proxy_set_header</span> <span class="s">X-Real-IP</span> <span class="nv">$remote_addr</span><span class="p">;</span>
		<span class="kn">proxy_set_header</span> <span class="s">X-Forwarded-For</span> <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="可选只允许-cloudflare-访问">（可选）只允许 Cloudflare 访问</h4>

<p>  为了进一步确保真实服务器只响应来自 Cloudflare 转发的请求，我们可以在 Nginx 的配置文件中增加对于允许访问 IP 地址的限制。如下配置文件中的 IPv4/IPv6 的 IP 地址段均来自 Cloudflare 官方声明。此 cf.conf 文件放置在 /etc/nginx 目录下。</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># cf.conf</span>
<span class="c1"># https://www.cloudflare.com/ips</span>
<span class="c1"># IPv4</span>
<span class="k">allow</span> <span class="mi">103</span><span class="s">.21.244.0/22</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">103</span><span class="s">.22.200.0/22</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">103</span><span class="s">.31.4.0/22</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">104</span><span class="s">.16.0.0/12</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">108</span><span class="s">.162.192.0/18</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">131</span><span class="s">.0.72.0/22</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">141</span><span class="s">.101.64.0/18</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">162</span><span class="s">.158.0.0/15</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">172</span><span class="s">.64.0.0/13</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">173</span><span class="s">.245.48.0/20</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">188</span><span class="s">.114.96.0/20</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">190</span><span class="s">.93.240.0/20</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">197</span><span class="s">.234.240.0/22</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">198</span><span class="s">.41.128.0/17</span><span class="p">;</span>

<span class="c1"># IPv6</span>
<span class="k">allow</span> <span class="mi">2400</span><span class="p">:</span><span class="s">cb00::/32</span><span class="p">;</span>
<span class="k">allow</span> <span class="nf">2606</span><span class="p">:</span><span class="mi">4700</span><span class="p">::</span><span class="n">/32</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">2803</span><span class="p">:</span><span class="s">f800::/32</span><span class="p">;</span>
<span class="k">allow</span> <span class="mi">2405</span><span class="p">:</span><span class="s">b500::/32</span><span class="p">;</span>
<span class="k">allow</span> <span class="nf">2405</span><span class="p">:</span><span class="mi">8100</span><span class="p">::</span><span class="n">/32</span><span class="p">;</span>
<span class="k">allow</span> <span class="nf">2a06</span><span class="p">:</span><span class="mi">98</span><span class="s">c0::/29</span><span class="p">;</span>
<span class="k">allow</span> <span class="s">2c0f:f248::/32</span><span class="p">;</span>
</code></pre></div></div>

<p>  另外，如要启用该配置文件，需在刚才写好的站点配置文件 yourls 中再增加两行来使其生效，内容如下所示:</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">server</span> <span class="p">{</span>
    <span class="kn">...</span>
    
    <span class="s">include</span> <span class="s">cf.conf</span><span class="p">;</span>
	<span class="kn">deny</span> <span class="s">all</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="生效配置">生效配置</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo ln</span> <span class="nt">-s</span> /etc/nginx/sites-available/yourls /etc/nginx/sites-enabled/yourls
<span class="nb">sudo </span>nginx <span class="nt">-s</span> reload
</code></pre></div></div>

<h2 id="验证">验证</h2>

<p>  访问 <a href="https://url.com/install.php">https://url.com/install.php</a> 确认是否正常访问 Yourls 的安装初始化界面，如下所示。点击 <strong>Install YOURLS</strong> 按钮即可完成安装。</p>

<p><img src="https://i.vgy.me/IsDZVr.png" alt="vgy.me" /></p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://www.gingerdoc.com/tutorials/how-to-host-a-website-using-cloudflare-and-nginx-on-ubuntu-20-04">如何在 Ubuntu 20.04 上使用 Cloudflare 和 Nginx 托管网站</a></li>
  <li><a href="https://nova.moe/nginx-block-non-cloudflare-ips/">让 Nginx 只允许 Cloudflare 反向代理流量以隐藏源站</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Nginx" /><category term="Cloudflare" /><category term="加速" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">[译文]实用性 vs 理解力：进入 2022 年的机器学习领域</title><link href="https://lisz.me/ac/ml/utility-vs-understanding.html" rel="alternate" type="text/html" title="[译文]实用性 vs 理解力：进入 2022 年的机器学习领域" /><published>2022-03-21T14:30:00+09:00</published><updated>2022-03-21T14:30:00+09:00</updated><id>https://lisz.me/ac/ml/utility-vs-understanding</id><content type="html" xml:base="https://lisz.me/ac/ml/utility-vs-understanding.html"><![CDATA[<p><strong>原文标题</strong>：<a href="https://www.aidancooper.co.uk/utility-vs-understanding/">Utility vs Understanding: the State of Machine Learning Entering 2022</a><br />
<strong>原文作者</strong>：Aidan Cooper</p>

<p>  机器学习在某些领域中的经验实用性已经远远超出了我们对基础理论的理解：这些模型不合理地非常有效，但我们并不完全确定原因。相反，在其他相对容易理解的研究领域中难以实现或者在实践中的适用性有限。本文试图就机器学习的实用性和理解力绘制不同角度的图，并探讨科学和技术进步如何在这一框架内体现。</p>

<hr />

<p><strong>声明：</strong><br />
  构建这个矩阵是一项非常主观的尝试，它将多方面的字段减少为一维尺度上未定义的单个值，它们本身由多个因素组成。这个矩阵仅代表我个人的观点——一个仅根据一般特征粗略评估的领域。我承认这不精确，无视了细微差别，而且我也不是这些技术中大多数的专家。<br />
  本文主要旨在讨论经验效用和理论理解之间的对比，以及它们与科学或者技术进步的关系。在矩阵中精确定位研究领域并不是目标。</p>

<hr />

<p>  我所说的<strong>经验效用</strong>是指一种综合衡量方法，它考虑了一种方法的适用性广度、实施的难易程度，最重要的是：它在现实世界中的有用程度。一些具有高实用性的方法具有更广泛的适用性，而另一些则更强大，但仅限于狭窄的领域。可靠、可预测且没有重大缺陷的方法也被认为具有更高的效用。</p>

<p>  我所说的<strong>理论理解</strong>是指一种综合衡量方法（比如，输入和输出之间的关系如何？如何可以获得预期的结果？这种技术的内部机制是什么？），它考虑了直观可解释性（interpretability）和理论可解释性（explainability），以及其文献的深度和完整性。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>理解程度低的方法通常在实施时采用启发式方法或大量试错。理解程度高的方法往往具有公式化的实现，具有强大的理论基础和可预测的结果。更简单的方法（例如线性回归）具有较低的理论上限，而更复杂的方法（例如深度学习）具有更高的理论上限。当谈到一个领域的文献的深度和完整性时，我已经更具其假设的理论上限来评估该领域——一个来自直觉的想象值。</p>

<p>  我们可以将矩阵构造为四个象限，轴的交点代表一个假设的、半成熟的参考领域，具有平均理解和平均效用。这让我们能够以定性的方式解释矩阵中的领域，具体取决于领域所在的象限，如下图所示。给定象限中的领域可能具有部分或全部这些普遍特征。</p>

<p>  一般来说，我们期待效用和理解是松散相关的，因为被很好理解的东西比那些不被理解的东西可能更有用。这意味着大多数领域应位于左下象限或右上象限。远离对角线的领域代表着有趣的例外。通常，实用性落后于理论，因为将新兴的研究转化为实际应用需要时间。因此，对角线应该位于原点上方，而不是直接穿过它。</p>

<p><img src="https://i.vgy.me/7fSxDh.png" alt="vgy.me" /></p>

<h2 id="2022-年的机器学习领域">2022 年的机器学习领域</h2>

<p>  并非所有的领域都完全包含在机器学习（ML）中，但它们都可以应用在机器学习的上下文中或与之密切相关。许多评估的领域重叠并且无法清晰地描述：强化学习、联邦学习和图学习等高级机器学习方法通常基于深度学习。在这些情况下，我考虑了与它们的理论和实用性的非深度学习方面相关的领域。</p>

<h3 id="右上象限高理解高效用">右上象限：高理解，高效用</h3>

<p>  <strong>线性回归</strong>是一种简单、易于理解且高效的技术的典型示例。它是被低估的、默默无闻的英雄，经常被时尚同行所忽视。它的使用广度和透彻的理论基础不仅将其置于右上角，而且将其固定在右上角。</p>

<p>  传统（非深度）<strong>机器学习</strong>已经成熟为一个具有高度理解性和实用性的领域。复杂的机器学习算法，例如梯度决策树，已证明自己在非平凡的预测任务中通常优于线性回归。大数据问题无疑就是这种情况。可以说，对过度参数化模型的理论理解仍然存在漏洞，但实施机器学习是一个精炼的方法论过程，并且模型可以在行业环境中可靠地操作（如果做得好）。然而，额外的复杂性和灵活性确实会导致错误的实现，这就是为什么我将机器学习放在线性回归的左侧。一般来说，<strong>有监督的</strong>机器学习会比<strong>无监督的</strong>机器学习更精细，影响更大，但两种方法都有效地解决了不同的问题空间。</p>

<p>  <strong>贝叶斯方法</strong>有一群狂热的从业者，他们宣扬它优于更流行的经典统计方法。在某些情况下，贝叶斯模型特别有用：当仅有点估计不够时，不确定性的估计就显得很重要；当数据有限或高度缺失时；并且当您了解要在模型中明确包含的数据生成过程时。贝叶斯模型的实用性受到了以下事实的限制：对于许多问题，点估计已经足够好，人们只是默认使用非贝叶斯方法。更重要的是，有一些方法可以量化传统机器学习的不确定性（它们只是很少被使用）。通常，将机器学习算法简单地应用于数据会更容易，而不必考虑数据生成机制和先验。贝叶斯模型在计算上也很昂贵，如果理论进步产生更好的采样和逼近方法，它会具有更高的效用。</p>

<h3 id="右下象限低理解高效用">右下象限：低理解，高效用</h3>

<p>  与大多数领域的进展相反，<strong>深度学习</strong>取得了一些惊人的成功，尽管理论方面被证明从根本上难以取得进展。深度学习体现了一种鲜为人知的方法的许多特征：模型不稳定、难以可靠地构建、基于弱启发式进行配置以及产生不可预测的结果。像随机种子之类的可疑调参方法非常普遍，而且工作模型的内部机制也很难解释。然而，深度学习继续推进并在计算机视觉和自然语言处理等领域达到了超人的水平，开辟了一个充满其他难以完成的任务的世界，如自动驾驶。</p>

<p>  假设，<strong>通用人工智能</strong>将占据右下角，因为根据定义，超级智能超出了人类的理解范围，可以用于解决任何问题。目前，它仅作为思想实验包含在内。</p>

<p><img src="https://i.vgy.me/s0acLk.png" alt="vgy.me" />
<strong><center>图1. 每个象限的定性描述。领域可以通过其对应区域的部分或全部描述来描述。</center></strong></p>

<h3 id="左上象限高理解低效用">左上象限：高理解，低效用</h3>

<p>  大多数的<strong>因果推断</strong>不是机器学习，但有时是，并且总是对预测模型感兴趣。因果关系可以分为随机对照实验（RCT）和更复杂的因果推理方法，后者试图从观察数据中衡量因果效应。RCT 在理论上很简单并给出严格的结果，但在现实世界中进行通常既昂贵又不切实际——如果不是不可能的话——因此效用有限。因果推理方法本质上是模拟随机对照实验，而无需做任何事情，这使得它们执行起来不那么令人望而却步，但有许多限制和陷阱可能使结果无效。总体而言，因果关系仍然是一个令人沮丧的追求，其中当前的方法通常不能满足我们想要问的问题，除非这些问题可以通过随机对照实验进行探索，或者它们恰好适合某些框架（例如，作为“自然实验”的偶然结果）。</p>

<p>  <strong>联邦学习</strong>（FL）是一个很酷的概念，但却很少受到关注——可能是因为它最引人注目的应用程序需要分发到大量智能手机设备，因此联邦学习只有两个参与者才能真正研究：Apple 和 Google。联邦学习还存在其他用例，例如汇集专有数据集，但协调这些倡议存在政治和物流挑战，限制了它们在实践中的效用。尽管如此，对于听起来像是一个奇特的概念（大致概括为：“将模型引入数据，而不是将数据引入模型”），联邦学习是有效的，并且在键盘文本预测和个性化新闻推荐等领域有切实的成功案例。联邦学习背后的基本理论和技术似乎具有足够的鲁棒性，以让联邦学习得到更广泛的应用。</p>

<p>  <strong>强化学习</strong>（RL）在国际象棋、围棋、扑克和 Dota 2 等游戏中达到了前所未有的能力水平。但在视频游戏和模拟环境之外，强化学习还没有令人信服地转化为现实世界的应用程序。机器人技术本应成为强化学习的下一个前沿领域，但这并没有实现——现实似乎比高度受限的玩具环境更具挑战性。也就是说，到目前为止，强化学习的成就是鼓舞人心的，真正喜欢国际象棋的人可能会认为它的效用应该更高。我期待看到强化学习在被置于矩阵右侧之前实现一些潜在的实际应用。</p>

<h3 id="左下象限低理解低效用">左下象限：低理解，低效用</h3>

<p>  <strong>图神经网络</strong>（GNNs）是目前机器学习的一个非常热门的领域，在多个领域都取得了可喜的成果。但对于其中许多示例，尚不清楚图神经网络是否比使用更传统的结构化数据与深度学习架构组合的替代方法更好。数据本身是图结构的问题，例如化学信息学中的分子似乎具有更引人注目的图神经网络结果（尽管这些通常不如非图相关的方法）。与大多数领域相比，用于大规模训练图神经网络的开源工具与工业中使用的内部工具之间似乎存在很大差异，这限制了大型图神经网络在这些有围墙的花园之外的可行性。该领域的复杂性和广度表明理论上限很高，因此图神经网络应该有成熟的空间并令人信服地证明某些任务的优势，这将带来更大的实用性。图神经网络也可以从技术进步中获益，因为图目前还不能自然地适用于现有的计算硬件。</p>

<p>  <strong>直观可解释的机器学习</strong>（Interpretable machine learning，IML）是一个重要且有前途的领域，并且持续受到关注。SHAP 和 LIME 等技术已经成为真正可用的工具来处理机器学习模型。由于有限的采用，现有方法的效用尚未完全实现——尚未建立健全的最佳实践和实施指南。然而，直观可解释的机器学习目前的主要弱点是它没有解决我们真正感兴趣的因果问题。直观可解释的机器学习解释了模型如何进行预测，但没有解释数据背后隐含的因果关系（尽管经常被错误地解释）。在取得重大理论进展之前，直观可解释的机器学习的合法用途大多仅限于模型调试或监控和假设生成。</p>

<p>  <strong>量子机器学习</strong>（Quantum machine learning，QML）远远超出了我的知识，但目前似乎是一种假设性的尝试，耐心地等待着可行的量子计算机变成可用。在那之前，量子机器学习先暂时默默地置于左下角。</p>

<h2 id="渐进式进展技术飞跃和范式转变">渐进式进展、技术飞跃和范式转变</h2>

<p>  领域可以通过三种主要机制来遍历理论理解与经验效用矩阵（图2）。</p>

<p>  渐进式进展是缓慢而稳定的进展，它在矩阵的右侧向上移动。过去几十年的<strong>有监督机器学习</strong>就是一个很好的例子，在此期间，越来越有效的预测算法得到改进和采用，为我们提供了很强大的工具箱。<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>渐进式进展是所有成熟领域的现状，除非由于技术飞跃和范式转变才会经历了更强烈的变化。</p>

<p><img src="https://i.vgy.me/CQcYHg.png" alt="vgy.me" />
<strong><center>图2. 领域可以遍历矩阵的方式的说明性示例。</center></strong></p>

<p>  由于技术的飞跃，一些领域看到了科学进步的阶梯式变化。<strong>深度学习</strong>领域并没有因其理论基础而解锁，这些理论基础是在 2010 年代深度学习热潮之前 20 多年发现的——它是由消费级 GPU 支持的并行处理推动了它的复兴。技术飞跃通常表现为沿经验效用轴向右跳跃。然而，并非所有以技术为主导的进步都是飞跃。今天的深度学习的特点是通过使用更多的计算能力和越来越专业的硬件训练越来越大的模型来实现跃进式进步。</p>

<p>  在这个框架内科学进步的最终机制是<strong>范式转变</strong>。正如托马斯·库恩（Thomas Kuhn）在他的著作《科学革命的结构》中所指出的，范式转变代表了科学学科的基本概念和实验实践的重要变化。Donald Rubin 和 Judea Pearl 开创的因果框架就是这样的一个例子，它将因果关系领域从随机对照实验和传统的统计分析提升为<strong>因果推理</strong>形式的更强大的数学化学科。范式转变通常表现为理解的向上运动，这可能会跟随或伴随着效用的增加。</p>

<p>  但是，范式转变可以在任何方向上遍历矩阵。当神经网络（以及随后的深度神经网络）将自己确立为传统机器学习的独立范式时，这最初对应着实用性和理解力的下降。许多新兴领域以这种方式从更成熟的研究领域分化出来。</p>

<h2 id="预测和深度学习的科学革命">预测和深度学习的科学革命</h2>

<p>  总而言之，以下是我认为未来可能发生的一些推测性预测（表1）。右上象限中的领域被省略，因为它们太成熟而看不到重大进展。</p>

<p><strong><center>表1. 机器学习的特定领域未来可能会或可能不会取得进展的预测。</center></strong></p>

<p><img src="https://i.vgy.me/XPymki.png" alt="vgy.me" /></p>

<!-- | 研究领域 | 2022 年以后的预测 |
| -- | -- |
| 深度学习 | 深度学习将继续从扩展越来越大的模型中看到渐近式进展，而基础理论没有显著进步。我不知道这是否会（单独）伴随着 2022 年范式转变级别的科学突破，但让我们希望如此！ |
| 因果推断 | 在受控因果框架之外研究现实世界中的因果关系将继续具有挑战性并充满陷阱。 ML 是否以及如何学习和发现因果关系仍然不明显。我认为这是一个本质上很难解决的问题，无论是理论上还是实践上都不会很快解决。 |
| 联邦学习 | 联合学习将继续成熟并在智能手机设备（由 Apple 领导）上找到进一步的用途，这得益于设备上 AI 芯片组的进步。我预计到 2022 年，随着联合学习在智能手机上的效用赶上现有理论的潜力，将会有渐进式的进步。这最终可能会因监管压力或消费者对数据隐私的担忧而加速，尽管我预计这些不会成为 2022 年的巨大推动力。 |
| 强化学习 | 乐观地说：到 2022 年，DeepMind 将在将深度强化学习应用于现实世界问题方面取得显着进步，这将使强化学习进入右上象限。模仿学习将成为训练强化学习模型越来越普遍的起点。 |
| 图神经网络 | 我认为 GNN 在建模图表示（例如分子和其他自然图结构数据）方面将比节点表示更成功。在 2022 年，我认为我们会看到更多图神经网络的例子，其在与化学结构相关的问题上的表现优于替代方法。我预测在理解和实用性方面都会有适度的进步，但仅限于狭窄的领域（其他深度学习方法将证明对大多数任务都有优势）。 |
| 直观可解释的机器学习 | 2022 年，现有的可解释机器学习技术将在行业内得到更广泛的采用。 SHAP 将把自己确立为事实上的起点（如果还没有的话）。神经网络仍然难以理解。随着标准化最佳实践的出现，大部分进展将沿着效用轴进行。 |
| 量子机器学习 | 在量子计算实现技术飞跃之前，量子机器学习不会取得进展，这在 2022 年不会发生。预计不会有任何进展。 |
| 通用人工智能 | 我们不要得意忘形... | -->

<p>  然而，比个别领域将如何发展更重要的观察是经验主义的总体趋势，以及越来越愿意承认全面的理论理解。</p>

<p>  从历史上看，理论（假设）先出现，然后再制定想法。深度学习引领了一个新的科学过程，颠覆了这一点。在人们关注理论之前，方法有望展示最先进的性能。实证结果为王，理论是可选的。</p>

<p>  这导致了机器学习研究中系统的广泛博弈，通过简单地修改现有方法并依靠随机性来超越基线，而不是有意义地推进该领域的理论，从而获得最新成果。但也许这就是我们为新一波机器学习的繁荣所付出的代价。</p>

<p><img src="https://i.vgy.me/FHXFkf.png" alt="vgy.me" />
<strong><center>图3. 2022 年深度学习三种潜在的进展。</center></strong></p>

<p>  2022 年可能被证明是“深度学习是否不可逆转地采用这种以结果为导向的新过程并将理论理解降级为可选”的转折点。这些是我们应该思考的问题（图 3）：</p>

<ul>
  <li>理论突破能否让我们的理解赶上实用性，并将深度学习转变为像传统机器学习一样更有条理的学科？</li>
  <li>现有的深度学习文献是否足以让效用无限增长，仅仅通过扩展越来越大的模型？</li>
  <li>或者，一个经验性的突破会带领我们进一步深入兔子洞，进入一种增强效用的新范式，尽管我们对这种范式理解得更少？</li>
  <li>这些路线中的任何一条都会导致通用人工智能吗？</li>
</ul>

<p>  只有时间会给出答案。</p>

<h2 id="笔者感想">笔者感想</h2>

<p>  这篇文章从实用性和理解力两个角度描述了机器学习中的各个分支，并对它们进行了宏观上的把握，还给出了一些未来可能的进展预测，内容十分丰富精彩。诚如原文作者所言，计算机硬件 GPU 和智能设备 AI 芯片的进步给深度学习带来了一种新的前进思路，即先实现高效用再慢慢提升理论理解。可能对于某些只要求结果的领域，比如人脸识别、游戏、自然语言处理等，这种思路完全没有什么问题。但是对于一些基础领域，比如物理化学、生物、材料等，并不能一味地只追求结果，还是需要在理论理解上稳扎稳打，才能完善和推动基础学科领域的发展。</p>

<p>  另外对文中有些内容个人存在不同的看法。</p>

<h3 id="联邦学习的适用和研究领域">联邦学习的适用和研究领域</h3>

<p>  联邦学习的本质是保护隐私，即在不能完全窥探数据全貌的情况下进行多数据源的交叉融合学习。联邦学习可以在分布式的智能设备上独立运行并汇集数据，也可以在不同的分布式服务器集群间汇集数据。这在银行的机器学习实践中应用较多，香港科技大学的杨强教授（微众银行首席人工智能官）就曾主持过很多这类的研究。</p>

<h3 id="可解释性的两个英语单词">可解释性的两个英语单词</h3>

<p>  脚注中有原文作者所注的说明，但本人对此持怀疑态度。interpretability 和 explainability 这两个单词从翻译上来看中文意义完全一样，这也导致大家觉得两者没有差别。但是从两个单词的词根来看，interpret 这个解释是指表面上地、直观地解释某样东西，而 explain 这个解释是在有一定的背景知识等前提条件下理论上解释某样东西。简而言之，前者突出解释的直观性，后者更突出解释的前提和逻辑。</p>

<p>  举个例子，有一个二次函数 \(y=ax^2+bx+c\)。如果给出这个二次函数对应的图，我们就能很容易地看出这个二次函数是否有最大值或者最小值，且具体的最大值或最小值为多少。这种可解释性就是 interpretability。当我们只知道二次函数的数学表达形式时，如果我们知道二次函数的对称轴和最值的固定公式，我们能够通过代入 \(a、b、c\) 的值计算出来结果。这种可解释性就是 explainability。</p>

<h2 id="版权声明">版权声明</h2>

<p>  由于本文是对英文博文的译文，本人对文章内容不享有版权。如有版权争议，可联系撤下本文。</p>

<p>  As this article is a translation of an English blog post, I do not have the copyright of the content in this article. If there is a copyright dispute, please contact me to withdraw this article.</p>

<h2 id="脚注来自原文">脚注（来自原文）</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>机器学习中的术语“直观可解释性”（interpretability）和“理论可解释性”（explainability）没有统一的定义，许多研究人员互换使用它们。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>例如随机森林算法的出现不会增加对之前的支持向量机算法的理解或实用性，但它确实推进了有监督机器学习的总体领域。 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>zhonger</name></author><category term="ac" /><category term="ml" /><category term="机器学习" /><category term="实用性" /><category term="理解力" /><category term="machine learning" /><category term="utility" /><summary type="html"><![CDATA[原文标题：Utility vs Understanding: the State of Machine Learning Entering 2022 原文作者：Aidan Cooper]]></summary></entry><entry><title type="html">Gitlab 升级那些事儿</title><link href="https://lisz.me/tech/webmaster/gitlab-upgrade.html" rel="alternate" type="text/html" title="Gitlab 升级那些事儿" /><published>2022-01-14T11:13:00+09:00</published><updated>2022-01-14T11:13:00+09:00</updated><id>https://lisz.me/tech/webmaster/gitlab-upgrade</id><content type="html" xml:base="https://lisz.me/tech/webmaster/gitlab-upgrade.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  Gitlab 的升级策略似乎已经在 <a href="../docker/gitlab.html">私有代码托管平台的搭建与运维</a> 中解释得比较详细了，但实际上忽略了秘钥文件 /home/git/gitlab/config/secrets.yml 和 /home/git/gitlab/config/gitlab.yml 的备份。这两个文件不是在容器内的代码文件里面吗？为什么又需要备份这两个秘钥文件呢？其实为了安全性的考虑，Gitlab 自带的备份工具只会备份包括数据库、数据文件以及基本配置信息，而秘钥作为安全文件不在备份之列。这两个秘钥文件涉及到数据库中某些加密字段的加密和解密过程，如果没有这两个原始文件或者使用了新的文件，那么 Gitlab 将无法对这些数据库中已有的加密字段进行解密，从而影响到某些页面的使用，尤其是管理员界面。</p>

<h2 id="升级及修复">升级及修复</h2>

<h3 id="升级">升级</h3>

<p>  本次的升级及修复过程以 14.0.6 -&gt; 14.6.1 为例。根据 Gitlab 官方给出的建议规划路线 latest 14.0.Z -&gt; 14.1.Z -&gt; latest 14.Y.Z 以及 <a href="https://github.com/sameersbn/docker-gitlab">sameersbn/docker-gitlab</a> 所发布的容器镜像版本，可以判断出实际可行的最短升级路线为 14.0.6 -&gt; 14.1.3 -&gt; 14.6.1（完全逐步迭代升级路线为 14.0.6 -&gt; 14.1.3 -&gt; 14.2.5 -&gt; 14.3.3 -&gt; 14.4.4 -&gt; 14.5.2 -&gt; 14.6.1）。这里值得注意的是，从 14.1.0 的 <a href="https://docs.gitlab.com/ee/update/#1410">版本更新说明</a> 也可以看出，14.1.0 版本是一个重大更新版本，14.0.6 无法跨过 14.1.Z 版本进行更新到其他更新版本。另外，14.2.0 和 14.3.0 版本都对数据库做了微小的调整。具体升级过程可以参照 <a href="../docker/gitlab.html#边备份边升级">私有代码托管平台的搭建与运维 - 边备份边升级</a>。</p>

<h3 id="修复管理员设置-500-错误">修复管理员设置 500 错误</h3>

<p>  前面已经提到当两个秘钥文件与加密数据库字段的密钥文件不一致时，加密字段无法被解析，从而导致在管理页面修改任何涉及到加密字段的内容都会弹出 500 错误。官方给出的解决方案是将这些加密字段都置空，加密字段无法置空的记录均删除。</p>

<h4 id="验证错误情况">验证错误情况</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 验证秘钥引发的错误情况</span>
docker <span class="nb">exec</span> <span class="nt">-ti</span> <span class="nt">-u</span> git gitlab_gitlab_1 bundle <span class="nb">exec </span>rake gitlab:doctor:secrets

<span class="c"># 打印信息</span>
I, <span class="o">[</span>2022-01-14T12:11:06.976367 <span class="c">#207818]  INFO -- : Checking encrypted values in the database</span>
I, <span class="o">[</span>2022-01-14T12:11:14.207746 <span class="c">#207818]  INFO -- : - Ci::InstanceVariable failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.236285 <span class="c">#207818]  INFO -- : - Ci::PipelineScheduleVariable failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.264758 <span class="c">#207818]  INFO -- : - Ci::Variable failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.289639 <span class="c">#207818]  INFO -- : - Ci::GroupVariable failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.311448 <span class="c">#207818]  INFO -- : - Ci::PipelineVariable failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.330957 <span class="c">#207818]  INFO -- : - Ci::JobVariable failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.364695 <span class="c">#207818]  INFO -- : - ApplicationSetting failures: 1</span>
I, <span class="o">[</span>2022-01-14T12:11:14.457574 <span class="c">#207818]  INFO -- : - User failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.483107 <span class="c">#207818]  INFO -- : - Clusters::Platforms::Kubernetes failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.504624 <span class="c">#207818]  INFO -- : - Snippet failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.507763 <span class="c">#207818]  INFO -- : - PersonalSnippet failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.510827 <span class="c">#207818]  INFO -- : - ProjectSnippet failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.534412 <span class="c">#207818]  INFO -- : - Clusters::Applications::Helm failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.552858 <span class="c">#207818]  INFO -- : - Clusters::Applications::Prometheus failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.572631 <span class="c">#207818]  INFO -- : - AlertManagement::HttpIntegration failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.591745 <span class="c">#207818]  INFO -- : - ProjectImportData failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.612651 <span class="c">#207818]  INFO -- : - RemoteMirror failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.634588 <span class="c">#207818]  INFO -- : - GrafanaIntegration failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.657573 <span class="c">#207818]  INFO -- : - PagesDomainAcmeOrder failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.678924 <span class="c">#207818]  INFO -- : - JiraConnectInstallation failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.701446 <span class="c">#207818]  INFO -- : - PagesDomain failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.723396 <span class="c">#207818]  INFO -- : - WebHook failures: 1</span>
I, <span class="o">[</span>2022-01-14T12:11:14.728267 <span class="c">#207818]  INFO -- : - ProjectHook failures: 1</span>
I, <span class="o">[</span>2022-01-14T12:11:14.732394 <span class="c">#207818]  INFO -- : - ServiceHook failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.735019 <span class="c">#207818]  INFO -- : - SystemHook failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.756876 <span class="c">#207818]  INFO -- : - Integrations::IssueTrackerData failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.775782 <span class="c">#207818]  INFO -- : - Integrations::JiraTrackerData failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.797853 <span class="c">#207818]  INFO -- : - Integrations::ZentaoTrackerData failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.818263 <span class="c">#207818]  INFO -- : - BulkImports::Configuration failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.838087 <span class="c">#207818]  INFO -- : - Clusters::KubernetesNamespace failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.859981 <span class="c">#207818]  INFO -- : - Atlassian::Identity failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.881123 <span class="c">#207818]  INFO -- : - IncidentManagement::ProjectIncidentManagementSetting failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.903973 <span class="c">#207818]  INFO -- : - ErrorTracking::ProjectErrorTrackingSetting failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.922100 <span class="c">#207818]  INFO -- : - Alerting::ProjectAlertingSetting failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.941501 <span class="c">#207818]  INFO -- : - Serverless::DomainCluster failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.944543 <span class="c">#207818]  INFO -- : - Clusters::Integrations::Prometheus failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.965724 <span class="c">#207818]  INFO -- : - Clusters::Providers::Gcp failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:14.985521 <span class="c">#207818]  INFO -- : - Clusters::Providers::Aws failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:15.005871 <span class="c">#207818]  INFO -- : - Packages::Debian::ProjectDistributionKey failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:15.025454 <span class="c">#207818]  INFO -- : - Packages::Debian::GroupDistributionKey failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:15.029060 <span class="c">#207818]  INFO -- : - Gitlab::BackgroundMigration::BackfillJiraTrackerDeploymentType2::JiraTrackerDataTemp failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:15.081215 <span class="c">#207818]  INFO -- : - Ci::Runner failures: 1</span>
I, <span class="o">[</span>2022-01-14T12:11:15.309755 <span class="c">#207818]  INFO -- : - Ci::Build failures: 1</span>
I, <span class="o">[</span>2022-01-14T12:11:15.449126 <span class="c">#207818]  INFO -- : - Group failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:15.662949 <span class="c">#207818]  INFO -- : - Project failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:15.710390 <span class="c">#207818]  INFO -- : - DeployToken failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:15.740096 <span class="c">#207818]  INFO -- : - Clusters::AgentToken failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:15.762011 <span class="c">#207818]  INFO -- : - Operations::FeatureFlagsClient failures: 0</span>
I, <span class="o">[</span>2022-01-14T12:11:15.762112 <span class="c">#207818]  INFO -- : Total: 5 row(s) affected</span>
I, <span class="o">[</span>2022-01-14T12:11:15.762150 <span class="c">#207818]  INFO -- : Done!</span>
</code></pre></div></div>
<h4 id="连接数据库">连接数据库</h4>

<p>  以下为官方给定的在不同版本和安装方式下连接数据库的命令。由于容器 sameersbn/docker-gitlab 采用的是源码安装方式，所以采用最后一种连接方式，所以使用命令如最后所示。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># For Omnibus GitLab 14.1 and earlier:</span>
<span class="nb">sudo </span>gitlab-rails dbconsole

<span class="c"># For Omnibus GitLab 14.2 and later:</span>
<span class="nb">sudo </span>gitlab-rails dbconsole <span class="nt">--database</span> main

<span class="c"># For installations from source, GitLab 14.1 and earlier:</span>
<span class="nb">sudo</span> <span class="nt">-u</span> git <span class="nt">-H</span> bundle <span class="nb">exec </span>rails dbconsole <span class="nt">-e</span> production

<span class="c"># For installations from source, GitLab 14.2 and later:</span>
<span class="nb">sudo</span> <span class="nt">-u</span> git <span class="nt">-H</span> bundle <span class="nb">exec </span>rails dbconsole <span class="nt">-e</span> production <span class="nt">--database</span> main

<span class="c"># 容器 sameersbn/docker-gitlab 连接数据库</span>
docker <span class="nb">exec</span> <span class="nt">-ti</span> <span class="nt">-u</span> git gitlab_gitlab_1 bundle <span class="nb">exec </span>rails dbconsole <span class="nt">-e</span> production <span class="nt">--database</span> main
</code></pre></div></div>

<h4 id="查询并重置-cicd-数据">查询并重置 CI/CD 数据</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">--  查询所有 CI/CD 记录</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">public</span><span class="p">.</span><span class="nv">"ci_group_variables"</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">public</span><span class="p">.</span><span class="nv">"ci_variables"</span><span class="p">;</span>

<span class="c1">-- 删除所有 CI/CD 记录</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">ci_group_variables</span><span class="p">;</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">ci_variables</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="清除加密-token">清除加密 TOKEN</h4>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Clear project tokens</span>
<span class="k">UPDATE</span> <span class="n">projects</span> <span class="k">SET</span> <span class="n">runners_token</span> <span class="o">=</span> <span class="k">null</span><span class="p">,</span> <span class="n">runners_token_encrypted</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
<span class="c1">-- Clear group tokens</span>
<span class="k">UPDATE</span> <span class="n">namespaces</span> <span class="k">SET</span> <span class="n">runners_token</span> <span class="o">=</span> <span class="k">null</span><span class="p">,</span> <span class="n">runners_token_encrypted</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
<span class="c1">-- Clear instance tokens</span>
<span class="k">UPDATE</span> <span class="n">application_settings</span> <span class="k">SET</span> <span class="n">runners_registration_token_encrypted</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
<span class="c1">-- Clear key used for JWT authentication</span>
<span class="c1">-- This may break the $CI_JWT_TOKEN job variable:</span>
<span class="c1">-- https://gitlab.com/gitlab-org/gitlab/-/issues/325965</span>
<span class="k">UPDATE</span> <span class="n">application_settings</span> <span class="k">SET</span> <span class="n">encrypted_ci_jwt_signing_key</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
<span class="c1">-- Clear runner tokens</span>
<span class="k">UPDATE</span> <span class="n">ci_runners</span> <span class="k">SET</span> <span class="n">token</span> <span class="o">=</span> <span class="k">null</span><span class="p">,</span> <span class="n">token_encrypted</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
<span class="c1">-- Clear build tokens</span>
<span class="k">UPDATE</span> <span class="n">ci_builds</span> <span class="k">SET</span> <span class="n">token</span> <span class="o">=</span> <span class="k">null</span><span class="p">,</span> <span class="n">token_encrypted</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
<span class="c1">-- truncate web_hooks table</span>
<span class="k">TRUNCATE</span> <span class="n">web_hooks</span> <span class="k">CASCADE</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="重新验证错误">重新验证错误</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 验证秘钥引发的错误情况</span>
docker <span class="nb">exec</span> <span class="nt">-ti</span> <span class="nt">-u</span> git gitlab_gitlab_1 bundle <span class="nb">exec </span>rake gitlab:doctor:secrets

<span class="c"># 发现所有错误均为 0 表示修复成功。可以访问管理员设置页面进行验证。</span>
</code></pre></div></div>

<h3 id="修复指标和分析-500-错误">修复指标和分析 500 错误</h3>

<p>  指标和分析 500 错误是从升级到 14.0.5 版本之后开始出现的，主要是因为在指标和分析中新增了指向 tmpfs 的配置项 prometheus_multiproc_dir。在默认的 sameersbn/docker-gitlab 容器中还未添加这一配置项，从而导致指标和分析页面无法访问。修复方法是，在 docker-compose.yml 中添加该配置项，如下所示。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">2.3'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">redis</span><span class="pi">:</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis:6.2.6</span>
    <span class="na">command</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">--loglevel warning</span>
    <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./redis-data:/data</span>

  <span class="na">postgresql</span><span class="pi">:</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">sameersbn/postgresql:12-20200524</span>
    <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./postgresql-data:/var/lib/postgresql</span>
    <span class="na">environment</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">DB_USER=gitlab</span>
    <span class="pi">-</span> <span class="s">DB_PASS=password</span>
    <span class="pi">-</span> <span class="s">DB_NAME=gitlabhq_production</span>
    <span class="pi">-</span> <span class="s">DB_EXTENSION=pg_trgm,btree_gist</span>

  <span class="na">gitlab</span><span class="pi">:</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">sameersbn/gitlab:14.6.1</span>
    <span class="na">depends_on</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">redis</span>
    <span class="pi">-</span> <span class="s">postgresql</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s2">"</span><span class="s">80:80"</span>
    <span class="pi">-</span> <span class="s2">"</span><span class="s">22:22"</span>
    <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./gitlab-data:/home/git/data</span>
    <span class="na">healthcheck</span><span class="pi">:</span>
      <span class="na">test</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">CMD"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">/usr/local/sbin/healthcheck"</span><span class="pi">]</span>
      <span class="na">interval</span><span class="pi">:</span> <span class="s">5m</span>
      <span class="na">timeout</span><span class="pi">:</span> <span class="s">10s</span>
      <span class="na">retries</span><span class="pi">:</span> <span class="m">3</span>
      <span class="na">start_period</span><span class="pi">:</span> <span class="s">5m</span>
    <span class="na">environment</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">DEBUG=false</span>
    <span class="pi">-</span> <span class="s">prometheus_multiproc_dir=/dev/shm</span>
    <span class="s">......</span>
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://docs.gitlab.com/ee/raketasks/backup_restore.html#when-the-secrets-file-is-lost">When the secrets file is lost</a></li>
  <li><a href="https://docs.gitlab.com/ee/raketasks/backup_restore.html#storing-configuration-files">Storing configuration files</a></li>
  <li><a href="https://docs.gitlab.com/ee/administration/monitoring/prometheus/gitlab_metrics.html#metrics-shared-directory">Metrics shared directory</a></li>
  <li><a href="https://blog.csdn.net/weixin_44295157/article/details/119618816">Gitlab Admin 管理页面提示 500 内部错误(500 Internal error)的解决办法</a></li>
  <li><a href="https://blog.csdn.net/Shawn_wang_0919/article/details/115895292">gitlab 迁移之后 runner 报 500 解决方案—-gitlab-secrets.json 忘记备份</a></li>
  <li><a href="https://lintian.co/archives/16">GitLab 备份恢复后 500 错误修复</a></li>
  <li><a href="https://github.com/sameersbn/docker-gitlab/issues/2387">metrics and profiling not working after upgrade to 14.0.5</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Nextcloud" /><category term="Upgrade" /><category term="Fix" /><category term="升级" /><category term="修复" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">Nextcloud 升级那些事儿</title><link href="https://lisz.me/tech/webmaster/nextcloud-upgrade.html" rel="alternate" type="text/html" title="Nextcloud 升级那些事儿" /><published>2022-01-13T11:26:00+09:00</published><updated>2022-01-13T11:26:00+09:00</updated><id>https://lisz.me/tech/webmaster/nextcloud-upgrade</id><content type="html" xml:base="https://lisz.me/tech/webmaster/nextcloud-upgrade.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  Nextcloud 的升级根据部署方式的不同也会有所差异。比如源码部署的 Nextcloud 的升级，一般是通过在网页端的管理页面点击升级按钮、经过漫长的等待然后完成。由于这种方式的升级要对本地的源代码同时进行升级，因此存在本地环境与升级所需环境不一致而导致升级失败的可能性。当然，一般来说源码升级总是要先看看环境要求是否相同，如果不同则应该先满足环境要求、再进行后续的升级。</p>

<p>  而对于 Docker 方式部署的 Nextcloud 来说，源代码、数据文件（包括配置文件和网盘文件）、数据库、缓存数据库四者之间既可独立维护，也可搭配使用。这样一来，每次的升级基本上都只需要升级一下源代码的容器镜像即可。数据文件一般是直接本地持久化的，数据库容器镜像一般不太更新，除非是 Nextcloud 进行数据库大版本升级的大更新。至于缓存数据库（比如 Redis），升不升级都不大会影响 Nextcloud 的正常运行，除非是缓存数据库新旧版本的差异导致源代码无法直接使用新版本的缓存数据库。</p>

<p>  之前笔者也写过两篇关于 Nextcloud 的文章： <a href="../webmaster/nextcloud.html">Nextcloud 搭建自己的云盘</a> 和 <a href="../docker/nextcloud-docker.html">Nextcloud 源码部署迁移到容器部署</a>。其中前一篇中其实也包括正常的 Docker 部署方式的 Nextcloud 升级，那为什么又要重新写一篇专门关于 Nextcloud 升级的文章呢？主要还是因为在实际升级过程中，发现了一些容易出问题的升级方式，而“如何在此基础上进行修复”是一件非常有意思的事情。那么接下来就来看看 Nextcloud 升级过程中到底能遇到哪些问题呢。</p>

<h2 id="问题及修复">问题及修复</h2>

<h3 id="问题一跨版本升级">问题一：跨版本升级</h3>

<h4 id="问题描述">问题描述</h4>

<p>  所谓跨版本升级就是指跳过某些重要版本更新而直接升级到另一个大版本。之前在 <a href="../docker/gitlab.html">私有代码托管平台的搭建与运维</a> 一文也提到过 Gitlab 的版本升级中不能直接从一个旧版本直接升级到最新版本，Nextcloud 亦然。比如，从 Nextcloud 22.0 版本升级到 Nextcloud 23.0 版本的话，就属于跨版本升级（在它们之间有一个重要版本更新 Nextcloud 22.2）。</p>

<h4 id="修复方案">修复方案</h4>

<p>  如果你在更新 Nextcloud 时未对版本更新可行性进行检验而直接跨版本更新，那么你将会在 Docker 容器的日志上看到提示无法跨版本更新。此时，由于容器只修改了 www/version.php 文件（如下所示），未对数据库及其他文件进行修改，还是可以修复回来的。</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- version.php --&gt;</span>

<span class="cp">&lt;?php</span>
<span class="nv">$OC_Version</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
<span class="nv">$OC_VersionString</span> <span class="o">=</span> <span class="s1">'23.0.0'</span><span class="p">;</span>
<span class="nv">$OC_Edition</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
<span class="nv">$OC_Channel</span> <span class="o">=</span> <span class="s1">'stable'</span><span class="p">;</span>
<span class="nv">$OC_VersionCanBeUpgradedFrom</span> <span class="o">=</span> <span class="k">array</span> <span class="p">(</span>
  <span class="s1">'nextcloud'</span> <span class="o">=&gt;</span>
  <span class="k">array</span> <span class="p">(</span>
    <span class="s1">'22.2'</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span>
    <span class="s1">'23.0'</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">),</span>
  <span class="s1">'owncloud'</span> <span class="o">=&gt;</span>
  <span class="k">array</span> <span class="p">(</span>
    <span class="s1">'10.5'</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">),</span>
<span class="p">);</span>
<span class="nv">$OC_Build</span> <span class="o">=</span> <span class="s1">'2021-11-26T20:54:42+00:00 0619207f13792250aea775a2c3133d41ab625980'</span><span class="p">;</span>
<span class="nv">$vendor</span> <span class="o">=</span> <span class="s1">'nextcloud'</span><span class="p">;</span>
</code></pre></div></div>

<p>  修复的主要步骤分为以下两步：</p>
<ul>
  <li>将 version.php 文件修改为以下内容，然后重新使用 nextcloud:22.0 容器启动。</li>
  <li>启动后会发现一切恢复正常，然后根据 22.0 -&gt; 22.2 -&gt; 23.0 的规划路线进行正常升级即可。一般来说，升级镜像后镜像内部会自动运行更新命令，并在更新完成后自动关闭维护模式。如果镜像内部为自动运行，可以参考下面命令手动完成相关插件更新。</li>
</ul>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- modified version.php --&gt;</span>

<span class="cp">&lt;?php</span>
<span class="nv">$OC_Version</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="mi">22</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>   <span class="c1">// 修改为升级前版本号</span>
<span class="nv">$OC_VersionString</span> <span class="o">=</span> <span class="s1">'22.0.0.12'</span><span class="p">;</span>  <span class="c1">// 修改为升级前版本号</span>
<span class="nv">$OC_Edition</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
<span class="nv">$OC_Channel</span> <span class="o">=</span> <span class="s1">'stable'</span><span class="p">;</span>
<span class="nv">$OC_VersionCanBeUpgradedFrom</span> <span class="o">=</span> <span class="k">array</span> <span class="p">(</span>
  <span class="s1">'nextcloud'</span> <span class="o">=&gt;</span>
  <span class="k">array</span> <span class="p">(</span>
    <span class="s1">'22.0'</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span>               <span class="c1">// 添加支持从升级前版本号开始升级</span>
    <span class="s1">'22.2'</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span>
    <span class="s1">'23.0'</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">),</span>
  <span class="s1">'owncloud'</span> <span class="o">=&gt;</span>
  <span class="k">array</span> <span class="p">(</span>
    <span class="s1">'10.5'</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">),</span>
<span class="p">);</span>
<span class="nv">$OC_Build</span> <span class="o">=</span> <span class="s1">'2021-11-26T20:54:42+00:00 0619207f13792250aea775a2c3133d41ab625980'</span><span class="p">;</span>
<span class="nv">$vendor</span> <span class="o">=</span> <span class="s1">'nextcloud'</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 手动更新镜像内部插件，并在更新后关闭维护模式。</span>

docker <span class="nb">exec</span> <span class="nt">-u</span> www-data <span class="nt">-ti</span> nextcloud_app_1 php occ maintenance:mode <span class="nt">--on</span>
docker <span class="nb">exec</span> <span class="nt">-u</span> www-data <span class="nt">-ti</span> nextcloud_app_1 php occ upgrade
docker <span class="nb">exec</span> <span class="nt">-u</span> www-data <span class="nt">-ti</span> nextcloud_app_1 php occ maintenance:mode <span class="nt">--off</span>
</code></pre></div></div>

<h3 id="问题二数据库索引缺失">问题二：数据库索引缺失</h3>

<h4 id="问题描述-1">问题描述</h4>

<p>  在完成新版本更新后，打开管理员的概览界面，有的时候会看到如下报错：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在数据表 “oc_share” 中无法找到索引 “share_with_index”。
在数据表 “oc_share” 中无法找到索引 “parent_index”。
在数据表 “oc_share” 中无法找到索引 “owner_index”。
在数据表 “oc_share” 中无法找到索引 “initiator_index”。
在数据表 “oc_filecache” 中无法找到索引 “fs_mtime”。
</code></pre></div></div>

<h4 id="修复方案-1">修复方案</h4>

<p>  一般我们可以在报错的提示中看到建议执行命令 <code class="language-plaintext highlighter-rouge">occ db:add-missing-indices</code> 来修复丢失的索引。在容器外我们可以采用以下命令执行：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">exec</span> <span class="nt">-u</span> www-data <span class="nt">-ti</span> nextcloud_app_1 php occ db:add-missing-indices
</code></pre></div></div>

<h3 id="问题三数据库类型转换失败">问题三：数据库类型转换失败</h3>

<h4 id="问题描述-2">问题描述</h4>

<p>  数据库中的一些列由于进行长整型转换而缺失。由于在较大的数据表重改变列类型会耗费一些时间，因此程序没有自动对其更改。以下为可能提示的列：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>activity.activity_id
activity.object_id
activity_mq.mail_id
filecache.fileid
filecache.storage
filecache.parent
filecache.mimetype
filecache.mimepart
filecache.mtime
filecache.storage_mtime
mimetypes.id
mounts.storage_id
mounts.root_id
mounts.mount_id
storages.numeric_id
</code></pre></div></div>

<h4 id="修复方案-2">修复方案</h4>

<p>  这种问题也比较容易修正，一般会提示执行命令 <code class="language-plaintext highlighter-rouge">occ db:convert-filecache-bigint</code> 来修复。在容器外我们可以采用以下命令执行：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">exec</span> <span class="nt">-u</span> www-data <span class="nt">-ti</span> nextcloud_app_1 php occ db:convert-filecache-bigint
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://nicolasbouliane.com/blog/nextcloud-docker-upgrade-error">How to fix an accidental Nextcloud docker image update</a></li>
  <li><a href="https://blog.csdn.net/robin_cai/article/details/119530743">Nextcloud 升级后问题解决</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Nextcloud" /><category term="Upgrade" /><category term="Docker" /><category term="升级" /><category term="修复" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">Jekyll 文章侧边索引导航</title><link href="https://lisz.me/tech/webmaster/jekyll-toc.html" rel="alternate" type="text/html" title="Jekyll 文章侧边索引导航" /><published>2022-01-09T22:00:00+09:00</published><updated>2022-01-09T22:00:00+09:00</updated><id>https://lisz.me/tech/webmaster/jekyll-toc</id><content type="html" xml:base="https://lisz.me/tech/webmaster/jekyll-toc.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#前言" id="markdown-toc-前言">前言</a>    <ul>
      <li><a href="#jekyll-生成目录的方案" id="markdown-toc-jekyll-生成目录的方案">Jekyll 生成目录的方案</a>        <ul>
          <li><a href="#第一种方案" id="markdown-toc-第一种方案">第一种方案</a></li>
          <li><a href="#第二种方案" id="markdown-toc-第二种方案">第二种方案</a></li>
          <li><a href="#第三种方案" id="markdown-toc-第三种方案">第三种方案</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#实践" id="markdown-toc-实践">实践</a>    <ul>
      <li><a href="#布局" id="markdown-toc-布局">布局</a></li>
      <li><a href="#目录生成" id="markdown-toc-目录生成">目录生成</a></li>
      <li><a href="#自适应" id="markdown-toc-自适应">自适应</a></li>
      <li><a href="#最终代码" id="markdown-toc-最终代码">最终代码</a></li>
    </ul>
  </li>
  <li><a href="#参考资料" id="markdown-toc-参考资料">参考资料</a></li>
</ul>

<h2 id="前言">前言</h2>

<p>  Jekyll 与 Hexo 不同之处有很多，其中一处是在文章页面中不支持原生 [TOC] Markdown 语法来自动生成目录。而在 Hexo 中，即使主题不支持侧边悬浮的优化目录导航，也可以通过最简单的方式在文章的开始位置生成目录。虽然这种目录永远固定在文章开始的地方，但是总算是能够通过大小标题来给读者一个大概的思路。</p>

<h3 id="jekyll-生成目录的方案">Jekyll 生成目录的方案</h3>

<p>  如参考资料 1 中所提到的，如果想要在 Jekyll 中实现文章目录，有三种不同的方案可供选择：</p>

<h4 id="第一种方案">第一种方案</h4>

<p>  利用完整的标签来生成静态目录，可以看到在本文的开头就是这样的一个实例。这种方法的好处是不需要修改什么复杂的模板或者添加什么样式，Github Pages 也默认支持这种方式。不好的地方是与标准的 Markdown 语法略有不同，而且每次都得在文章内容页面开头加上以下代码。如果你使用带有 markdownlint 插件的编辑器编辑文章时，可能会有一堆告警。当然，如果不想折腾的人，这种方法不失为一种最简单方便的解决方案。</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">*</span> TOC
{:toc}
</code></pre></div></div>

<h4 id="第二种方案">第二种方案</h4>

<p>  利用第三方插件 <a href="https://github.com/toshimaru/jekyll-toc">jekyll-toc</a>。这种方式在实现上比上一种要更加优雅一些，不需要自己修改或编写代码，只需要执行以下步骤即可。缺点在于 Github Pages 不支持这类自定义插件，你可能需要使用自定义的 workflow.yml 文件来指导 Github Action 来编译生成静态文件。如果不怎么了解 Github Action，恐怕这种方式部署在 Github Pages 上也不是很省心。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># gemfile</span>

<span class="n">gem</span> <span class="s2">"jekyll-toc"</span>

<span class="c1"># 添加后需执行 bundle install 安装插件</span>
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># _config.yml</span>

<span class="c1"># 在全局配置文件中启用 jekyll-toc 插件</span>
<span class="na">plugins</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">jekyll-toc"</span><span class="pi">]</span>

<span class="c1"># 默认为所有文章启用 toc</span>
<span class="na">defaults</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">scope</span><span class="pi">:</span>
      <span class="na">path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
    <span class="na">values</span><span class="pi">:</span>
      <span class="na">toc</span><span class="pi">:</span> <span class="no">true</span>
</code></pre></div></div>

<h4 id="第三种方案">第三种方案</h4>

<p>  采用新增 jekyll 模板的方式来支持自动生成目录。这种方式也可以直接运行在 Github Pages 下。主要的步骤是：</p>
<ul>
  <li>将 <a href="https://github.com/allejo/jekyll-toc/releases/download/v1.2.0/toc.html">toc.html</a> 文件下载到 _includes 目录下；</li>
  <li>在 _layouts 需要使用 toc 功能的页面模板的 content 前面加上 <code class="language-plaintext highlighter-rouge">% include toc.html html=content %</code>。</li>
</ul>

<h2 id="实践">实践</h2>

<p>  从上述三种方案综合来看，第三种方案能够同时支持自动生成目录和 Github Pages，比较适合预期的需求。另外，采用模板的方式还有一个好处，可以在全局配置文件 _config.yml 中一键设置“开启”或“关闭”，配置上比较简单。但如果仅仅照搬上述的第三种方案，还是不能完全满足实际的需求。因为第三种方案的结果是自动生成目录的内容，并不涉及到具体的布局，也就是说只能放在某一个固定的位置。总结的来说，实际的目标起码需要满足以下两点：</p>
<ul>
  <li><strong>目标一</strong>：目录位于正文右侧（或左侧），且当内容滑动时目录位置固定不变。</li>
  <li><strong>目标二</strong>：目录在宽屏时自动显示，在窄屏或移动端分辨率不足时自动隐藏。</li>
</ul>

<h3 id="布局">布局</h3>

<p>  从目标一来看，其实在大部分的静态博客主题中都是有这样的功能的（PS：可能 Jekyll 是个例外，原生只支持静态目录）。我们可以先来看两个例子 <a href="https://github.com/ahonn/hexo-theme-even">hexo-theme-even</a> 和 <a href="https://www.markdownguide.org/getting-started/">markdownguide</a>。前面的例子是 Hexo 主题，其中采用的是 js 控制 toc 的 div 层在 <code class="language-plaintext highlighter-rouge">position: absolute</code> 和 <code class="language-plaintext highlighter-rouge">position: fixed</code> 之间变换：当页面初始时，处于 absolute 位置；当页面在向下滑动时，处于 fixed 位置。这种方式需要有 js 代码的介入，增加了运算的成本（虽然其实很小）和维护成本（占比更大）。后面的例子是采用了 Bootstrap 框架中的 toc js 插件，能够满足目标一，且能跟踪内容位置来切换显示的二级目录，相对来说功能更加强大。唯一的缺点是，拖着 Bootstrap 这个大拖油瓶，如果本身的主题是基于 Bootstrap 框架的，那么就非常合适了。</p>

<p>  这里我们想要实践的是在未使用 Bootstrap 框架的 Jekyll 主题中增加目标一的功能，因此这两个例子的做法都不是很合适。实际上，从需要维护的代码量来说，第一个例子的做法所需的 js 代码应该是算少的，但是不是存在完全不使用 js 代码也能实现这样的功能的方案呢？实际上是存在的。据我们所知，现在已有的页面布局的方法大致有三种：<strong>Table 布局</strong>、<strong>Div 布局</strong>和 <strong>Flex 布局</strong>。Table 布局算是最原始的布局方式了，主要利用 Table 的横列来组织页面中的各个元素的位置，特点是容易上手且不易出问题。缺点也比较明显，不大符合语义化 HTML 的规范，即 HTML 标签只做与它含义相同的事情。Table 标签作为表格布局标签，应该专注于展示表格数据，而非为整个页面布局操心。于是，Div 布局开始流行起来。Div 层的概念和布局的含义完全吻合，也容易理解。Div 布局比较让人头疼的地方是，页面中有很多浮动元素出现时，可能会出现各种各样想象不到的问题，某些布局之后被迫要清除浮动。Flex 布局的出现为 Div 布局提出了改善，使得页面布局不再被浮动元素和 Div 层浮动时内容大小为零所困恼。</p>

<p>  由于想要目录内容块随着内容滑动而改变 position，我们可以采用 sticky 的 position 方案。这可能是 css 的一大进步，通过定义 sticky 的 position 可以让元素根据相邻元素的滑动而改变 position。其实，sticky 就等于 absolute 加上 fixed。只是这种等价只在某些条件成立时才能生效。我们可以通过参考资料 2~4 来了解更多详情。</p>

<h3 id="目录生成">目录生成</h3>

<p>  目录生成这里直接采用的是上述的第三种方案。具体在 post 模板页使用 toc 模块的代码如最后所示。</p>

<h3 id="自适应">自适应</h3>

<p>  为了实现目标二，这里采用了最简单的 CSS 媒体查询，即在平常 PC 端宽屏时采用如下 common.sass 中的样式。显示目录时，正文内容宽度为 720 px，目录宽度为 280 px。同时为了将目录与正文拉大间距以及更好区分，这里增加了 margin-left （30 px）、border-left（2px）和 padding（10px）。总计为，720+280+30+10*2=1050 px（这里忽略了 2px 的边界）。不显示目录时，让正文占据所有宽度，并设置目录块为 <code class="language-plaintext highlighter-rouge">display: none</code>，即隐藏该元素。具体实现如最终代码 common.sass 和 layout.sass 所示。在没有 sass 编译环境下，此处的 sass 代码可以取出转换为 css 使用。</p>

<h3 id="最终代码">最终代码</h3>

<div class="language-liquid highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- post.html --&gt;

<span class="p">{%</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="nv">site</span><span class="p">.</span><span class="nv">toc</span><span class="w"> </span><span class="p">%}</span>
  &lt;div class="container"&gt;  
    &lt;div class="contents"&gt;
      &lt;article class="markdown-body"&gt;
        <span class="p">{{</span><span class="w"> </span><span class="nv">page</span><span class="p">.</span><span class="nv">content</span><span class="w"> </span><span class="p">}}</span>
      &lt;/article&gt;
    &lt;/div&gt;   
    &lt;div class="table-of-contents"&gt;
      &lt;h2&gt;Contents&lt;/h2&gt;
      <span class="p">{%</span><span class="w"> </span><span class="nt">include</span><span class="w"> </span>toc.html<span class="w"> </span><span class="na">html</span><span class="o">=</span><span class="nv">content</span><span class="w"> </span><span class="p">%}</span>
    &lt;/div&gt;
  &lt;/div&gt;
<span class="p">{%</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="p">%}</span>
  &lt;article class="markdown-body"&gt;
    <span class="p">{{</span><span class="w"> </span><span class="nv">page</span><span class="p">.</span><span class="nv">content</span><span class="w"> </span><span class="p">}}</span>
  &lt;/article&gt;
<span class="p">{%</span><span class="w"> </span><span class="kr">endif</span><span class="w"> </span><span class="p">%}</span>
</code></pre></div></div>

<div class="language-sass highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;!</span><span class="nt">--</span> <span class="nt">common</span><span class="nc">.sass</span> <span class="nt">--</span><span class="o">&gt;</span>

<span class="nc">.container</span> <span class="err">{</span>
    <span class="nl">width</span><span class="p">:</span> <span class="m">1050px</span><span class="err">;</span>
    <span class="nl">margin</span><span class="p">:</span> <span class="m">0</span> <span class="nb">auto</span><span class="err">;</span>
    <span class="nl">display</span><span class="p">:</span> <span class="n">flex</span><span class="err">;</span>
    <span class="nl">flex-direction</span><span class="p">:</span> <span class="n">row</span><span class="err">;</span>
    <span class="nc">.contents</span><span class="err">{</span>
        <span class="nl">width</span><span class="p">:</span> <span class="m">720px</span><span class="err">;</span>
    <span class="err">}</span>
    <span class="nc">.table-of-contents</span><span class="err">{</span>
        <span class="nl">padding</span><span class="p">:</span> <span class="m">10px</span><span class="err">;</span>
        <span class="nl">border-left</span><span class="p">:</span> <span class="m">2px</span> <span class="nb">solid</span> <span class="mh">#efefef</span><span class="err">;</span>
        <span class="nl">width</span><span class="p">:</span> <span class="m">280px</span><span class="err">;</span>
        <span class="nl">position</span><span class="p">:</span> <span class="o">-</span><span class="n">webkit-sticky</span><span class="err">;</span>
        <span class="nl">position</span><span class="p">:</span> <span class="n">sticky</span><span class="err">;</span>
        <span class="nl">top</span><span class="p">:</span> <span class="m">80px</span><span class="err">;</span>
        <span class="nl">margin-bottom</span><span class="p">:</span> <span class="m">80px</span><span class="err">;</span>
        <span class="nl">height</span><span class="p">:</span> <span class="n">fit-content</span><span class="err">;</span>
        <span class="nl">margin-left</span><span class="p">:</span> <span class="m">30px</span><span class="err">;</span>
        <span class="nt">h2</span> <span class="err">{</span>
            <span class="nl">font-family</span><span class="p">:</span> <span class="nb">fantasy</span><span class="err">;</span>
            <span class="nl">color</span><span class="p">:</span> <span class="mh">#e32e00</span><span class="err">;</span>
        <span class="err">}</span>
        <span class="nt">ul</span><span class="err">{</span>
            <span class="nl">margin-left</span><span class="p">:</span> <span class="m">20px</span><span class="err">;</span>
            <span class="nl">list-style-type</span><span class="p">:</span> <span class="n">revert</span><span class="err">;</span>
            <span class="nl">font-size</span><span class="p">:</span> <span class="m">14px</span><span class="err">;</span>
            <span class="nl">line-height</span><span class="p">:</span> <span class="m">24px</span><span class="err">;</span>
            <span class="nl">color</span><span class="p">:</span> <span class="mh">#005b81</span><span class="err">;</span>
            <span class="nt">a</span><span class="err">{</span>
                <span class="nl">color</span><span class="p">:</span> <span class="mh">#005b81</span><span class="err">;</span>
                <span class="k">&amp;</span><span class="nd">:hover</span><span class="err">{</span>
                    <span class="nl">color</span><span class="p">:</span> <span class="mh">#e32e00</span><span class="err">;</span>
                    <span class="nl">text-decoration</span><span class="p">:</span> <span class="nb">underline</span><span class="err">;</span>
                <span class="err">}</span>
            <span class="err">}</span>
        <span class="err">}</span>
    <span class="err">}</span>
<span class="err">}</span>
</code></pre></div></div>

<div class="language-sass highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;!</span><span class="nt">--</span> <span class="nt">layout</span><span class="nc">.sass</span> <span class="nt">--</span><span class="o">&gt;</span>

<span class="k">@media</span> <span class="n">screen</span> <span class="nf">and</span> <span class="p">(</span><span class="n">max-width</span><span class="o">:</span> <span class="m">1050px</span><span class="p">)</span> <span class="err">{</span>
    <span class="nc">.post-content</span> <span class="err">{</span>
        <span class="nc">.container</span> <span class="err">{</span>
            <span class="nl">width</span><span class="p">:</span> <span class="m">100%</span><span class="err">;</span>
            <span class="nc">.contents</span> <span class="err">{</span>
                <span class="nl">width</span><span class="p">:</span> <span class="m">100%</span><span class="err">;</span>
                <span class="nl">float</span><span class="p">:</span> <span class="nb">none</span><span class="err">;</span>
                <span class="nl">margin</span><span class="p">:</span> <span class="m">0</span> <span class="nb">auto</span><span class="err">;</span>
            <span class="err">}</span>
            <span class="nc">.table-of-contents</span> <span class="err">{</span>
                <span class="nl">display</span><span class="p">:</span> <span class="nb">none</span><span class="err">;</span>
            <span class="err">}</span>
        <span class="err">}</span>
    <span class="err">}</span>
<span class="err">}</span>
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://plutotree.me/jekyll/2019/01/30/jekyll-toc-solution.html">jekyll自动生成目录的几种方案</a></li>
  <li><a href="https://www.runoob.com/css/css-positioning.html">Runoob - CSS Position 定位</a></li>
  <li><a href="https://segmentfault.com/a/1190000039858711">position:sticky 粘性定位的几种巧妙应用</a></li>
  <li><a href="https://www.php.cn/css-tutorial-466057.html">css3 sticky不生效怎么办</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Jekyll" /><category term="主题" /><category term="theme" /><category term="侧边索引" /><category term="TOC" /></entry><entry><title type="html">[译文]迭代机器学习：迈向模型准确性的一步</title><link href="https://lisz.me/ac/ml/iterative-learning.html" rel="alternate" type="text/html" title="[译文]迭代机器学习：迈向模型准确性的一步" /><published>2022-01-05T20:30:00+09:00</published><updated>2022-01-05T20:30:00+09:00</updated><id>https://lisz.me/ac/ml/iterative-learning</id><content type="html" xml:base="https://lisz.me/ac/ml/iterative-learning.html"><![CDATA[<p><strong>原文标题</strong>：<a href="https://hub.packtpub.com/iterative-machine-learning-step-towards-model-accuracy/">Iterative Machine Learning: A step towards Model Accuracy</a><br />
<strong>原文作者</strong>：Amarabha Benerjee</p>

<p>  通过死记硬背来学习一些东西，比如重复多次，通过一遍又一遍地练习来完善一项技能，或者通过逐步对原型进行细微调整来构建某些东西，这些都是我们人类自然而然发生的事情。机器也可以学习这种方式，这被称为“迭代机器学习”。在大多数情况下，迭代是一种有效的学习方法，有助于更快、更准确地达到预期的最终结果，而不会成为资源紧缩的噩梦。</p>

<p>  现在，你可能会想，迭代本身不就是任何机器学习的一部分吗？换句话说，从基础的回归分析、决策树、贝叶斯网络到高级的神经网络和深度学习算法，现代机器学习技术都内置了一些固有的迭代组件。那么，将迭代学习作为一个独立的主题来讨论的必要性是什么呢？这仅仅是因为将迭代外部引入到算法可以最大限度地减少误差范围，从而有助于准确建模。</p>

<h2 id="迭代学习是如何工作的">迭代学习是如何工作的</h2>

<p>  让我们仔细观察机器学习算法中单个迭代流期间发生的情况来了解迭代的原理。</p>

<p>  首先将预处理的训练数据集引入到模型中。在对给定的数据进行处理和构建模型后，对模型进行测试，然后将结果与所期待的输出进行匹配。然后将反馈返回给系统，以便算法那进一步学习和微调其结果。这清楚地表明，这里发生了两个迭代过程：</p>

<ol>
  <li>数据迭代——算法固有的</li>
  <li>模型训练迭代——外部引入</li>
</ol>

<p><img src="https://i.vgy.me/mYccJd.png" alt="vgy.me" /></p>

<p>  现在，如果我们没有将结果反馈到系统中，比如说不允许算法迭代学习，而是采用顺序方法，情况会变成怎么呢？算法是否有效，能否提供正确的结果呢？</p>

<p>  是的，算法肯定会起作用。但是，它产生的结果的质量将会因为许多因素而有很大的差异。训练数据集的质量和数量、所采用的特征定义和特征抽取技术、算法本身的鲁棒性等都是许多因素之一。即使上述所有工作都做得完美，仍然不能保证顺序方法产生的结果将非常准确。简而言之，结果既不准确，也不可重复。因此，迭代学习允许算法提高模型准确性。</p>

<p>  某些算法在设计中具有迭代核心，可以根据数据量的多少进行缩放。这些算法处于机器学习实现的最前沿，因为它们能够更快更好地执行。在接下来的部分，我们将讨论来自三种主要机器学习方法的不同算法类别的迭代——<strong>有监督机器学习</strong>、<strong>无监督机器学习</strong>和<strong>强化学习</strong>。</p>

<h2 id="提升算法有监督机器学习中的迭代">提升算法：有监督机器学习中的迭代</h2>

<p>  提升算法本质上是迭代的，是通过最小化错误来改善结果的最佳方式。它们主要旨在减少结果中的偏差，并将一组特定的弱学习分类器算法转换为强学习器，从而使它们能够减少错误。以下是一些示例：</p>
<ul>
  <li>AdaBoost（Adaptive Boosting）</li>
  <li>梯度提升树（Gradient Tree Boosting）</li>
  <li>XGBoost</li>
</ul>

<h3 id="它们是如何工作的">它们是如何工作的</h3>

<p>  所有的提升算法都有一个通用的分类器，这些分类器经过迭代修改以达到想要的结果。让我们以“在某篇文章中找抄袭案例”为例。这里的第一个分类器是找到一组单词，这些单词出现在其他地方或者另一篇文章中，这将导致一个红色信号。如果我们创建 10 个单独的单词组，并将它们称为分类器 1 到 10，那么我们将根据这些分类器检查我们的文章，并且任何可能的匹配都将会标记为红色。但是，这 10 个分类器没有任何红色信号并不意味着一个肯定的 100% 原创文章。因此，我们需要更新分类器，创建可能基于第一次通过的更短的组，从而提高分类器发现这篇文章与其他文章的相似性的准确性。Boosting 算法中的这个迭代过程最终使我们获得了相当高的准确率。原因是在每次迭代之后，分类器都会根据其性能进行更新。与其他内容非常相似的内容将进行更新和调整，以便我们可以获得更好的匹配。这种本质上改进算法的过程被称为提升，目前是有监督机器学习中最流行的方法之一。</p>

<h3 id="优缺点">优缺点</h3>

<p>  这种方法的明显优点是，它允许在最终模型中出现最小的错误，因为迭代模型能够在每次出现错误时自行纠正。缺点是处理时间较长，并且大量迭代对总体内存的要求较高。另一个重要方面是，反馈给训练模型的错误是在外部完成的，这意味着监督者可以控制模型及其修改方式。这反过来又有一个缺点，即模型无法学会自行消除错误。因此，该模型不能用于另一组数据。换句话说，模型不会自己学习如何变得无差错，因此不能移植到另一个数据集上，因为它需要从头开始学习过程。</p>

<h2 id="人工神经网络无监督机器学习中的迭代">人工神经网络：无监督机器学习中的迭代</h2>

<p>  神经网络已经成为无监督机器学习的典型代表，因为它们在预测数据模型方面的准确性。一些众所周知的神经网络有：</p>
<ul>
  <li>卷积神经网络（Convolutional Neural Networks，CNNs）</li>
  <li>玻尔兹曼机（Boltzman Machines，BMs）</li>
  <li>循环神经网络（Recurrent Neural Networks，RNNs）</li>
  <li>深度神经网络（Deep Neural Networks，DNNs）</li>
  <li>记忆网络（Memory Networks，MNs）</li>
</ul>

<h3 id="它们是如何工作的-1">它们是如何工作的</h3>

<p>  人工神经网络在模拟数据模型方面非常准确，主要是因为它们的迭代学习过程。但这个过程与我们之前探索的 Boosting 算法的过程不同。在这里，这个过程是无缝和自然的，在某种程度上，它为人工智能系统中的强化学习铺平了道路。</p>

<p>  神经网络由模拟人脑工作方式的电子网络组成。每个网络都有一个输入和输出节点，以及由算法组成的中间隐藏层。输入节点被赋予初始数据集以执行一系列的操作，并且每次迭代都会创建一个数据字符串输出作为结果。然后，这个输出与实际结果数据集进行匹配，并将错误反馈给输入节点。这样一来，这个错误使得算法能够自行纠正，并越来越接近实际数据集。这个过程称为训练神经网络，每次迭代都会提高准确性。与 Boosting 算法执行迭代的方式相比，执行的迭代之间的关键区别在于，这里我们不必手动更新分类器，算法会根据错误反馈自行更改。</p>

<h3 id="优缺点-1">优缺点</h3>

<p>  这个过程的主要优点是它可以达到的准确度。该模型也是可重用的，因为它学习了实现准确性的方法，而不仅仅是为你提供直接的结果。这种方法的另一面是，模型可能会严重出错，并完全偏离不同的方向。这是因为归纳迭代有自己的过程，不需要人工监督。“Facebook 聊天机器人偏离了他们最初的目标，并用自己的语言在他们内部进行交流”就是一个很好的例子。但俗话说，聪明的东西有其自身的问题。如果我们想要创建更准确的模型和更智能的系统，我们必须准备好应对这一风险。</p>

<h2 id="强化学习">强化学习</h2>

<p>  强化学习是机器学习的一个有趣的案例，其中简单的神经网络被连接起来，它们与环境相互作用，从错误和奖励中学习。这里介绍的迭代以复杂的形式发生。迭代以奖励或惩罚的形式发生，分别对应得出正确或错误的结果。在每次这种交互之后，多层神经网络都会合并反馈，然后重新创建模型以提高准确性。典型的奖励和惩罚方法在某种程度上将其置于一个即不是受监督也不是不受监督的空间，但表现出两者的特征，并且还具有产生更准确结果的额外优势。这里的缺点是模型在设计上很复杂。多层神经网络在多次迭代的情况下很难处理，因为每一层可能对某种奖励或惩罚做出不同的反应。因此，它可能产生内部冲突，这些冲突可能导致系统停滞不前——无法决定下一步向哪个方向发展。</p>

<h2 id="迭代的一些实际实现">迭代的一些实际实现</h2>

<p>  许多现代机器学习平台和框架已经实现了自己的迭代过程，从而创建更好的数据模型，Apache Spark 和 MapReduce 就是两个这样的例子。两者实现迭代的方式在技术上是不同的，它们有其优点和局限性。</p>

<p>  让我们来看看 MapReduce。它直接在磁盘上存在的 HDFS 文件系统上读取和写入数据。请注意，从磁盘读取和写入的每个迭代都需要大量的时间。这在某种程度上创建了一个更健壮和容错的系统，但在速度上妥协了。另一方面，Apache Spark 将数据存储在内存（弹性分布式数据集），比如 RAM 中。因此，每次迭代花费的时间要少得多，这使得 Spark 能够执行闪电般的快速数据处理。但是，Spark 执行迭代方式的主要问题是，动态内存或者 RAM 在存储迭代数据和执行复杂操作方面的可靠性远低于磁盘存储。因此，它的容错能力远低于 MapReduce。</p>

<h2 id="将其整合在一起">将其整合在一起</h2>

<p>  为了总结讨论，我们可以大致如下来看一下迭代过程及其实现机器学习模型的阶段：</p>

<p><img src="https://i.vgy.me/4XY4X4.png" alt="vgy.me" /></p>

<ol>
  <li><strong>参数迭代</strong>：这是任何算法迭代的第一个也是固有的阶段。算法涉及到的参数运行多次，并在此过程中最终确定模型的最佳拟合参数。</li>
  <li><strong>数据迭代</strong>：一旦模型参数最终确定之后，将数据放入系统并模拟模型。将多组数据放入系统中，以检查参数在产生想要的结果方面的有效性。因此，如果数据迭代阶段表明某些参数不适合模型，则将它们带回参数迭代阶段，并添加或修改参数。</li>
  <li><strong>模型迭代</strong>：在初始参数和数据集最终确定后，进行模型测试/训练。模型测试阶段的迭代是关于使用相同的参数和数据集多次运行相同的模型模拟，然后检查错误量，如果错误在每次迭代中都有很大变化，则数据或参数或两者都有问题。对数据和参数进行迭代，直到模型达到准确性。</li>
  <li><strong>人工迭代</strong>：此步骤涉及到人工归纳的迭代，其中将不同的模型放在一起以创建功能齐全的智能系统。在这里，多层次的拟合和再拟合恰好可以实现一个连贯的总体目标，比如创建无人驾驶汽车系统或功能完全的人工智能（AI）。</li>
</ol>

<p>  迭代对于在不久的将来创建更智能的 AI 系统至关重要。对复杂数据集执行多次迭代的巨大内存需求继续带来重大挑战。但随着人工智能芯片、存储设备和数据传输技术的日益完善，这些挑战变得越来越容易应对。</p>

<p>  我们相信，迭代机器学习技术将在不久的将来继续引领人工智能领域的转型。</p>

<h2 id="版权声明">版权声明</h2>

<p>  由于本文是对英文博文的译文，本人对文章内容不享有版权。如有版权争议，可联系撤下本文。</p>

<p>  As this article is a translation of an English blog post, I do not have the copyright of the content in this article. If there is a copyright dispute, please contact me to withdraw this article.</p>]]></content><author><name>zhonger</name></author><category term="ac" /><category term="ml" /><category term="迭代学习" /><category term="机器学习" /><category term="iterative learning" /><category term="machine learning" /><summary type="html"><![CDATA[原文标题：Iterative Machine Learning: A step towards Model Accuracy 原文作者：Amarabha Benerjee]]></summary></entry><entry><title type="html">H2O-ac theme for Jekyll</title><link href="https://lisz.me/tech/webmaster/new-theme-h2o-ac.html" rel="alternate" type="text/html" title="H2O-ac theme for Jekyll" /><published>2021-12-22T20:50:00+09:00</published><updated>2021-12-22T20:50:00+09:00</updated><id>https://lisz.me/tech/webmaster/new-theme-h2o-ac</id><content type="html" xml:base="https://lisz.me/tech/webmaster/new-theme-h2o-ac.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  正如大家所知，Jekyll 是一款高可定制的、非常流行的静态博客生成工具。围绕着 Jekyll 也衍生出了很多优秀的 Jekyll 主题， 由 <a href="https://github.com/kaeyleo">廖柯宇</a> 开发的 <a href="https://github.com/kaeyleo/jekyll-theme-H2O">H2O</a> 主题就是其中之一。极简主义、风格扁平化、卡片式布局、Medium 及知乎专栏的视觉风格等等特点，为我们带来了或许是迄今为止最漂亮的 Jekyll 主题。</p>

<p>  诞生之初，H2O 主题就在 Github 平台上以 MIT 许可证协议开放了源代码。这吸引了很多小伙伴纷纷转投 Jekyll 和 H2O 主题的阵营，本人也是其中之一。随着使用者越来越多，不少的小伙伴在使用过程中发现了一些小问题并主动修复，最后贡献到了 H2O 的主项目，这让 H2O 主题变得更好。本人在使用过程中也的确是发现了一些与自己实际需求不大一致的地方，并且在原 H2O 主题的基础上做了一些改动。考虑到这些改动可能并不是大多数人的需求，直接向原 H2O 主题提交 pull 请求合并的必要性不大，因此决定将原项目 fork 并改名为 <a href="https://github.com/zhonger/jekyll-theme-H2O-ac">zhonger/jekyll-theme-H2O-ac</a>。现正式将源代码以与 H2O 主题相同的 MIT 许可证协议在 Github 平台上公开。</p>

<p>  在此，非常感谢廖柯宇及其他小伙伴对于 H2O-ac 主题的基础主题 H2O 的代码开发和开放共享。</p>

<h2 id="新特性">新特性</h2>

<h3 id="更适合学术人和运维程序员的页面结构">更适合学术人和运维程序员的页面结构</h3>

<p>  H2O 主题其实在很大程度上已经满足了大部分人的需求，只是对于学术研究人员和运维程序员来说，个人觉得页面结构还是有点不够合适。学术研究人员比较重视在首页直接展示个人信息和研究情况，能够让人很快地了解到所需的信息，这其实是将 About me 这样一个平常的辅助页面当成了主页面来用。另外，运维程序员比较重视能一览所有文章的标题以迅速找到感兴趣的文章。虽然搜索功能、标签页、卡片展示页都能够列出所有的文章，但个人觉得还是不够简洁、方便。而像 Hexo 静态生成工具自带的 Archive 归档页面比较能满足这样的需求。除此之外，整个博客的系统日志变迁记录对于运维程序员来说也非常重要，毕竟如果通过发布一篇文章来描述变迁过程并不适合联系起来完整了解。如果有系统日志页，就可以按照年份、月份、事件的先后进行简要的描述，并且一览无遗。</p>

<p>  因此，在 H2O-ac 主题中，从原来 H2O 的主页中抽出框架做成了页面模板。根据实际页面的内容需求，增加了<strong>学术首页</strong>、<strong>归档页</strong>和<strong>系统日志页</strong>。</p>

<h4 id="学术首页">学术首页</h4>

<p>  学术首页如下图所示，并将原来 H2O 中的卡片首页移动到 blog 子目录下了。如果读者想要看到文章卡片展示页，还是可以点击顶部的导航栏中的 BLOG 直接访问。</p>

<p><img src="https://i.vgy.me/pICzcE.png" alt="首页 Home" /></p>

<h4 id="归档页">归档页</h4>

<p>  归档页设置为由 Jekyll 按照模板自动生成，以年份、日期、文章标题分级列表展示，简洁清晰。</p>

<p><img src="https://i.vgy.me/25IZzc.png" alt="归档页 Archives" /></p>

<h4 id="系统日志页">系统日志页</h4>

<p>  系统日志页其实也不是经常更新的，只有在博客整体作出设置或改进的才加以说明。另外，也可以将一些固定的站点信息放置在系统日志页，比如站点的多点部署信息，读者可以根据此信息访问最快、最合适的节点。</p>

<p><img src="https://i.vgy.me/tUCNEb.png" alt="系统日志 Log" /></p>

<h3 id="使用体验提升">使用体验提升</h3>

<p>  廖柯宇也在 H2O 主题的默认页面中写道，目前 H2O 主题还有一些可优化的内容，比如夜间模式、查看大图等。这里，根据个人的一些实际需求和了解，在 H2O-ac 主题中做了调整。</p>

<h4 id="社交图标扩展">社交图标扩展</h4>

<p>  H2O 原有的社交图标其实已经比较广泛，只是还有些领域局限性，比如学术研究人员可能更希望展示谷歌学术、ResearchGate、ORCID 等社交图标及链接，而运维开发人员可能更希望展示 SegmentFault、CSDN、博客园等社交图标及链接。这里在 H2O 提供的社交图标类型基础上做了这些平台图标的扩充，同时尝试了 Symbol 引用的方式来实现社交图标鼠标悬停的效果，从而简化代码（H2O 采用的是字体图标的方式，需要为每一个社交图标定义不同的主题色）。</p>

<p><img src="https://i.vgy.me/ebCeqM.png" alt="社交图标 SNS" /></p>

<h4 id="查看大图">查看大图</h4>

<p>  查看大图功能的确对于读者的阅读体验来说有很大的提升。就像我们阅读文献一样，可能首先会只看文章附图来大致掌握文章的核心点。博文的查看大图功能也可能有这样的异曲同工之妙。这里是采用的 <a href="https://fancyapps.com/docs/ui/fancybox">Fancybox</a> 插件实现的。H2O-ac 主题中只使用了最简单的配置，用户可以根据需求查看文档做出更多的修改。</p>

<p><img src="https://i.vgy.me/FNRDTv.png" alt="查看大图 Fancybox" /></p>

<p>(2022年4月30日更新)</p>

<p>  ，由于 fancybox 库作者对原使用的 v3.5.7 版本不再进行维护和更新，现将版本更新至新的 v4.0 版本，即 <a href="https://github.com/fancyapps/ui">fancyapps/ui</a>。另，新增将 alt 内容作为图片的描述显示在 fancybox 中。</p>

<h4 id="深色模式切换按钮">深色模式切换按钮</h4>

<p>(2022年4月30日更新)</p>

<p>  原来 H2O 主题的深色模式切换需要在 _config.yml 文件中配置开启，并且只能在固定时间段使用。此次更新在页面右上角提供了深色/浅色模式一键切换按钮，如下图所示。由于更新了深色模式采用 cookie 的方式来确定，此深色模式切换按钮可以与原来的深色模式配置共存。</p>

<p><img src="https://i.vgy.me/x1CWVs.png" alt="浅色模式 Day mode" /></p>

<p><img src="https://i.vgy.me/8DGFx2.png" alt="深色模式 Night mode" /></p>

<h4 id="提示框">提示框</h4>

<p>(2022年4月30日更新)</p>

<p>  通过引入 <a href="https://github.com/lazee/premonition">lazee/premonition</a> 库新增五种提示框：笔记、提示、警告、错误、引用，完全兼容原生 Markdown 语法，并对样式进行了主题适应。以下为五种提示框的实际效果。</p>

<div class="premonition note"> <div class="header"> <svg class="icon note" aria-hidden="true"> <use xlink:href="#icon-note"></use> </svg> <div class="title"> Note </div> </div> <div class="content"> <p>The body of the note goes here. Premonition allows you to write any <code class="language-plaintext highlighter-rouge">Markdown</code> inside the block.</p>



 </div> </div>
<div class="premonition info"> <div class="header"> <svg class="icon info" aria-hidden="true"> <use xlink:href="#icon-info"></use> </svg> <div class="title"> 小提示 </div> </div> <div class="content"> <p>The body of the info goes here. Premonition allows you to write any <code class="language-plaintext highlighter-rouge">Markdown</code> inside the block.</p>



 </div> </div>
<div class="premonition warning"> <div class="header"> <svg class="icon warning" aria-hidden="true"> <use xlink:href="#icon-warning"></use> </svg> <div class="title"> Warning </div> </div> <div class="content"> <p>The body of the warning goes here. Premonition allows you to write any <code class="language-plaintext highlighter-rouge">Markdown</code> inside the block.</p>



 </div> </div>
<div class="premonition error"> <div class="header"> <svg class="icon error" aria-hidden="true"> <use xlink:href="#icon-error"></use> </svg> <div class="title"> Error </div> </div> <div class="content"> <p>The body of the error goes here. Premonition allows you to write any <code class="language-plaintext highlighter-rouge">Markdown</code> inside the block.</p>



 </div> </div>
<div class="premonition citation"> <div class="header"> <svg class="icon citation" aria-hidden="true"> <use xlink:href="#icon-citation"></use> </svg> </div> <div class="content"> <p>To be or not to be is a question.</p>



 </div> <div class="ref"> ------ 莎士比亚 </div> </div>
<h4 id="代码高亮优化">代码高亮优化</h4>

<p>  本人使用 H2O 主题的时候代码高亮功能还是沿用的 Jekyll 自带的，后来 H2O 主题也开始采用了 <a href="https://prismjs.com/">Prism.js</a>。不过由于使用的是 <code class="language-plaintext highlighter-rouge">OKAIDIA</code> 高亮主题，所以有些段落中的格式化字段显示上有些问题。这里，仍然采用默认主题，并且扩增到 Prism.js 支持的所有编程语言类型。效果可以从前一句的 OKAIDIA 字段和下面即将出现的代码片段看出。</p>

<h4 id="字数统计及阅读时间估计">字数统计及阅读时间估计</h4>

<p>  字数统计及阅读时间估计这个小功能其实以前在用 WordPress 的时候比较常见。虽然说统计和估计的结果不一定完全准确，但是还是起到了一定的辅助阅读的作用。效果可以查看本页标题下的基本信息区域。</p>

<h4 id="文章侧边索引导航">文章侧边索引导航</h4>

<p>(2022年1月9日更新)</p>

<p>  在一些基于 Bootstrap 前端框架的 Jekyll 主题中，这个功能比较常见。由于本主题未使用 Bootstrap 前端框架，所以添加起来稍微有些麻烦，现已增加此功能。在浏览器窗口超过 1050 px 的情况下，在文章页面可以正常看到右侧的文章侧边索引导航。当窗口滑动时，侧边索引导航也会跟着滑动。在浏览器窗口不足 1050 px 的情况下，侧边索引导航自动隐藏。在 _config.yml 配置文件中，可以通过设置 <code class="language-plaintext highlighter-rouge">toc: false</code> 来全局禁用此功能。</p>

<p>(2022年4月30日更新)</p>

<p>  在原来的基础上增加了跟随左侧内容滑动高亮。当左侧内容向上或向下滑动时，右侧索引导航将会使对应的对应一级标题高亮。</p>

<h4 id="配置项">配置项</h4>

<p>  配置项中新增了<strong>友情链接</strong>、<strong>备案号</strong>、<strong>Google Analytics</strong> 和 <strong>CNZZ</strong> 统计功能，可以直接在 _config.yml 文件的对应配置项下设置即可，如下所示。友情链接主要是方便跟其他博主交换友链，备案号主要是为了方便部署在国内需备案的 vps 或虚拟主机上。此处，二者都可以置空。</p>

<p>(2022年4月30日更新)</p>

<p>  新增全站一键灰度化功能、时间格式配置。在国家公祭日等需要灰度化以示哀悼的时候可以将灰度化配置设置为 true，平常使用默认配置 false。时间格式这里一共提供了 3 种：第一种中英文站点使用皆宜，第二种适用于英文站点，第三种适用于中文站点。默认时间格式为第一种。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Links 友情链接</span>
<span class="na">links</span><span class="pi">:</span>
  <span class="s1">'</span><span class="s">Mr</span><span class="nv"> </span><span class="s">Li'</span><span class="err">:</span> <span class="s1">'</span><span class="s">https://lisz.me'</span>

<span class="c1"># Beian 备案号</span>
<span class="na">beian</span><span class="pi">:</span> <span class="s1">'</span><span class="s">沪ICP备xxxxxxxx号'</span>

<span class="c1"># Gray 灰度化</span>
<span class="na">gray</span><span class="pi">:</span> <span class="no">true</span>

<span class="c1"># Time format 时间格式 </span>
<span class="c1"># 0 -- 2022-04-29    1 -- 29 Apr 2022   2 -- 2022年4月29日</span>
<span class="na">formats</span><span class="pi">:</span>
  <span class="na">time</span><span class="pi">:</span> <span class="s">0</span> 

<span class="c1"># CNZZ 统计代码</span>
<span class="na">cnzz</span><span class="pi">:</span>

<span class="c1"># Google Analytics</span>
<span class="na">google_analytics</span><span class="pi">:</span>
</code></pre></div></div>

<h4 id="前端自动构建工作流优化">前端自动构建工作流优化</h4>

<p>  H2O 主题中使用了 Gulp + Node-Sass 的方案来自动化前端构建工作流。不得不说，这个方案还是很不错的，只是随着 Gulp 和 Node-Sass 版本的更新，对 NodeJS 环境及其他依赖库都有一些要求。这里，H2O-ac 主题在 package.json 文件中将所有库都更新到目前最新，对应版本列表如下所示。另外，为了减少一些第三方 CSS 样式的请求数，利用自动构建工作流将固定的第三方 CSS 样式文件合并并压缩为 plugins.min.css 文件。app.min.css 仍为多个自编写 CSS 样式文件的合并压缩。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">运行环境或依赖库</th>
      <th style="text-align: center">版本号</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">NodeJS</td>
      <td style="text-align: center">v17.0.0</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp</td>
      <td style="text-align: center">v4.0.2</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-clean-css</td>
      <td style="text-align: center">v4.3.0</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-rename</td>
      <td style="text-align: center">v20.0</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-sass</td>
      <td style="text-align: center">v5.0.0</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-uglify</td>
      <td style="text-align: center">v3.0.2</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-concat</td>
      <td style="text-align: center">v2.6.1</td>
    </tr>
    <tr>
      <td style="text-align: center">node-sass</td>
      <td style="text-align: center">v7.0.0</td>
    </tr>
  </tbody>
</table>

<h2 id="使用方法">使用方法</h2>

<h3 id="初始化">初始化</h3>

<h4 id="方式一从模板新建博客">方式一：从模板新建博客</h4>

<p>  为了方便用户使用 H2O-ac 主题，特别提供了 Github 的模板功能。如下图所示，访问 <a href="https://github.com/zhonger/jekyll-theme-H2O-ac">H2O-ac</a> 可以看到如下的 Use this template 按钮，点击该按钮即可用 H2O-ac 主题创建自己的博客代码仓库。想要了解更多步骤，可以访问 Github 官方文档之 <a href="https://docs.github.com/cn/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template">从模板创建仓库</a>。</p>

<p><img src="https://i.vgy.me/y7lv2Q.png" alt="从模板新建 Start the blog from the template" /></p>

<h4 id="方式二已有博客迁移">方式二：已有博客迁移</h4>

<p>  <del>暂时无法支持 gem 直接切换主题，后续将更新此方式。目前只能使用方式一创建仓库后，将文章的 markdown 文件复制到 _posts 目录下应用 H2O-ac 主题。</del></p>

<p>(2021年12月26日更新)</p>

<p>  现已支持使用 gem 直接切换主题 <code class="language-plaintext highlighter-rouge">jekyll-theme-h2o-ac</code>。同时，也推出了一键式构建工具 <a href="https://github.com/zhonger/easy-to-h2o-ac">easy-to-h2o-ac</a>，详细可以见项目主页。</p>

<h3 id="本地测试">本地测试</h3>

<p>  在进行本地测试时，如果需要修改一些样式，则需要先执行 <code class="language-plaintext highlighter-rouge">npm install</code> 来完成前端自动构建工作流依赖库的安装。注意，这里设定的可用 NodeJS 版本为 v17.0.0，使用老版本会报错。其次，务必使用 <code class="language-plaintext highlighter-rouge">bundle install</code> 安装主题所需的所有 Ruby 依赖库。最后执行 <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve --livereload</code> 命令即可在本地实时同步预览。只要不修改 _config.yml 文件，不必中断后再启动。然后就是在 _posts 目录下写 markdown 文章即可。</p>

<h3 id="发布部署">发布部署</h3>

<p>  由于 Github 提供 Jekyll 静态生成器的静态页面托管，只要打开仓库的 Pages 功能，当推送更新到 Github 时即会自动部署。此处值得注意的是，如果代码仓库的名字不是 <code class="language-plaintext highlighter-rouge">username.github.io</code>，而也没有为该仓库的 Pages 提供自定义域名，那么这个仓库将会被部署到子目录，因此此时必须在 _config.yml 文件中设置 base_url，从而生成正常的静态页面。</p>

<h2 id="结束语">结束语</h2>

<p>  再次感谢廖柯宇及其他小伙伴们对 H2O 主题的付出，没有 H2O 主题就没有 H2O-ac 主题！H2O-ac 主题后续也将继续更新，欢迎小伙伴们使用和 <a href="https://github.com/zhonger/jekyll-theme-H2O-ac">Star</a>，也欢迎大家一起来贡献代码。</p>

<p>（Ps: <del>由于沿用了 H2O 的 Logo，可能会侵犯廖柯宇的版权。如果的确如此，后续将会设计一个新的 Logo。</del> 已采用新 Logo。）（2022年1月10日更新）</p>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="jekyll" /><category term="theme" /><category term="blog" /><category term="ac" /><category term="develop" /><category term="主题" /><category term="前端开发" /><category term="学术" /><category term="运维" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">Jekyll 社交图标集合创建</title><link href="https://lisz.me/tech/webmaster/jekyll-sns-icons.html" rel="alternate" type="text/html" title="Jekyll 社交图标集合创建" /><published>2021-12-22T11:30:00+09:00</published><updated>2021-12-22T11:30:00+09:00</updated><id>https://lisz.me/tech/webmaster/jekyll-sns-icons</id><content type="html" xml:base="https://lisz.me/tech/webmaster/jekyll-sns-icons.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  一般来说，我们的个人博客都会放上一些社交图标以及社交链接。这样一来，想要关注我们更多的最新研究或工作的读者就可以很快找到路径。于是，在 Jekyll 博客主题设计的时候，通常会在个人简介的地方放置几个社交小图标，点击社交小图标即可把读者带到你的社交个人主页上。对于不同类型的作者，常用的或者关注的社交平台基本上不大一样，社交小图标也会有不一样的需求。比如说，对于从事科研工作的人来说，像谷歌学术、ResearchGate、ORCID 等等能够列举发表论文或者相关研究的平台就比较重要；对于一般程序员来说，像 Github、Gitlab、Segmentfault、CSDN、简书等等能够展示自己所参与的项目和技术心得体会的平台就比较重要；对于前端设计师来说，像 Instgram、UI 中国、Dribble等等能够展示 UI 设计作品的平台就比较重要。因此，对于一款 Jekyll 博客主题的设计者来说，同时要兼顾到这么多不同的需求可能会有点为难，毕竟领域不同、了解的程度也很有限。</p>

<p>  俗话说得好，授人以鱼不如授人以渔。今天我们就来讲讲如何自己定制一套社交图标集合。</p>

<h2 id="技术发展回顾">技术发展回顾</h2>

<h3 id="图片索引">图片索引</h3>

<p>  对网站前端设计有点了解的小伙伴可能知道，如果要为网站添加一些社交图标，并且支持鼠标悬停高亮显示，最早的办法是采用不同的图片进行切换的方法。具体来说就是，鼠标悬停前是一张图片，悬停后切换到另外一张图片。由于如果要支持很多个社交图标就要准备很多对这样的图片，那么同一页面内的文件 HTTP 请求数就会陡然增加，对页面加载性能有非常大的影响。</p>

<p>  随之产生了一种比较可行的解决方案：将所有的社交图片拼在一张图上，然后通过定位的方式来索引到不同的社交图标，我们通常将这张图称为<strong>雪碧图</strong>。这种方法的好处比较明显，浏览器只需要发出一次请求下载雪碧图即可，减少了文件 HTTP 请求数，加载时间显著变短。比较明显的困难是，定位找起来简直不要太麻烦。而且为了能描述不同的图标悬停前后的位置，必须写很多对样式与之对应，工作量比较大。另外一个比较大的困难是，图标集合的更新很麻烦。新增图标的时候，为了能沿用原来已经写好的样式，只能在原有的雪碧图的基础上往后增加图标，当然同时也要增加对应的样式。</p>

<p>  虽然雪碧图在某种程度上提升了加载效率，但是给后期的更新、维护带来了不小的麻烦。还有一个越来越凸显的问题——随着访问网站的设备类型的不断增多，图片的质量会影响到不同设备、不同平台下的效果一致性，甚至在高分辨率屏幕下会出现图标模糊的情况，用户体验极其不佳。最有效的改进方法可能就是采用分辨率更高、质量更高的图片来拼凑雪碧图，不过同时也会增大雪碧图的文件体积。这会导致虽然只发出了一个文件 HTTP 加载请求，但是由于文件体积过大、加载速度慢，而给用户带来不好的使用体验。</p>

<h3 id="字体图标">字体图标</h3>

<p>  接着发展出了一种<strong>字体图标</strong>的东西来解决图片索引中存在的问题。字体图标，顾名思义就是把所有的图标都变成了字体编码一样，只要我们在网页中引入字体图标文件就可以像用 Unicode 一样使用字体图标了。这种方式最好的一点就是，像操纵字体一样设置字体图标的样式。比如说，虽然我们只在字体图标文件中定义了一个图标，但是当我们使用不同的 color 定义时，图标就会改变其颜色。而且，我们操纵字体图标的大小是采用 font-size 的方式而非 width/height 的方式。这样一来，字体图标和行内文字段落一起使用时也是非常匹配的，行距等文字样式都能同等适用。</p>

<p>  当然，字体图标在后期的维护、更新过程中也会有些问题。比如说，对于一个大型项目的迭代开发，每个子系统可能都会弄一套需要的字体图标，然后在代码分支合并时就会出现问题。因此，有些项目团队可能会为此而设定一位管理员来专门管理字体图标的更新。每个子系统只能向图标管理员提交他们的更新，最终更新由图标管理员来完成。虽然这样也能在某种程度上解决问题，但是对于图标管理员来说还是会很苦恼。</p>

<p>  说到这里，有人可能会想起 Bootstrap 等 UI 框架中自带的字体图标集合。那我们直接使用某个框架提供的字体图标集合不就万事大吉了吗？可事实并非如此，框架所包含的字体图标集合虽然看起来还是比较全面，但是还是有可能缺少某些我们想要的字体图标。想到这里，可能会想不如把多个字体图标集合整合在一起使用不就好了吗？这样随之而来的问题是，很大可能存在大量冗余。对于前端界面来说，除了大量的 HTTP 请求是无法接受的，大量冗余代码也是无法接受的。当我们用 <a href="https://web.dev/measure/">Lighthouse</a> 类似的工具来测试网页的性能时，就可以很容易地发现请求代码的使用率情况。如果我们采用多个字体图标集合并用的方案，那么代码实际使用率可能就会很低。也就是说，请求的代码基本上不会在网页中被使用到，这对于优化页面性能来说简直就是噩梦。</p>

<p>  如果我们觉得自己来手动管理、手动更新字体图标文件太麻烦了，其实也可以用阿里的 <a href="https://www.iconfont.cn">Iconfont</a> 或者其他类似工具来在线管理字体图标集合。Iconfont 会提供一个阿里 CDN 上的链接地址来直接使用你建立好的字体图标集合，这样一来基本上就解决了上面所说的维护难题。我们在 Iconfont 上更新好字体图标集合后，Iconfont 会生成一个新的链接地址。然后，我们只需要修改页面代码的对应地址就可以非常方便地应用更新。</p>

<p>  这么看来，字体图标的方案好像很完美了，但事实上还是存在其他的问题。Iconfont 这类平台比较适合个人开发者或者开源项目，而对于企业开发者或者非开源项目来说可能依然不大适合。另外，字体图标因为像字体一样被操纵，所以只能支持一种颜色，无法同时支持多种颜色。除此之外，如果我们想要预览所有的图标，但是抱歉的是脱离了 Iconfont 这类平台我们可能就没有办法做到。</p>

<h3 id="symbol-图标">Symbol 图标</h3>

<p>  实际上除了字体图标在不同设备、不同平台上有相同的效果之外，SVG 图标也具有类似的效果，这主要是因为 SVG 图标的矢量本质，即缩放不会产生任何失真。SVG 图标还支持多种颜色、可以通过字体样式调整样式，并且支持 IE9 以上版本的浏览器。（随着时代的进步，IE 其实已经不是最新的 Windows 11 操作系统默认软件之一了，而且微软也不再提供 IE 安装包下载了，所以未来 IE 浏览器可能不会出现在考虑支持列表里。）为了能够创建一个 SVG 图标集合，我们可以使用 <code class="language-plaintext highlighter-rouge">symbol</code> 元素来定义一个图形模板对象，然后用一个 <code class="language-plaintext highlighter-rouge">&lt;use&gt;</code> 元素实例化。<code class="language-plaintext highlighter-rouge">symbol</code> 元素对图形的作用是在同一文档中多次使用，添加结构和语义。结构丰富的文档可以更生动地呈现出来，类似讲演稿或盲文，从而提升了可访问性。值得注意的是，一个 <code class="language-plaintext highlighter-rouge">symbol</code> 元素本身是不会呈现的，只有当 <code class="language-plaintext highlighter-rouge">symbol</code> 元素的实例（即，一个引用了 <code class="language-plaintext highlighter-rouge">symbol</code> 的 <code class="language-plaintext highlighter-rouge">&lt;use&gt;</code> 元素）才能呈现。</p>

<p>  如下代码所示，是一个 <code class="language-plaintext highlighter-rouge">symbol</code> 图标的例子。其中，<code class="language-plaintext highlighter-rouge">symbol</code> 元素定义了两个圆圈，对应信息如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">圆的编号</th>
      <th style="text-align: center">位置</th>
      <th style="text-align: center">半径</th>
      <th style="text-align: center">填充色</th>
      <th style="text-align: center">描边宽度</th>
      <th style="text-align: center">描边颜色</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">(50, 50)</td>
      <td style="text-align: center">40</td>
      <td style="text-align: center">红色</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">红色</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">(90, 60)</td>
      <td style="text-align: center">40</td>
      <td style="text-align: center">白色</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">绿色</td>
    </tr>
  </tbody>
</table>

<p>实例化了三个 <code class="language-plaintext highlighter-rouge">symbol</code> 元素，分别为：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">实例编号</th>
      <th style="text-align: center">位置</th>
      <th style="text-align: center">宽度</th>
      <th style="text-align: center">高度</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">(0, 0)</td>
      <td style="text-align: center">100</td>
      <td style="text-align: center">50</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">(0, 50)</td>
      <td style="text-align: center">75</td>
      <td style="text-align: center">38</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">(0, 100)</td>
      <td style="text-align: center">50</td>
      <td style="text-align: center">25</td>
    </tr>
  </tbody>
</table>

<pre><code class="language-svg">&lt;svg&gt;
&lt;!-- symbol definition  NEVER draw --&gt;
&lt;symbol id="sym01" viewBox="0 0 150 110"&gt;
  &lt;circle cx="50" cy="50" r="40" stroke-width="8" stroke="red" fill="red"/&gt;
  &lt;circle cx="90" cy="60" r="40" stroke-width="8" stroke="green" fill="white"/&gt;
&lt;/symbol&gt;

&lt;!-- actual drawing by "use" element --&gt;
&lt;use xlink:href="#sym01"
     x="0" y="0" width="100" height="50"/&gt;
&lt;use xlink:href="#sym01"
     x="0" y="50" width="75" height="38"/&gt;
&lt;use xlink:href="#sym01"
     x="0" y="100" width="50" height="25"/&gt;
&lt;/svg&gt;
</code></pre>
<p>效果如下所示：</p>

<p><img src="https://i.vgy.me/eTsY1a.png" alt="vgy.me" /></p>

<h2 id="创建自定义社交图标集合">创建自定义社交图标集合</h2>

<p>  现在让我们来尝试一下借助 Iconfont 来创建自定义的社交图标集合吧。首先访问 <a href="https://www.iconfont.cn">Iconfont 首页</a> 并使用 Github 账户或者其他方式登录好。然后在搜索框中输入 github 查询平台所有开放的相关图标，点击即可加入购物车。</p>

<p><img src="https://i.vgy.me/RkgKa1.png" alt="vgy.me" /></p>

<p>  接着点击右上角的购物车按钮如下所示可以查看已加入到购物车的所有图标，并点击<strong>添加到项目</strong>。</p>

<p><img src="https://i.vgy.me/QHdhi5.png" alt="vgy.me" /></p>

<p>  然后给项目取名（这里的名字随便起），点击<strong>确认</strong>按钮完成项目添加，自动跳转到项目页。</p>

<p><img src="https://i.vgy.me/dymDV8.png" alt="vgy.me" /></p>

<p>  点击生成代码即可生成专属链接，并出现<strong>点击复制代码</strong>按钮。</p>

<p><img src="https://i.vgy.me/NNSsLJ.png" alt="vgy.me" /></p>

<p>  点击<strong>收起在线链接</strong>旁边的下箭头可以看到<strong>预览字体</strong>，点击<strong>预览字体</strong>即跳转到在线预览页面，如下所示。</p>

<p><img src="https://i.vgy.me/tKwaPx.png" alt="vgy.me" /></p>

<p>  这里提供了三种方式来使用创建好的社交图标集合，目前平台推荐的是<strong>Symbol 引用</strong>方式。接着即可按照以下三个步骤在你的网页上轻松使用自定义好的社交图标集合了。</p>

<p><img src="https://i.vgy.me/7C7G0A.png" alt="vgy.me" /></p>

<h3 id="小提示">小提示</h3>

<p>  如果想要实现鼠标悬停图标高亮的效果，还需要自己修改一下 CSS 样式，如下所示。这里采用了灰度遮罩滤镜的方式，给原来彩色的图标灰度化了。当鼠标悬停时，灰度化效果被移除，并且有 0.2 s 的缓慢过渡。不过如果原来的图标是黑色的话，灰度化的效果可能就比较差，悬停前后的差异不大明显，所以推荐使用彩色社交图标。Iconfont 平台实际上提供了在线编辑修改颜色的功能，如果想要知道某个图标或者品牌的主题颜色可以访问 <a href="https://www.schemecolor.com/">Schemecolor</a> 来查询。</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.icon</span> <span class="p">{</span>
    <span class="nl">width</span><span class="p">:</span> <span class="m">1em</span><span class="p">;</span>
    <span class="nl">height</span><span class="p">:</span> <span class="m">1em</span><span class="p">;</span>
    <span class="nl">vertical-align</span><span class="p">:</span> <span class="m">-0.15em</span><span class="p">;</span>
    <span class="py">fill</span><span class="p">:</span> <span class="n">currentColor</span><span class="p">;</span>
    <span class="nl">overflow</span><span class="p">:</span> <span class="nb">hidden</span><span class="p">;</span>
    <span class="nl">filter</span><span class="p">:</span> <span class="n">grayscale</span><span class="p">(</span><span class="m">100%</span><span class="p">);</span>
    <span class="nl">-webkit-filter</span><span class="p">:</span> <span class="n">grayscale</span><span class="p">(</span><span class="m">100%</span><span class="p">);</span>
    <span class="nl">-moz-filter</span><span class="p">:</span> <span class="n">grayscale</span><span class="p">(</span><span class="m">100%</span><span class="p">);</span>
    <span class="nl">-ms-filter</span><span class="p">:</span> <span class="n">grayscale</span><span class="p">(</span><span class="m">100%</span><span class="p">);</span>
    <span class="nl">-o-filter</span><span class="p">:</span> <span class="n">grayscale</span><span class="p">(</span><span class="m">100%</span><span class="p">);</span>
    <span class="nl">transition</span><span class="p">:</span> <span class="m">.2s</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.icon</span><span class="nd">:hover</span> <span class="p">{</span>
    <span class="nl">filter</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
    <span class="nl">-webkit-filter</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
    <span class="nl">-moz-filter</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
    <span class="nl">-ms-filter</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
    <span class="nl">-o-filter</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/symbol">symbol - SVG | MDN</a></li>
  <li><a href="https://blog.csdn.net/jys1216/article/details/8852158">使网站首页变灰色，遮罩滤镜</a></li>
  <li><a href="https://juejin.cn/post/6844904162442870792">还在用字体图标吗，试试svg图标吧(内附vuecli-svg-sprite-loader插件)</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Jekyll" /><category term="主题" /><category term="theme" /><category term="社交图标" /><category term="sns" /><category term="icons" /><category term="Iconfont" /><summary type="html"><![CDATA[前言]]></summary></entry></feed>