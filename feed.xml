<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="https://lisz.me/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lisz.me/" rel="alternate" type="text/html" /><updated>2022-01-11T04:18:56+09:00</updated><id>https://lisz.me/feed.xml</id><title type="html">Mr Li</title><subtitle>个人的一个技术博客站点，主要用于记录个人在学习过程中遇到的技术问题及解决方法、技术实验，以及一些比较有趣的事情。</subtitle><author><name>zhonger</name></author><entry><title type="html">[译文]迭代机器学习：迈向模型准确性的一步</title><link href="https://lisz.me/ac/ml/iterative-learning.html" rel="alternate" type="text/html" title="[译文]迭代机器学习：迈向模型准确性的一步" /><published>2022-01-05T20:30:00+09:00</published><updated>2022-01-05T20:30:00+09:00</updated><id>https://lisz.me/ac/ml/iterative-learning</id><content type="html" xml:base="https://lisz.me/ac/ml/iterative-learning.html"><![CDATA[<p><strong>原文标题</strong>：<a href="https://hub.packtpub.com/iterative-machine-learning-step-towards-model-accuracy/">Iterative Machine Learning: A step towards Model Accuracy</a><br />
<strong>原文作者</strong>：Amarabha Benerjee</p>

<p>  通过死记硬背来学习一些东西，比如重复多次，通过一遍又一遍地练习来完善一项技能，或者通过逐步对原型进行细微调整来构建某些东西，这些都是我们人类自然而然发生的事情。机器也可以学习这种方式，这被称为“迭代机器学习”。在大多数情况下，迭代是一种有效的学习方法，有助于更快、更准确地达到预期的最终结果，而不会成为资源紧缩的噩梦。</p>

<p>  现在，你可能会想，迭代本身不就是任何机器学习的一部分吗？换句话说，从基础的回归分析、决策树、贝叶斯网络到高级的神经网络和深度学习算法，现代机器学习技术都内置了一些固有的迭代组件。那么，将迭代学习作为一个独立的主题来讨论的必要性是什么呢？这仅仅是因为将迭代外部引入到算法可以最大限度地减少误差范围，从而有助于准确建模。</p>

<h2 id="迭代学习是如何工作的">迭代学习是如何工作的</h2>

<p>  让我们仔细观察机器学习算法中单个迭代流期间发生的情况来了解迭代的原理。</p>

<p>  首先将预处理的训练数据集引入到模型中。在对给定的数据进行处理和构建模型后，对模型进行测试，然后将结果与所期待的输出进行匹配。然后将反馈返回给系统，以便算法那进一步学习和微调其结果。这清楚地表明，这里发生了两个迭代过程：</p>

<ol>
  <li>数据迭代——算法固有的</li>
  <li>模型训练迭代——外部引入</li>
</ol>

<p><img src="https://i.vgy.me/mYccJd.png" alt="vgy.me" /></p>

<p>  现在，如果我们没有将结果反馈到系统中，比如说不允许算法迭代学习，而是采用顺序方法，情况会变成怎么呢？算法是否有效，能否提供正确的结果呢？</p>

<p>  是的，算法肯定会起作用。但是，它产生的结果的质量将会因为许多因素而有很大的差异。训练数据集的质量和数量、所采用的特征定义和特征抽取技术、算法本身的鲁棒性等都是许多因素之一。即使上述所有工作都做得完美，仍然不能保证顺序方法产生的结果将非常准确。简而言之，结果既不准确，也不可重复。因此，迭代学习允许算法提高模型准确性。</p>

<p>  某些算法在设计中具有迭代核心，可以根据数据量的多少进行缩放。这些算法处于机器学习实现的最前沿，因为它们能够更快更好地执行。在接下来的部分，我们将讨论来自三种主要机器学习方法的不同算法类别的迭代——<strong>有监督机器学习</strong>、<strong>无监督机器学习</strong>和<strong>强化学习</strong>。</p>

<h2 id="提升算法有监督机器学习中的迭代">提升算法：有监督机器学习中的迭代</h2>

<p>  提升算法本质上是迭代的，是通过最小化错误来改善结果的最佳方式。它们主要旨在减少结果中的偏差，并将一组特定的弱学习分类器算法转换为强学习器，从而使它们能够减少错误。以下是一些示例：</p>
<ul>
  <li>AdaBoost（Adaptive Boosting）</li>
  <li>梯度提升树（Gradient Tree Boosting）</li>
  <li>XGBoost</li>
</ul>

<h3 id="它们是如何工作的">它们是如何工作的</h3>

<p>  所有的提升算法都有一个通用的分类器，这些分类器经过迭代修改以达到想要的结果。让我们以“在某篇文章中找抄袭案例”为例。这里的第一个分类器是找到一组单词，这些单词出现在其他地方或者另一篇文章中，这将导致一个红色信号。如果我们创建 10 个单独的单词组，并将它们称为分类器 1 到 10，那么我们将根据这些分类器检查我们的文章，并且任何可能的匹配都将会标记为红色。但是，这 10 个分类器没有任何红色信号并不意味着一个肯定的 100% 原创文章。因此，我们需要更新分类器，创建可能基于第一次通过的更短的组，从而提高分类器发现这篇文章与其他文章的相似性的准确性。Boosting 算法中的这个迭代过程最终使我们获得了相当高的准确率。原因是在每次迭代之后，分类器都会根据其性能进行更新。与其他内容非常相似的内容将进行更新和调整，以便我们可以获得更好的匹配。这种本质上改进算法的过程被称为提升，目前是有监督机器学习中最流行的方法之一。</p>

<h3 id="优缺点">优缺点</h3>

<p>  这种方法的明显优点是，它允许在最终模型中出现最小的错误，因为迭代模型能够在每次出现错误时自行纠正。缺点是处理时间较长，并且大量迭代对总体内存的要求较高。另一个重要方面是，反馈给训练模型的错误是在外部完成的，这意味着监督者可以控制模型及其修改方式。这反过来又有一个缺点，即模型无法学会自行消除错误。因此，该模型不能用于另一组数据。换句话说，模型不会自己学习如何变得无差错，因此不能移植到另一个数据集上，因为它需要从头开始学习过程。</p>

<h2 id="人工神经网络无监督机器学习中的迭代">人工神经网络：无监督机器学习中的迭代</h2>

<p>  神经网络已经成为无监督机器学习的典型代表，因为它们在预测数据模型方面的准确性。一些众所周知的神经网络有：</p>
<ul>
  <li>卷积神经网络（Convolutional Neural Networks，CNNs）</li>
  <li>玻尔兹曼机（Boltzman Machines，BMs）</li>
  <li>循环神经网络（Recurrent Neural Networks，RNNs）</li>
  <li>深度神经网络（Deep Neural Networks，DNNs）</li>
  <li>记忆网络（Memory Networks，MNs）</li>
</ul>

<h3 id="它们是如何工作的-1">它们是如何工作的</h3>

<p>  人工神经网络在模拟数据模型方面非常准确，主要是因为它们的迭代学习过程。但这个过程与我们之前探索的 Boosting 算法的过程不同。在这里，这个过程是无缝和自然的，在某种程度上，它为人工智能系统中的强化学习铺平了道路。</p>

<p>  神经网络由模拟人脑工作方式的电子网络组成。每个网络都有一个输入和输出节点，以及由算法组成的中间隐藏层。输入节点被赋予初始数据集以执行一系列的操作，并且每次迭代都会创建一个数据字符串输出作为结果。然后，这个输出与实际结果数据集进行匹配，并将错误反馈给输入节点。这样一来，这个错误使得算法能够自行纠正，并越来越接近实际数据集。这个过程称为训练神经网络，每次迭代都会提高准确性。与 Boosting 算法执行迭代的方式相比，执行的迭代之间的关键区别在于，这里我们不必手动更新分类器，算法会根据错误反馈自行更改。</p>

<h3 id="优缺点-1">优缺点</h3>

<p>  这个过程的主要优点是它可以达到的准确度。该模型也是可重用的，因为它学习了实现准确性的方法，而不仅仅是为你提供直接的结果。这种方法的另一面是，模型可能会严重出错，并完全偏离不同的方向。这是因为归纳迭代有自己的过程，不需要人工监督。“Facebook 聊天机器人偏离了他们最初的目标，并用自己的语言在他们内部进行交流”就是一个很好的例子。但俗话说，聪明的东西有其自身的问题。如果我们想要创建更准确的模型和更智能的系统，我们必须准备好应对这一风险。</p>

<h2 id="强化学习">强化学习</h2>

<p>  强化学习是机器学习的一个有趣的案例，其中简单的神经网络被连接起来，它们与环境相互作用，从错误和奖励中学习。这里介绍的迭代以复杂的形式发生。迭代以奖励或惩罚的形式发生，分别对应得出正确或错误的结果。在每次这种交互之后，多层神经网络都会合并反馈，然后重新创建模型以提高准确性。典型的奖励和惩罚方法在某种程度上将其置于一个即不是受监督也不是不受监督的空间，但表现出两者的特征，并且还具有产生更准确结果的额外优势。这里的缺点是模型在设计上很复杂。多层神经网络在多次迭代的情况下很难处理，因为每一层可能对某种奖励或惩罚做出不同的反应。因此，它可能产生内部冲突，这些冲突可能导致系统停滞不前——无法决定下一步向哪个方向发展。</p>

<h2 id="迭代的一些实际实现">迭代的一些实际实现</h2>

<p>  许多现代机器学习平台和框架已经实现了自己的迭代过程，从而创建更好的数据模型，Apache Spark 和 MapReduce 就是两个这样的例子。两者实现迭代的方式在技术上是不同的，它们有其优点和局限性。</p>

<p>  让我们来看看 MapReduce。它直接在磁盘上存在的 HDFS 文件系统上读取和写入数据。请注意，从磁盘读取和写入的每个迭代都需要大量的时间。这在某种程度上创建了一个更健壮和容错的系统，但在速度上妥协了。另一方面，Apache Spark 将数据存储在内存（弹性分布式数据集），比如 RAM 中。因此，每次迭代花费的时间要少得多，这使得 Spark 能够执行闪电般的快速数据处理。但是，Spark 执行迭代方式的主要问题是，动态内存或者 RAM 在存储迭代数据和执行复杂操作方面的可靠性远低于磁盘存储。因此，它的容错能力远低于 MapReduce。</p>

<h2 id="将其整合在一起">将其整合在一起</h2>

<p>  为了总结讨论，我们可以大致如下来看一下迭代过程及其实现机器学习模型的阶段：</p>

<p><img src="https://i.vgy.me/4XY4X4.png" alt="vgy.me" /></p>

<ol>
  <li><strong>参数迭代</strong>：这是任何算法迭代的第一个也是固有的阶段。算法涉及到的参数运行多次，并在此过程中最终确定模型的最佳拟合参数。</li>
  <li><strong>数据迭代</strong>：一旦模型参数最终确定之后，将数据放入系统并模拟模型。将多组数据放入系统中，以检查参数在产生想要的结果方面的有效性。因此，如果数据迭代阶段表明某些参数不适合模型，则将它们带回参数迭代阶段，并添加或修改参数。</li>
  <li><strong>模型迭代</strong>：在初始参数和数据集最终确定后，进行模型测试/训练。模型测试阶段的迭代是关于使用相同的参数和数据集多次运行相同的模型模拟，然后检查错误量，如果错误在每次迭代中都有很大变化，则数据或参数或两者都有问题。对数据和参数进行迭代，直到模型达到准确性。</li>
  <li><strong>人工迭代</strong>：此步骤涉及到人工归纳的迭代，其中将不同的模型放在一起以创建功能齐全的智能系统。在这里，多层次的拟合和再拟合恰好可以实现一个连贯的总体目标，比如创建无人驾驶汽车系统或功能完全的人工智能（AI）。</li>
</ol>

<p>  迭代对于在不久的将来创建更智能的 AI 系统至关重要。对复杂数据集执行多次迭代的巨大内存需求继续带来重大挑战。但随着人工智能芯片、存储设备和数据传输技术的日益完善，这些挑战变得越来越容易应对。</p>

<p>  我们相信，迭代机器学习技术将在不久的将来继续引领人工智能领域的转型。</p>

<h2 id="版权声明">版权声明</h2>

<p>  由于本文是对英文博文的译文，本人对文章内容不享有版权。如有版权争议，可联系撤下本文。</p>

<p>  As this article is a translation of an English blog post, I do not have the copyright of the content in this article. If there is a copyright dispute, please contact me to withdraw this article.</p>]]></content><author><name>zhonger</name></author><category term="ac" /><category term="ml" /><category term="迭代学习" /><category term="机器学习" /><category term="iterative learning" /><category term="machine learning" /><summary type="html"><![CDATA[原文标题：Iterative Machine Learning: A step towards Model Accuracy 原文作者：Amarabha Benerjee]]></summary></entry><entry><title type="html">H2O-ac theme for Jekyll</title><link href="https://lisz.me/tech/webmaster/new-theme-h2o-ac.html" rel="alternate" type="text/html" title="H2O-ac theme for Jekyll" /><published>2021-12-22T20:50:00+09:00</published><updated>2021-12-22T20:50:00+09:00</updated><id>https://lisz.me/tech/webmaster/new-theme-h2o-ac</id><content type="html" xml:base="https://lisz.me/tech/webmaster/new-theme-h2o-ac.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  正如大家所知，Jekyll 是一款高可定制的、非常流行的静态博客生成工具。围绕着 Jekyll 也衍生出了很多优秀的 Jekyll 主题， 由 <a href="https://github.com/kaeyleo">廖柯宇</a> 开发的 <a href="https://github.com/kaeyleo/jekyll-theme-H2O">H2O</a> 主题就是其中之一。极简主义、风格扁平化、卡片式布局、Medium 及知乎专栏的视觉风格等等特点，为我们带来了或许是迄今为止最漂亮的 Jekyll 主题。</p>

<p>  诞生之初，H2O 主题就在 Github 平台上以 MIT 许可证协议开放了源代码。这吸引了很多小伙伴纷纷转投 Jekyll 和 H2O 主题的阵营，本人也是其中之一。随着使用者越来越多，不少的小伙伴在使用过程中发现了一些小问题并主动修复，最后贡献到了 H2O 的主项目，这让 H2O 主题变得更好。本人在使用过程中也的确是发现了一些与自己实际需求不大一致的地方，并且在原 H2O 主题的基础上做了一些改动。考虑到这些改动可能并不是大多数人的需求，直接向原 H2O 主题提交 pull 请求合并的必要性不大，因此决定将原项目 fork 并改名为 <a href="https://github.com/zhonger/jekyll-theme-H2O-ac">zhonger/jekyll-theme-H2O-ac</a>。现正式将源代码以与 H2O 主题相同的 MIT 许可证协议在 Github 平台上公开。</p>

<p>  在此，非常感谢廖柯宇及其他小伙伴对于 H2O-ac 主题的基础主题 H2O 的代码开发和开放共享。</p>

<h2 id="新特性">新特性</h2>

<h3 id="更适合学术人和运维程序员的页面结构">更适合学术人和运维程序员的页面结构</h3>

<p>  H2O 主题其实在很大程度上已经满足了大部分人的需求，只是对于学术研究人员和运维程序员来说，个人觉得页面结构还是有点不够合适。学术研究人员比较重视在首页直接展示个人信息和研究情况，能够让人很快地了解到所需的信息，这其实是将 About me 这样一个平常的辅助页面当成了主页面来用。另外，运维程序员比较重视能一览所有文章的标题以迅速找到感兴趣的文章。虽然搜索功能、标签页、卡片展示页都能够列出所有的文章，但个人觉得还是不够简洁、方便。而像 Hexo 静态生成工具自带的 Archive 归档页面比较能满足这样的需求。除此之外，整个博客的系统日志变迁记录对于运维程序员来说也非常重要，毕竟如果通过发布一篇文章来描述变迁过程并不适合联系起来完整了解。如果有系统日志页，就可以按照年份、月份、事件的先后进行简要的描述，并且一览无遗。</p>

<p>  因此，在 H2O-ac 主题中，从原来 H2O 的主页中抽出框架做成了页面模板。根据实际页面的内容需求，增加了<strong>学术首页</strong>、<strong>归档页</strong>和<strong>系统日志页</strong>。</p>

<h4 id="学术首页">学术首页</h4>

<p>  学术首页如下图所示，并将原来 H2O 中的卡片首页移动到 blog 子目录下了。如果读者想要看到文章卡片展示页，还是可以点击顶部的导航栏中的 BLOG 直接访问。</p>

<p><img src="https://i.vgy.me/pICzcE.png" alt="vgy.me" /></p>

<h4 id="归档页">归档页</h4>

<p>  归档页设置为由 Jekyll 按照模板自动生成，以年份、日期、文章标题分级列表展示，简洁清晰。</p>

<p><img src="https://i.vgy.me/25IZzc.png" alt="vgy.me" /></p>

<h4 id="系统日志页">系统日志页</h4>

<p>  系统日志页其实也不是经常更新的，只有在博客整体作出设置或改进的才加以说明。另外，也可以将一些固定的站点信息放置在系统日志页，比如站点的多点部署信息，读者可以根据此信息访问最快、最合适的节点。</p>

<p><img src="https://i.vgy.me/tUCNEb.png" alt="vgy.me" /></p>

<h3 id="使用体验提升">使用体验提升</h3>

<p>  廖柯宇也在 H2O 主题的默认页面中写道，目前 H2O 主题还有一些可优化的内容，比如夜间模式、查看大图等。这里，根据个人的一些实际需求和了解，在 H2O-ac 主题中做了调整。</p>

<h4 id="社交图标扩展">社交图标扩展</h4>

<p>  H2O 原有的社交图标其实已经比较广泛，只是还有些领域局限性，比如学术研究人员可能更希望展示谷歌学术、ResearchGate、ORCID 等社交图标及链接，而运维开发人员可能更希望展示 SegmentFault、CSDN、博客园等社交图标及链接。这里在 H2O 提供的社交图标类型基础上做了这些平台图标的扩充，同时尝试了 Symbol 引用的方式来实现社交图标鼠标悬停的效果，从而简化代码（H2O 采用的是字体图标的方式，需要为每一个社交图标定义不同的主题色）。</p>

<p><img src="https://i.vgy.me/ebCeqM.png" alt="vgy.me" /></p>

<h4 id="查看大图">查看大图</h4>

<p>  查看大图功能的确对于读者的阅读体验来说有很大的提升。就像我们阅读文献一样，可能首先会只看文章附图来大致掌握文章的核心点。博文的查看大图功能也可能有这样的异曲同工之妙。这里是采用的 <a href="https://fancyapps.com/docs/ui/fancybox">Fancybox</a> 插件实现的。H2O-ac 主题中只使用了最简单的配置，用户可以根据需求查看文档做出更多的修改。</p>

<p><img src="https://i.vgy.me/FNRDTv.png" alt="vgy.me" /></p>

<h4 id="代码高亮优化">代码高亮优化</h4>

<p>  本人使用 H2O 主题的时候代码高亮功能还是沿用的 Jekyll 自带的，后来 H2O 主题也开始采用了 <a href="https://prismjs.com/">Prism.js</a>。不过由于使用的是 <code class="language-plaintext highlighter-rouge">OKAIDIA</code> 高亮主题，所以有些段落中的格式化字段显示上有些问题。这里，仍然采用默认主题，并且扩增到 Prism.js 支持的所有编程语言类型。效果可以从前一句的 OKAIDIA 字段和下面即将出现的代码片段看出。</p>

<h4 id="字数统计及阅读时间估计">字数统计及阅读时间估计</h4>

<p>  字数统计及阅读时间估计这个小功能其实以前在用 WordPress 的时候比较常见。虽然说统计和估计的结果不一定完全准确，但是还是起到了一定的辅助阅读的作用。效果可以查看本页标题下的基本信息区域。</p>

<h4 id="文章侧边索引导航">文章侧边索引导航</h4>

<p>(2022年1月9日更新)</p>

<p>  在一些基于 Bootstrap 前端框架的 Jekyll 主题中，这个功能比较常见。由于本主题未使用 Bootstrap 前端框架，所以添加起来稍微有些麻烦，现已增加此功能。在浏览器窗口超过 1050 px 的情况下，在文章页面可以正常看到右侧的文章侧边索引导航。当窗口滑动时，侧边索引导航也会跟着滑动。在浏览器窗口不足 1050 px 的情况下，侧边索引导航自动隐藏。在 _config.yml 配置文件中，可以通过设置 <code class="language-plaintext highlighter-rouge">toc: false</code> 来全局禁用此功能。</p>

<h4 id="配置项">配置项</h4>

<p>  配置项中新增了<strong>友情链接</strong>、<strong>备案号</strong>、<strong>Google Analytics</strong> 和 <strong>CNZZ</strong> 统计功能，可以直接在 _config.yml 文件的对应配置项下设置即可，如下所示。友情链接主要是方便跟其他博主交换友链，备案号主要是为了方便部署在国内需备案的 vps 或虚拟主机上。此处，二者都可以置空。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Links 友情链接</span>
<span class="na">links</span><span class="pi">:</span>
  <span class="s1">'</span><span class="s">Mr</span><span class="nv"> </span><span class="s">Li'</span><span class="err">:</span> <span class="s1">'</span><span class="s">https://lisz.me'</span>

<span class="c1"># Beian 备案号</span>
<span class="na">beian</span><span class="pi">:</span> <span class="s1">'</span><span class="s">沪ICP备xxxxxxxx号'</span>

<span class="c1"># CNZZ 统计代码</span>
<span class="na">cnzz</span><span class="pi">:</span>

<span class="c1"># Google Analytics</span>
<span class="na">google_analytics</span><span class="pi">:</span>
</code></pre></div></div>

<h4 id="前端自动构建工作流优化">前端自动构建工作流优化</h4>

<p>  H2O 主题中使用了 Gulp + Node-Sass 的方案来自动化前端构建工作流。不得不说，这个方案还是很不错的，只是随着 Gulp 和 Node-Sass 版本的更新，对 NodeJS 环境及其他依赖库都有一些要求。这里，H2O-ac 主题在 package.json 文件中将所有库都更新到目前最新，对应版本列表如下所示。另外，为了减少一些第三方 CSS 样式的请求数，利用自动构建工作流将固定的第三方 CSS 样式文件合并并压缩为 plugins.min.css 文件。app.min.css 仍为多个自编写 CSS 样式文件的合并压缩。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">运行环境或依赖库</th>
      <th style="text-align: center">版本号</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">NodeJS</td>
      <td style="text-align: center">v17.0.0</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp</td>
      <td style="text-align: center">v4.0.2</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-clean-css</td>
      <td style="text-align: center">v4.3.0</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-rename</td>
      <td style="text-align: center">v20.0</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-sass</td>
      <td style="text-align: center">v5.0.0</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-uglify</td>
      <td style="text-align: center">v3.0.2</td>
    </tr>
    <tr>
      <td style="text-align: center">gulp-concat</td>
      <td style="text-align: center">v2.6.1</td>
    </tr>
    <tr>
      <td style="text-align: center">node-sass</td>
      <td style="text-align: center">v7.0.0</td>
    </tr>
  </tbody>
</table>

<h2 id="使用方法">使用方法</h2>

<h3 id="初始化">初始化</h3>

<h4 id="方式一从模板新建博客">方式一：从模板新建博客</h4>

<p>  为了方便用户使用 H2O-ac 主题，特别提供了 Github 的模板功能。如下图所示，访问 <a href="https://github.com/zhonger/jekyll-theme-H2O-ac">H2O-ac</a> 可以看到如下的 Use this template 按钮，点击该按钮即可用 H2O-ac 主题创建自己的博客代码仓库。想要了解更多步骤，可以访问 Github 官方文档之 <a href="https://docs.github.com/cn/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template">从模板创建仓库</a>。</p>

<p><img src="https://i.vgy.me/y7lv2Q.png" alt="vgy.me" /></p>

<h4 id="方式二已有博客迁移">方式二：已有博客迁移</h4>

<p>  <del>暂时无法支持 gem 直接切换主题，后续将更新此方式。目前只能使用方式一创建仓库后，将文章的 markdown 文件复制到 _posts 目录下应用 H2O-ac 主题。</del></p>

<p>(2021年12月26日更新)</p>

<p>  现已支持使用 gem 直接切换主题 <code class="language-plaintext highlighter-rouge">jekyll-theme-h2o-ac</code>。同时，也推出了一键式构建工具 <a href="https://github.com/zhonger/easy-to-h2o-ac">easy-to-h2o-ac</a>，详细可以见项目主页。</p>

<h3 id="本地测试">本地测试</h3>

<p>  在进行本地测试时，如果需要修改一些样式，则需要先执行 <code class="language-plaintext highlighter-rouge">npm install</code> 来完成前端自动构建工作流依赖库的安装。注意，这里设定的可用 NodeJS 版本为 v17.0.0，使用老版本会报错。其次，务必使用 <code class="language-plaintext highlighter-rouge">bundle install</code> 安装主题所需的所有 Ruby 依赖库。最后执行 <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve --livereload</code> 命令即可在本地实时同步预览。只要不修改 _config.yml 文件，不必中断后再启动。然后就是在 _posts 目录下写 markdown 文章即可。</p>

<h3 id="发布部署">发布部署</h3>

<p>  由于 Github 提供 Jekyll 静态生成器的静态页面托管，只要打开仓库的 Pages 功能，当推送更新到 Github 时即会自动部署。此处值得注意的是，如果代码仓库的名字不是 <code class="language-plaintext highlighter-rouge">username.github.io</code>，而也没有为该仓库的 Pages 提供自定义域名，那么这个仓库将会被部署到子目录，因此此时必须在 _config.yml 文件中设置 base_url，从而生成正常的静态页面。</p>

<h2 id="结束语">结束语</h2>

<p>  再次感谢廖柯宇及其他小伙伴们对 H2O 主题的付出，没有 H2O 主题就没有 H2O-ac 主题！H2O-ac 主题后续也将继续更新，欢迎小伙伴们使用和 <a href="https://github.com/zhonger/jekyll-theme-H2O-ac">Star</a>，也欢迎大家一起来贡献代码。</p>

<p>（Ps: <del>由于沿用了 H2O 的 Logo，可能会侵犯廖柯宇的版权。如果的确如此，后续将会设计一个新的 Logo。</del> 已采用新 Logo。）（2022年1月10日更新）</p>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="jekyll" /><category term="theme" /><category term="blog" /><category term="ac" /><category term="develop" /><category term="主题" /><category term="前端开发" /><category term="学术" /><category term="运维" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">Jekyll 社交图标集合创建</title><link href="https://lisz.me/tech/webmaster/jekyll-sns-icons.html" rel="alternate" type="text/html" title="Jekyll 社交图标集合创建" /><published>2021-12-22T11:30:00+09:00</published><updated>2021-12-22T11:30:00+09:00</updated><id>https://lisz.me/tech/webmaster/jekyll-sns-icons</id><content type="html" xml:base="https://lisz.me/tech/webmaster/jekyll-sns-icons.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  一般来说，我们的个人博客都会放上一些社交图标以及社交链接。这样一来，想要关注我们更多的最新研究或工作的读者就可以很快找到路径。于是，在 Jekyll 博客主题设计的时候，通常会在个人简介的地方放置几个社交小图标，点击社交小图标即可把读者带到你的社交个人主页上。对于不同类型的作者，常用的或者关注的社交平台基本上不大一样，社交小图标也会有不一样的需求。比如说，对于从事科研工作的人来说，像谷歌学术、ResearchGate、ORCID 等等能够列举发表论文或者相关研究的平台就比较重要；对于一般程序员来说，像 Github、Gitlab、Segmentfault、CSDN、简书等等能够展示自己所参与的项目和技术心得体会的平台就比较重要；对于前端设计师来说，像 Instgram、UI 中国、Dribble等等能够展示 UI 设计作品的平台就比较重要。因此，对于一款 Jekyll 博客主题的设计者来说，同时要兼顾到这么多不同的需求可能会有点为难，毕竟领域不同、了解的程度也很有限。</p>

<p>  俗话说得好，授人以鱼不如授人以渔。今天我们就来讲讲如何自己定制一套社交图标集合。</p>

<h2 id="技术发展回顾">技术发展回顾</h2>

<h3 id="图片索引">图片索引</h3>

<p>  对网站前端设计有点了解的小伙伴可能知道，如果要为网站添加一些社交图标，并且支持鼠标悬停高亮显示，最早的办法是采用不同的图片进行切换的方法。具体来说就是，鼠标悬停前是一张图片，悬停后切换到另外一张图片。由于如果要支持很多个社交图标就要准备很多对这样的图片，那么同一页面内的文件 HTTP 请求数就会陡然增加，对页面加载性能有非常大的影响。</p>

<p>  随之产生了一种比较可行的解决方案：将所有的社交图片拼在一张图上，然后通过定位的方式来索引到不同的社交图标，我们通常将这张图称为<strong>雪碧图</strong>。这种方法的好处比较明显，浏览器只需要发出一次请求下载雪碧图即可，减少了文件 HTTP 请求数，加载时间显著变短。比较明显的困难是，定位找起来简直不要太麻烦。而且为了能描述不同的图标悬停前后的位置，必须写很多对样式与之对应，工作量比较大。另外一个比较大的困难是，图标集合的更新很麻烦。新增图标的时候，为了能沿用原来已经写好的样式，只能在原有的雪碧图的基础上往后增加图标，当然同时也要增加对应的样式。</p>

<p>  虽然雪碧图在某种程度上提升了加载效率，但是给后期的更新、维护带来了不小的麻烦。还有一个越来越凸显的问题——随着访问网站的设备类型的不断增多，图片的质量会影响到不同设备、不同平台下的效果一致性，甚至在高分辨率屏幕下会出现图标模糊的情况，用户体验极其不佳。最有效的改进方法可能就是采用分辨率更高、质量更高的图片来拼凑雪碧图，不过同时也会增大雪碧图的文件体积。这会导致虽然只发出了一个文件 HTTP 加载请求，但是由于文件体积过大、加载速度慢，而给用户带来不好的使用体验。</p>

<h3 id="字体图标">字体图标</h3>

<p>  接着发展出了一种<strong>字体图标</strong>的东西来解决图片索引中存在的问题。字体图标，顾名思义就是把所有的图标都变成了字体编码一样，只要我们在网页中引入字体图标文件就可以像用 Unicode 一样使用字体图标了。这种方式最好的一点就是，像操纵字体一样设置字体图标的样式。比如说，虽然我们只在字体图标文件中定义了一个图标，但是当我们使用不同的 color 定义时，图标就会改变其颜色。而且，我们操纵字体图标的大小是采用 font-size 的方式而非 width/height 的方式。这样一来，字体图标和行内文字段落一起使用时也是非常匹配的，行距等文字样式都能同等适用。</p>

<p>  当然，字体图标在后期的维护、更新过程中也会有些问题。比如说，对于一个大型项目的迭代开发，每个子系统可能都会弄一套需要的字体图标，然后在代码分支合并时就会出现问题。因此，有些项目团队可能会为此而设定一位管理员来专门管理字体图标的更新。每个子系统只能向图标管理员提交他们的更新，最终更新由图标管理员来完成。虽然这样也能在某种程度上解决问题，但是对于图标管理员来说还是会很苦恼。</p>

<p>  说到这里，有人可能会想起 Bootstrap 等 UI 框架中自带的字体图标集合。那我们直接使用某个框架提供的字体图标集合不就万事大吉了吗？可事实并非如此，框架所包含的字体图标集合虽然看起来还是比较全面，但是还是有可能缺少某些我们想要的字体图标。想到这里，可能会想不如把多个字体图标集合整合在一起使用不就好了吗？这样随之而来的问题是，很大可能存在大量冗余。对于前端界面来说，除了大量的 HTTP 请求是无法接受的，大量冗余代码也是无法接受的。当我们用 <a href="https://web.dev/measure/">Lighthouse</a> 类似的工具来测试网页的性能时，就可以很容易地发现请求代码的使用率情况。如果我们采用多个字体图标集合并用的方案，那么代码实际使用率可能就会很低。也就是说，请求的代码基本上不会在网页中被使用到，这对于优化页面性能来说简直就是噩梦。</p>

<p>  如果我们觉得自己来手动管理、手动更新字体图标文件太麻烦了，其实也可以用阿里的 <a href="https://www.iconfont.cn">Iconfont</a> 或者其他类似工具来在线管理字体图标集合。Iconfont 会提供一个阿里 CDN 上的链接地址来直接使用你建立好的字体图标集合，这样一来基本上就解决了上面所说的维护难题。我们在 Iconfont 上更新好字体图标集合后，Iconfont 会生成一个新的链接地址。然后，我们只需要修改页面代码的对应地址就可以非常方便地应用更新。</p>

<p>  这么看来，字体图标的方案好像很完美了，但事实上还是存在其他的问题。Iconfont 这类平台比较适合个人开发者或者开源项目，而对于企业开发者或者非开源项目来说可能依然不大适合。另外，字体图标因为像字体一样被操纵，所以只能支持一种颜色，无法同时支持多种颜色。除此之外，如果我们想要预览所有的图标，但是抱歉的是脱离了 Iconfont 这类平台我们可能就没有办法做到。</p>

<h3 id="symbol-图标">Symbol 图标</h3>

<p>  实际上除了字体图标在不同设备、不同平台上有相同的效果之外，SVG 图标也具有类似的效果，这主要是因为 SVG 图标的矢量本质，即缩放不会产生任何失真。SVG 图标还支持多种颜色、可以通过字体样式调整样式，并且支持 IE9 以上版本的浏览器。（随着时代的进步，IE 其实已经不是最新的 Windows 11 操作系统默认软件之一了，而且微软也不再提供 IE 安装包下载了，所以未来 IE 浏览器可能不会出现在考虑支持列表里。）为了能够创建一个 SVG 图标集合，我们可以使用 <code class="language-plaintext highlighter-rouge">symbol</code> 元素来定义一个图形模板对象，然后用一个 <code class="language-plaintext highlighter-rouge">&lt;use&gt;</code> 元素实例化。<code class="language-plaintext highlighter-rouge">symbol</code> 元素对图形的作用是在同一文档中多次使用，添加结构和语义。结构丰富的文档可以更生动地呈现出来，类似讲演稿或盲文，从而提升了可访问性。值得注意的是，一个 <code class="language-plaintext highlighter-rouge">symbol</code> 元素本身是不会呈现的，只有当 <code class="language-plaintext highlighter-rouge">symbol</code> 元素的实例（即，一个引用了 <code class="language-plaintext highlighter-rouge">symbol</code> 的 <code class="language-plaintext highlighter-rouge">&lt;use&gt;</code> 元素）才能呈现。</p>

<p>  如下代码所示，是一个 <code class="language-plaintext highlighter-rouge">symbol</code> 图标的例子。其中，<code class="language-plaintext highlighter-rouge">symbol</code> 元素定义了两个圆圈，对应信息如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">圆的编号</th>
      <th style="text-align: center">位置</th>
      <th style="text-align: center">半径</th>
      <th style="text-align: center">填充色</th>
      <th style="text-align: center">描边宽度</th>
      <th style="text-align: center">描边颜色</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">(50, 50)</td>
      <td style="text-align: center">40</td>
      <td style="text-align: center">红色</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">红色</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">(90, 60)</td>
      <td style="text-align: center">40</td>
      <td style="text-align: center">白色</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">绿色</td>
    </tr>
  </tbody>
</table>

<p>实例化了三个 <code class="language-plaintext highlighter-rouge">symbol</code> 元素，分别为：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">实例编号</th>
      <th style="text-align: center">位置</th>
      <th style="text-align: center">宽度</th>
      <th style="text-align: center">高度</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">(0, 0)</td>
      <td style="text-align: center">100</td>
      <td style="text-align: center">50</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">(0, 50)</td>
      <td style="text-align: center">75</td>
      <td style="text-align: center">38</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">(0, 100)</td>
      <td style="text-align: center">50</td>
      <td style="text-align: center">25</td>
    </tr>
  </tbody>
</table>

<pre><code class="language-svg">&lt;svg&gt;
&lt;!-- symbol definition  NEVER draw --&gt;
&lt;symbol id="sym01" viewBox="0 0 150 110"&gt;
  &lt;circle cx="50" cy="50" r="40" stroke-width="8" stroke="red" fill="red"/&gt;
  &lt;circle cx="90" cy="60" r="40" stroke-width="8" stroke="green" fill="white"/&gt;
&lt;/symbol&gt;

&lt;!-- actual drawing by "use" element --&gt;
&lt;use xlink:href="#sym01"
     x="0" y="0" width="100" height="50"/&gt;
&lt;use xlink:href="#sym01"
     x="0" y="50" width="75" height="38"/&gt;
&lt;use xlink:href="#sym01"
     x="0" y="100" width="50" height="25"/&gt;
&lt;/svg&gt;
</code></pre>
<p>效果如下所示：</p>

<p><img src="https://i.vgy.me/eTsY1a.png" alt="vgy.me" /></p>

<h2 id="创建自定义社交图标集合">创建自定义社交图标集合</h2>

<p>  现在让我们来尝试一下借助 Iconfont 来创建自定义的社交图标集合吧。首先访问 <a href="https://www.iconfont.cn">Iconfont 首页</a> 并使用 Github 账户或者其他方式登录好。然后在搜索框中输入 github 查询平台所有开放的相关图标，点击即可加入购物车。</p>

<p><img src="https://i.vgy.me/RkgKa1.png" alt="vgy.me" /></p>

<p>  接着点击右上角的购物车按钮如下所示可以查看已加入到购物车的所有图标，并点击<strong>添加到项目</strong>。</p>

<p><img src="https://i.vgy.me/QHdhi5.png" alt="vgy.me" /></p>

<p>  然后给项目取名（这里的名字随便起），点击<strong>确认</strong>按钮完成项目添加，自动跳转到项目页。</p>

<p><img src="https://i.vgy.me/dymDV8.png" alt="vgy.me" /></p>

<p>  点击生成代码即可生成专属链接，并出现<strong>点击复制代码</strong>按钮。</p>

<p><img src="https://i.vgy.me/NNSsLJ.png" alt="vgy.me" /></p>

<p>  点击<strong>收起在线链接</strong>旁边的下箭头可以看到<strong>预览字体</strong>，点击<strong>预览字体</strong>即跳转到在线预览页面，如下所示。</p>

<p><img src="https://i.vgy.me/tKwaPx.png" alt="vgy.me" /></p>

<p>  这里提供了三种方式来使用创建好的社交图标集合，目前平台推荐的是<strong>Symbol 引用</strong>方式。接着即可按照以下三个步骤在你的网页上轻松使用自定义好的社交图标集合了。</p>

<p><img src="https://i.vgy.me/7C7G0A.png" alt="vgy.me" /></p>

<h3 id="小提示">小提示</h3>

<p>  如果想要实现鼠标悬停图标高亮的效果，还需要自己修改一下 CSS 样式，如下所示。这里采用了灰度遮罩滤镜的方式，给原来彩色的图标灰度化了。当鼠标悬停时，灰度化效果被移除，并且有 0.2 s 的缓慢过渡。不过如果原来的图标是黑色的话，灰度化的效果可能就比较差，悬停前后的差异不大明显，所以推荐使用彩色社交图标。Iconfont 平台实际上提供了在线编辑修改颜色的功能，如果想要知道某个图标或者品牌的主题颜色可以访问 <a href="https://www.schemecolor.com/">Schemecolor</a> 来查询。</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.icon</span> <span class="p">{</span>
    <span class="nl">width</span><span class="p">:</span> <span class="m">1em</span><span class="p">;</span>
    <span class="nl">height</span><span class="p">:</span> <span class="m">1em</span><span class="p">;</span>
    <span class="nl">vertical-align</span><span class="p">:</span> <span class="m">-0.15em</span><span class="p">;</span>
    <span class="py">fill</span><span class="p">:</span> <span class="n">currentColor</span><span class="p">;</span>
    <span class="nl">overflow</span><span class="p">:</span> <span class="nb">hidden</span><span class="p">;</span>
    <span class="nl">filter</span><span class="p">:</span> <span class="n">grayscale</span><span class="p">(</span><span class="m">100%</span><span class="p">);</span>
    <span class="nl">-webkit-filter</span><span class="p">:</span> <span class="n">grayscale</span><span class="p">(</span><span class="m">100%</span><span class="p">);</span>
    <span class="nl">-moz-filter</span><span class="p">:</span> <span class="n">grayscale</span><span class="p">(</span><span class="m">100%</span><span class="p">);</span>
    <span class="nl">-ms-filter</span><span class="p">:</span> <span class="n">grayscale</span><span class="p">(</span><span class="m">100%</span><span class="p">);</span>
    <span class="nl">-o-filter</span><span class="p">:</span> <span class="n">grayscale</span><span class="p">(</span><span class="m">100%</span><span class="p">);</span>
    <span class="nl">transition</span><span class="p">:</span> <span class="m">.2s</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.icon</span><span class="nd">:hover</span> <span class="p">{</span>
    <span class="nl">filter</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
    <span class="nl">-webkit-filter</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
    <span class="nl">-moz-filter</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
    <span class="nl">-ms-filter</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
    <span class="nl">-o-filter</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/symbol">symbol - SVG | MDN</a></li>
  <li><a href="https://blog.csdn.net/jys1216/article/details/8852158">使网站首页变灰色，遮罩滤镜</a></li>
  <li><a href="https://juejin.cn/post/6844904162442870792">还在用字体图标吗，试试svg图标吧(内附vuecli-svg-sprite-loader插件)</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="Jekyll" /><category term="主题" /><category term="theme" /><category term="社交图标" /><category term="sns" /><category term="icons" /><category term="Iconfont" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">科学文献的那些事儿</title><link href="https://lisz.me/ac/experience/search-papers.html" rel="alternate" type="text/html" title="科学文献的那些事儿" /><published>2021-12-10T10:10:00+09:00</published><updated>2021-12-10T10:10:00+09:00</updated><id>https://lisz.me/ac/experience/search-papers</id><content type="html" xml:base="https://lisz.me/ac/experience/search-papers.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  现在有越来越多的人涌入了读研、读博的大潮当中，但是“如何搜索到自己需要的科学文献，并进行阅读和管理”却成了一个比较棘手的问题。所以，今天打算介绍一些本人在这方面的经验。</p>

<p>  一般的科学探索过程可以分为以下几个大的版块：<strong>选题</strong>、<strong>搜索文献</strong>、<strong>阅读文献</strong>、<strong>提出想法</strong>、<strong>代码编写与测试</strong> 以及 <strong>论文撰写与投稿</strong>。其中，选题可以是一个具体的题目，也可以是几个关键词，比如说“钙钛矿”、“能带间隙”、“机器学习”等。在明确了选题之后，我们仍然可能不知道我们想要关注和解决的问题是什么。这种时候往往需要通过在阅读一定量的文献之后，才有可能对问题本身有一个比较清晰的认识。所以说，前三个版块其实都可以归于 <strong>提出问题</strong> 的大步骤里。事实上，<strong>提出想法</strong> 也是需要建立在阅读一定量的文献的基础上的。如果不能够很好地掌握研究方向上的各种各样的研究思路和关注的问题，自然也就无法产生自己的想法，甚至说可能有些时候自己的想法已经被研究过了而不自知。再一个与文献有关系的版块就是 <strong>论文撰写与投稿</strong>。一旦在上一个版块中有了与你期待的一致的结果时，这里不仅需要把你的想法和结果告诉别人，还需要通过对文献的引用来多方面地论证自己观点的正确性和适用性。这其实也是论文撰写过程中最难的一环，如果缺少这一环，那么你撰写的论文将和实验报告没有什么太大的差别。不过，对于一些原创性极强的文章，可能会有一种难以找到相关的文献来论证自己观点。一般来说，可能在完全相同或相近的研究方向上存在的文献非常少，但是和自己的研究中所用到的细节上的相关研究应该还是有不少的，同样可以用来论证细节上的正确性和适用性。</p>

<p>  接下来，将从与文献有关的<strong>搜索</strong>、<strong>阅读</strong>和<strong>管理</strong>几个方面分享一些具体的经验。</p>

<h2 id="文献搜索">文献搜索</h2>

<p>  最初大家印象里的文献搜索可能就是在 <strong>百度</strong>、<strong>必应</strong>、<strong>谷歌</strong> 等第三方搜索引擎中输入关键词(中文/英文)，然后可能进阶到用 <strong>百度学术</strong>、<strong>必应学术</strong>、<strong>谷歌学术</strong> 等专注于文献或书籍的搜索引擎搜索关键词。当然了，国内外高校基本上新生入学都会有一个图书馆教育。一般的图书馆教育中，除了日常的借书、还书的事务性教育外，还有一大部分是关于如何正确地、合理地使用图书馆所购买的各项文献数据库，并遵守应有的学术规范、学术道德。接着大家可能会发现学校图书馆的主页上其实也有一个大大的搜索框。这个搜索框也是一个搜索引擎，而且是学校花钱购买的统一了学校所有纸质资源和电子资源的搜索引擎。发现了这个之后，很多人可能会从第三方提供的搜索引擎转向图书馆的搜索引擎。可是用了不久之后，慢慢地会觉得是不是哪里出了问题，怎么搜索不到更多我想要的文献了？哈哈哈，有这种感觉完全没有什么问题，这是一个必然的结果。所谓的搜索引擎是建立在一个复杂的数据库和索引上的，如果数据库没有及时更新信息，那么采用相同的关键词搜索出来的文献列表自然没有什么变化。图书馆搜索引擎如此，第三方搜索引擎亦是如此。</p>

<p>  单单依靠图书馆搜索引擎和第三方搜索引擎可能都无法满足最新、最全的需求，我们需要借助更加全面的搜索引擎工具– <a href="https://www.webofscience.com/">Web of Science</a> (WoS)。这个搜索引擎最初是由在美国费城的科学情报研究所建立的，之后又转交给 科睿唯安(Clarivate)公司 进行维护。WoS 包含了非常丰富的文献数据以及引用情况，如 SCI 索引、SSCI 索引、ESCI 索引、书籍索引等。下表比较了这三种不同的搜索引擎的优势和缺点。</p>

<table>
  <thead>
    <tr>
      <th>搜索引擎提供方</th>
      <th>优势</th>
      <th>缺点</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>图书馆</td>
      <td>有版权可直接下载（登录后校外也可）</td>
      <td>缺少某些数据库</td>
    </tr>
    <tr>
      <td>第三方搜索</td>
      <td>搜索引擎算法更好</td>
      <td>偶有未索引文献；无法直接下载</td>
    </tr>
    <tr>
      <td>Web of Science</td>
      <td>数据库索引和相关信息齐全</td>
      <td>搜索引擎一般</td>
    </tr>
  </tbody>
</table>

<p>  有人觉得，既然说三种搜索引擎各有千秋那为什么不同时使用它们三个呢？当然，三者同时使用的话可以进行优势互补，可以满足 80% 以上的个人需求。那还有 20% 的需求指的是什么呢？又需要如何满足呢？实际上，并不是说我们需要的文献就可以通过我们定义的那几个关键词在搜索引擎中搜索出来。相反，有不少可能对我们非常有用的文献所关联的关键词并非我们常用的。</p>

<p>  对于这部分文献我们需要从两种方法来补齐。一种是，改变搜索的策略为“按人名搜索”。“按人名搜索”与“按关键词搜索”不同的是，前者的结果是某个研究者参与的所有工作，后者的结果是可能与关键词非常相关的很多研究者的某项工作。当我们阅读到一定量的文献之后，其实我们可以知道在国内外有哪些非常知名的研究者或研究团队在从事和我们相同或类似的工作。一般来说，某个研究者或者研究团队都是在一个研究方向上会有持续性的研究。这样一来，随着时间的积累自然也会有不少的值得一读的文献。顺便提一句，当我们刚进入一个研究团队开始我们的研究时，应该先阅读一下研究团队发表的大部分文章，以此明确未来可能的研究方向。甚至说，你可能从这些文章中发现一些你可以做的点（问题）。另外一种是，让平台为你自动推荐，比如 Research Gate、Mendeley、谷歌学术等。这些平台会根据你日常阅读或已发表的文献来推荐你可能感兴趣的文献，虽然说有些时候推荐的文献并不是让人很感兴趣，但是只要几十篇里面有一篇可以对你有所帮助，那么它的价值就已经足够了。</p>

<p>  以下就对上述所提到的三种文献搜索方式进行详细地解释：</p>

<h3 id="按关键词搜索">按关键词搜索</h3>

<p>  关键词搜索其实是模糊搜索中最常用的一种搜索策略，不管对于任何的搜索引擎来说，都是同样有效的。唯一的差别是，根据搜索引擎的算法不同、数据库索引不同，搜索出来的结果会有差异。而且，当我们输入中文关键词或英文关键词时，也会对搜索结果产生影响。因为搜索结果也是与关键词所使用的语言密切相关的，比如说在图书馆搜索引擎中搜索中文关键词，那么默认搜索结果将会以中文优先，英文及其他语言的结果会在中文结果之后。除了某些像 WoS 那样只支持多语言界面单语言搜索的搜索引擎之外，其他大部分搜索引擎亦然。所以，如果想要搜索中文文献可以使用 <a href="https://www.cnki.net/">知网</a>、<a href="https://www.wanfangdata.com.cn/">万方</a>、<a href="https://www.cqvip.com/">维普</a> 来代替 WoS。相反，如果想要搜索英文文献最好使用 WoS。</p>

<p>  以下就拿“基于机器学习的二元合金的固溶度研究”来举例。首先根据这个标题，可以确定几个英文关键词：alloys、machine learning、 solid solubility。其次，需要选择一个搜索引擎，这里选用 <a href="https://www.bing.com/academic">必应学术</a>。以下是搜索的结果。（哈哈哈，没想到我的文章居然是最相关的。）</p>

<p><img src="https://i.vgy.me/JTSLHF.png" alt="vgy.me" /></p>

<p>  如果直接点击搜索结果的链接，那么将会直接跳转到文献的在线出版页。一般来说，学校购买的版权都是只能校园网内使用的。如果在校外直接访问文献的在线出版页，会提示你没有权限在线访问文献的所有内容以及下载。这个时候我们就可以打开图书馆搜索引擎搜索想要的文献标题，并且使用自己的校园账号登录授权。结果如下图所示。</p>

<p><img src="https://i.vgy.me/obuh1i.png" alt="vgy.me" />
<img src="https://i.vgy.me/OScEFQ.png" alt="vgy.me" /></p>

<p>  从图中可以看出，如果学校已购买版权，就会像上面那样是“有全文（请点击查看全文了解详情）”。但是问题是，如果我们在校外即使点击了这个链接，也会提示没有权限。这又是怎么了？我们期待的是可以直接访问有权限的页面。实际上，出版商们为了能够有效地控制所有可用的请求都是从可以追踪的授权方发出的，坚持限制只有固定的公网校园网 IP 段有权限。这样就是说，你想要在校外通过 IP 验证权限访问文献就必须连上学校的 VPN。但是学校的 VPN 也是花钱买的，所以还是会有客户端数量的限制，尤其一个大学往往是几万人起步，显然 VPN 的路径是特别拥堵的。为此，国外诞生了名为 EZproxy 的图书馆专用代理软件。它主要是给所有可能会使用到的网站都做了一个反向代理，并且利用学校提供的 IDP 服务进行鉴权。国外很多高校都采用了 EZproxy 作为校外访问图书馆资源的替代方式。</p>

<p>  国内高校虽然没有使用 EZproxy，但是有一个由北京大学计算中心开发和维护的 <a href="https://ds.carsi.edu.cn">CARSI 联盟认证</a>。CARSI 与 EZproxy 不同的是，它不依赖于每个高校去建立一套完整的反向代理，而是借助所有出版商提供的第三方账号鉴权 API 为学校和出版商之间架起了一座桥。登录之后如下图所示，会展示学校购买的所有数据库。</p>

<p><img src="https://i.vgy.me/ItMLGh.png" alt="vgy.me" /></p>

<p>  因为刚才我们想要下载的文章属于 ScienceDirect 平台的，所以我们点击进入下图详情页面。然后点击访问资源，系统会帮助你自动完成登录操作，并且显示如下图所示的“You have institutional access”。</p>

<p><img src="https://i.vgy.me/j02Gdk.png" alt="vgy.me" />
<img src="https://i.vgy.me/F9ArXM.png" alt="vgy.me" /></p>

<p>  现在我们去再次刷新一下刚才文献的在线出版页，发现也已经变成了有权限访问和下载了。</p>

<p><img src="https://i.vgy.me/RKg3E1.png" alt="vgy.me" /></p>

<p>  这里也尝试了一下在 WoS 中搜索相同的关键词，搜索结果如下。（没想到最相关的结果也还是我的那篇文章。）这里的“出版商处的全文”其实与图书馆搜索引擎中的全文类似–点击就会直接跳转到文献的在线出版页。如果点击这里的标题的话，就会跳转到如下的详情页。在这个详情页里，我们可以看到非常丰富的相关信息，比如作者的 ORCID 号、文献的 DOI 号、摘要、资助信息、期刊的相关信息等。这里值得一提的是，每个研究者都可以创建一个属于自己的唯一 ORCID 号，不论所在单位或联系邮箱发生了改变都可以保持 ORCID 号完全不变。并且，ORCID 提供一个学术页面，可以介绍个人的教育经历、发表论文以及自定义的链接。现在一般投稿的时候都会建议与 ORCID 账号连接，这样可以保证相同的名字不同的人的一一对应，为整理某个研究者发表的所有文章列表非常有用。</p>

<p><img src="https://i.vgy.me/S0YiNx.png" alt="vgy.me" />
<img src="https://i.vgy.me/EWcRfi.png" alt="vgy.me" /></p>

<h3 id="按人名搜索">按人名搜索</h3>

<p>  前面提到为了补足关键词搜索所欠缺的 20% 未发现的文献，我们通常还会通过搜索某个研究者来发现他参加的所有相关工作。虽然上面提到的三种搜索引擎都可以把姓名当做关键词来进行搜索，但是仍然有可能有很多同名的其他人的工作，或者缺失目标研究者的某些工作。为了得到尽可能完整的列表，通常采用 <a href="https://www.scopus.com/">Scopus</a> 专门搜索研究者。可以看到 WoS 的文献详情页面中的作者信息虽然没有错，但是上面提供的作者链接可能是有问题的，主要是因为同名不同人的问题。</p>

<p>  Scopus 是由 ELSEVIER (爱思唯尔) 出版社建立的，与 ScienceDirect 属于兄弟网站。所以，如果你已经进行了刚才的登录，现在进入 Scopus 网站时就会是已登录状态。而且，Scopus 同时也提供一个期刊度量评价服务，虽然有类似 的第三方评价网站，但是这个指标还是更靠谱的。首先访问 <a href="https://www.scopus.com/">Scopus</a>，然后点击顶部导航栏中的作者搜索，并输入姓和名（拼音或英文）点击搜索即可查看搜索结果。输入 Li 和 Shengzhou 的搜索结果如下所示，第二个就是我自己。</p>

<p><img src="https://i.vgy.me/DcxfiR.png" alt="vgy.me" />
<img src="https://i.vgy.me/RUSMUy.png" alt="vgy.me" /></p>

<p>  那么我们可以点击这第二项进入查看详情，如下图所示。如果你开始看到的画面链接有很多灰色的地方，可以点击右上角铃铛旁边的机构登录按钮再次登录，之后就可以看到下图这样完整的画面了。不得不说，Scopus 整理出来的文章列表还是非常齐全的，其中连预印本也包括在内了。同样，这里既可以查看基本信息，也可以点击“View at Publisher”查看文献的在线出版页。甚至说，这里最后还有一个“相关文献”的推荐按钮，或许可以从中找到更多我们需要的文献。除此之外，如果我们在推荐列表中看到了感兴趣的文献，还可以点击其中的作者查看该作者参与的所有文献的列表，岂不是一举多得。</p>

<p><img src="https://i.vgy.me/WdXVxT.png" alt="vgy.me" /></p>

<h3 id="平台自动推荐">平台自动推荐</h3>

<p>  另外一种获取推荐文献的方式是注册 <a href="https://www.researchgate.net">Research Gate</a>、<a href="https://www.mendeley.com">Mendeley</a>、谷歌学术等平台的账号，并关注一些研究者的账号，那么系统将会定期向你发送推荐邮件。一般来说，频率不会太高，最多一周一次。除此之外，还可以关注领域内的一些知名公众号。毕竟对于一篇刚在线发表公众号的文献来说，公众号的运营者可能很快就知道了，而搜索引擎由于采用爬虫自动爬取很大可能还没来得及增加索引。</p>

<h2 id="文献阅读">文献阅读</h2>

<p>  虽然利用以上文献搜索方法可能获取到了你想要的文献，但是从文献中阅读出对你有用的东西依旧困难。如果你去知乎上搜索一下“如何阅读文献”，可能会有一大堆的回答，而且讲得都很有道理。但是归根结底，理论和实践还是两回事。对于不同的人来说，也会有不同适合的方法。有些时候能够从摘要中就能够觉得获取到了想要的信息，有些时候甚至阅读了全文也很难获取到想要的信息，这种差异就体现了事先预判的必要性。一般来说，文献的结构与我们开展科学研究的过程基本上是一致的。</p>

<ul>
  <li><strong>Introduction 部分</strong>：首先要提出问题，其次要介绍问题相关的研究现状（目的也是为了对问题本身进行充分讨论得出自己将要在文献中解决的问题），接着是简要概括全文的目标、方法和结果。</li>
  <li><strong>Method 部分</strong>：要对提出的方法或模型的构成以及数据集作出充分的阐述，有必要的话可能还有一些简单的性能测试预备。</li>
  <li><strong>Results 部分</strong>：会对所有的结果进行说明，但一定是按照开展研究的思路进行说明的。比如说，想要验证提出模型的好坏，首先要与别的方法的结果进行一个横向的比较，当然也可以包括一个模型内部模块必要性的纵向性能比较。这样可以在某种程度上证明提出的模型的确可以解决对应的问题，但是还缺乏更多的验证。因此，往往还会用一个没有见过的数据集来验证一下模型的泛化能力。如此一来，模型的完备性得到了证明。</li>
  <li><strong>Discussion 部分</strong>：会对研究过程中一些比较关键性的结果或者细节进行充分讨论，从而在理论层面上巩固模型的可用性。有些期刊也会将结果与讨论两个部分放在一起。</li>
  <li><strong>Conclusion 部分</strong>：可能有人觉得这个部分用处不大，但又是必不可少的。因为当读者阅读完以上所有内容之后还需要这个部分来帮他重新总结升华一下，进一步理清思路。在这个部分，也有的作者会提出一些比较前瞻性的考虑，比如未来可以研究的方向或可能实现的目标等。</li>
</ul>

<p>  个人觉得读一篇文献可以有四个目标：找到主线、找到支线、找到“有趣之处”和找到可研究点，接下来就对它们逐一解释。</p>

<h3 id="找到主线">找到主线</h3>

<p>  每一篇文献能够被发表在期刊上，一定有其比较优秀的地方，有的时候是一点，有的时候是几点。从摘要中我们可以获得至少一点，而这一点一般来说会与标题相呼应。有了这样一个预期之后，我们去阅读全文的时候就能找到主线是什么。当然，主线也应该是由“提出的问题”和“解决方案”组成的。</p>

<h3 id="找到支线">找到支线</h3>

<p>  对于一篇文献来说，除了上述的主线之外，应该还可能会有若干条支线。支线的任务有可能是做一些前期工作，为进一步引入解决方案做好准备；也有可能是针对解决方案中的某个细节进行更加深入的探究，进一步增强解决方案的理论可信度；也有可能是对一些小问题的简单探索，并不打算作为主要的结果或结论告诉大家。无论是这里面的哪一种，都对我们进一步了解和思考文献所提出的解决方案有很大的帮助。</p>

<h3 id="找到有趣之处">找到“有趣之处”</h3>

<p>  这里所说的“有趣之处”并不一定是来自解决方案中的某个核心的思路或者模块，也有可能是作者在实践的过程中偶然得到的灵感体现在了解决方案的某个细节上。这种“有趣之处”，虽然可能不能为你提出想要解决问题的思路，但是却能够给你带来更加灵活的思考。比如说，在机器学习领域已经有各种各样的基础算法，诸如支持向量机、决策树、随机森林、贝叶斯优化等等。不少现有的工作都是在这些算法的基础上提出针对某一方面的改进，尤其是应用于交叉领域学科，似乎原有的机器学习算法就已经足够了。这其实会很大地限制你的思考空间，很难有一些实践上的灵活应用。</p>

<p>  这里举一个<strong>交叉验证方法</strong>和<strong>集成学习</strong>灵活应用的例子。一般来说，交叉验证方法是为了提高验证模型分类或预测能力的准确性，但是在交叉验证中实际上根据训练集和验证集的不同会训练得到多个同质模型。往往我们只会关注于交叉验证后的模型平均效果如何，而不会关心学习之后的模型是否也可以利用起来。有文献就利用集成学习将交叉验证得到的多个同质模型集成为一个强学习模型。这样一来，既保证了模型的分类或预测能力，又使得学习模型变得更加具有鲁棒性。只有去深入了解和理解这些，才能在实际应用中灵活应用所学的基础知识得到更好的成果。</p>

<h3 id="找到可研究点">找到可研究点</h3>

<p>  阅读文献不仅仅是在了解与选题相关的国内外研究现状，同时也是在找选题中的可研究点，即需要解决且有可能解决的问题。虽然可能在某些课题组已有研究成果的基础上存在这样的可研究点，但是依旧需要联系客观的研究需求，提出属于自己的可研究点。</p>

<p>  可研究点可以通过在阅读一定量文献之后进行文献总结的方式，梳理现有的研究问题和解决方案以及待解决的研究问题，从而判断有哪些可研究点是值得研究并可能研究的。当然，理论还是要和实际结合的，比如说导师有哪方面的事情想去做，那也应该将其考虑进来，作出一个比较恰当、可行性高的判断。</p>

<h2 id="文献管理">文献管理</h2>

<p>  文献的管理其实是一个非常繁琐的过程，也不存在绝对完美的方式方法。知乎上有很多关于“如何使用 iPad Pro 和 Apple pencil 搭配来做笔记”的回答。虽然所展示的做阅读笔记的方式让人感觉看起来很不错，但是自己实践起来却非常困难。主要有两个原因：一是文献阅读大部分是 PDF 文件，需要边读边在旁边做笔记，但是诸多因素限制了这一目标的实现；二是在 iPad 上书写与在纸质上书写存在较大的不同，无法有相同的感觉，也无法获得相同的效果。因此，本人采用的文献管理方法依旧比较传统，大部分文献还是要打印出来，然后在纸质上边读边做笔记。唯独在文献引用管理上借助一下工具 Mendeley。</p>

<h3 id="pdf-文件的管理">PDF 文件的管理</h3>

<p>  首先 PDF 文件的命名需要有比较好的规范。比如说，可以按照“(期刊简写) 文献标题.pdf”的格式来命名所有文献。这样一来，相同期刊的文献就会排列在一起，再按照字母顺序进行排列。同时为了很好地区分某些专题或系列文献，可以建立一个单独的文件夹，将它们放进去。这样的好处是想要哪个方向的文献可以在很小的范围找到，不好的地方是如果只想找文献中的一个小细节，那么可能不大容易与文件夹名字联系起来。另外，使用网盘进行同步也是非常有必要的。这样可以在没有常用电脑在身边的时候，也可以在网盘上找到想要的文献。</p>

<h3 id="mendeley-的使用">Mendeley 的使用</h3>

<p>  Mendeley 是一款完全免费的文献管理软件。</p>

<ul>
  <li>Mendeley 客户端不仅可以从 PDF 文件或引用条目中自动识别文献的相关信息，还可以直接打开 PDF 文件进行阅读。如果不是很强调软件的界面，可能你就不需要其他的 PDF 阅读软件了。</li>
  <li>Mendeley 提供文献同步功能，当你将文献放到 Mendeley 客户端或者上传到网页上时，会自动同步所有登录设备。只不过同步的容量有所限制，5 GB 左右。如果你只将引用条目导入 Mendeley 的话，这样的容量完全是非常充足的。</li>
  <li>Mendeley 与 Microsoft Office 完全无缝兼容，支持在撰写论文时直接从你的库里选择文献并自动生成引用。当然，你也可以选择你要投递的期刊，Mendeley 会帮你自动转换引用格式。</li>
</ul>

<p>  和 Mendeley 类似的文献管理软件也有很多，比如 RefWorks、Endnote、Citavi 等等。相比之下，其他大部分文献管理软件都是收费的。不过有些学校也会买某个软件的版权，只要你还是在校生，都可以使用。</p>

<h2 id="结束语">结束语</h2>

<p>  在看完以上的内容之后，相信你对科学文献相关的一些问题可能能得到解答了吧。如果存在什么疑问也不要紧，在实践的过程中不断总结和扩展自己的知识面，相信很快就可以把问题都解决了。</p>

<p>  加油💪🏻💪🏻💪🏻</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://www.carsi.edu.cn/aboutCARSI.html">CARSI &amp; eduGAIN</a></li>
  <li><a href="https://www.biomart.cn/experiment/793/2714581.htm">6 款主流文献管理软件测评</a></li>
  <li><a href="http://wr.lib.tsinghua.edu.cn/">清华大学图书馆推荐网络学术站点</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="ac" /><category term="experience" /><category term="Paper" /><category term="Reading" /><category term="manage" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">私有代码托管平台的搭建与运维</title><link href="https://lisz.me/tech/docker/gitlab.html" rel="alternate" type="text/html" title="私有代码托管平台的搭建与运维" /><published>2021-08-02T08:10:00+09:00</published><updated>2021-08-02T08:10:00+09:00</updated><id>https://lisz.me/tech/docker/gitlab</id><content type="html" xml:base="https://lisz.me/tech/docker/gitlab.html"><![CDATA[<h2 id="前言">前言</h2>

<h3 id="版本控制">版本控制</h3>

<p>  当我们谈到代码托管平台，我们不得不先谈一谈“版本控制”。什么是“版本控制”？版本控制是一种记录一个或若干内容变化，以便将来查阅特定版本修订情况的系统。在我们日常的编写代码过程或者工作中，版本控制显得尤为重要。有了它你就可以将选定的文件回溯到之前的状态，甚至可以将整个项目代码都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。使用版本控控制系统通常还意味着，就算你胡乱处理项目中的文件，你也照样可以轻松回复到原先的养殖，而且额外增加的工作量却是微乎其微。</p>

<p>  其实除了代码之外，任何文件都可以加入版本控制。比如像最新的 Office 365 中，如果将文件放在与 Onedrive 同步的文件夹中，那么 Office 365 不但会时不时为你自动保存文件，而且会把每一次的保存都记录下来，同时在你关闭文档时记录为一个版本。</p>

<p>  回过头来看版本控制系统，它主要可以分为本地版本控制系统、集中化的版本控制系统和分布式版本控制系统。</p>

<h4 id="本地版本控制系统">本地版本控制系统</h4>

<p>  举个例子，当我在写论文或者做 PPT 的时候，我习惯在文件名的最后加上完成年月日以示区分。这样做的唯一好处就是简单便捷，但是特别容易犯错，尤其是需要和之前的版本进行交叉修改的时候。为了解决这种问题，很久以前就有许多中本地版本控制系统被开发出来，其中大多数都是采用某种简单的数据库来记录文件的历次更新差异。其中最流行的一种叫做 RCS，现今许多计算机系统上还看得到它的踪影。RCS 的工作原理是在硬盘上保留补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。我们常用的网盘的增量同步就是采用了这种方式，网盘同步工具会在同步的主目录建立一个文件来描述本地文件的修订情况，在联网之后与远程服务器的信息进行对比就能发现本地文件与远程文件是否一致。如果两个文件的 MD5 值相同则可以说明文件无须操作，如果不同则根据时间戳来判断哪个文件最新，并将最新的文件更新给另一方。</p>

<p><img src="https://git-scm.com/book/en/v2/images/local.png" alt="local-version" /></p>

<h4 id="集中化的版本控制系统">集中化的版本控制系统</h4>

<p>  以上的本地版本控制系统也有一定的局限性，比如无法让不同系统上的开发者协同工作。于是就有了集中化的版本控制系统（CVCS）。比较有名的像 Subversion（SVN），CVS 等等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人脉通常通过客户端连接到这台服务器，取出最新的文件或者提交更新。在 Git 没有被发明出来之前，这是主要的版本控制系统的标准，而且主要以 SVN 使用者最多。</p>

<p>  这样一来，的确在某种程度上提供了多人开发协同的功能，但是如果中央服务器发生了故障，那么谁也无法提交更新或者协同工作。如果磁盘发生损坏且未进行实时备份，毫无疑问所有或者一部分数据都会丢失。</p>

<p><img src="https://git-scm.com/book/en/v2/images/centralized.png" alt="central-version" /></p>

<h4 id="分布式版本控制系统">分布式版本控制系统</h4>

<p>  于是分布式版本控制系统（DVCS）应运而生，其中比较知名的有 Git、Mercurial、Bazaar 等等。在这类系统中，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录、这样一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>

<p>  关于 Git 的诞生有个小故事一直被人津津乐道。Linux 内核开源项目有着众多的参与者，但是早期（1991~2002 年间）绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上。从 2002 年开始，整个项目组开始启用一个专门的分布式版本控制系统 BitKeeper 来管理和维护代码。到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核开源社区免费使用 BitKeeper 的权利。于是 Linux 的缔造者 Linus 决定闭关开发一款自己的版本控制系统。一个星期后 Git 就诞生了。Git 的目标是速度、简单的设计、对非线性开发模式的强力支持、完全分布式、有能力高效管理类似 Linux 内核一样的超大规模项目，因此它的速度非空，极其适合管理大项目。</p>

<p>  Git 诞生以前几乎是 SVN 占据了开源届版本控制系统的江山，但之后随着 Git 的诞生与日臻完善，版本控制系统的天下早已被 Git 收入囊中。就连原来以 SVN 作为版本控制系统的 <a href="https://sf.net/">SourceForge</a> 和以 Mercurial 作为版本控制系统的 <a href="https://bitbucket.org/">Bitbucket</a> 都相继支持 Git。</p>

<p><img src="https://git-scm.com/book/en/v2/images/distributed.png" alt="distributed-version" /></p>

<h3 id="git-私有代码托管平台解决方案">Git 私有代码托管平台解决方案</h3>

<p>  目前公有代码托管平台国外主要有 <a href="https://github.com">Github</a>、<a href="https://gitlab.com">Gitlab</a>、<a href="https://sf.net">SourceForge</a>、<a href="https://bitbucket.org/">Bitbucket</a> 等，国内主要有 <a href="https://gitee.com">Gitee</a>、<a href="https://coding.net">Coding</a>、<a href="https://code.aliyun.com/">阿里云 Code</a> 等。其中，Github、SourceForge、Bitbucket、Gitee 都提供商业化的 Git 私有代码托管平台解决方案，只有 Gitlab 提供开源的 Git 私有代码托管平台解决方案，其他平台暂不了解是否有相应的解决方案。</p>

<p>  除了 Gitlab 这家开源的解决方案之外，其实还有 <a href="https://gogs.io/">gogs</a>、<a href="https://gitea.io/">Gitea</a> 等。Gitlab CE 版本提供了与 Gitlab EE 几乎一样的功能，并包含了非常丰富的特性，比如 Pages（静态页面托管）、Oauth2（第三方应用登录验证）、CI（持续集成）、CD（持续部署）等。相比之下，gogs 或者 Gitea 则偏向于更加基础、精悍的 Git 私有代码托管平台解决方案。从 Gitea 提供的 <a href="https://docs.gitea.io/en-us/comparison/">Gitea compared to other Git hosting options</a> 一文可以看出，Gitlab CE、Gitlab EE 与 Github EE 事实上是特性最为丰富的，Gitea 除了不支持 Pages、内置容器 Registry、内置 CI/CD、提交人身份验证等特性之外，还是支持大部分特性的。考虑到未来可能出现的更加复杂的应用场景需求，比如 JupyterLab 的 Oauth2 登录验证等，这里我们采用了 Gitlab CE 的解决方案。</p>

<p>  随着 Docker 的广泛使用和发展，Gitlab CE 官方也提供了 Docker 化的部署方式，但是相比较而言，由 sameersbn 提供的 <a href="https://github.com/sameersbn/docker-gitlab">sameersbn/docker-gitlab</a> 更加适合实践。主要的理由有以下两点：</p>
<ul>
  <li>对 Gitlab CE 的多个组成部分包括数据库、缓存数据库、应用进行了分离，解耦程度更高，更有利于应用本身的独立升级。</li>
  <li>Gitlab CE 应用的升级并非只是镜像的更新，还涉及到应用容器实例启动后的内部数据库和文件的更新，<a href="https://github.com/sameersbn/docker-gitlab">sameersbn/docker-gitlab</a> 提供了一键式的部署和更新，让用户无须关注容器内部的操作。唯一值得注意的是，Gitlab 的版本升级是具有路线图的，当跨版本升级的时候需要根据官方给出的路线图逐步迭代更新，<strong>不能直接从一个旧版本直接升级到最新版本</strong>。</li>
</ul>

<h2 id="平台搭建">平台搭建</h2>

<p>  由于这里采用了 Docker 化的方式进行部署 Gitlab CE，所以预先需要安装 Docker 环境 和 docker-compose 工具，这里不对此进行赘述。</p>

<h3 id="准备">准备</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 为 Gitlab 创建一个目录用于放置应用配置和数据</span>
<span class="nb">mkdir</span> ~/web/gitlab

<span class="c"># 下载 docker-compose.yml 文件</span>
wget <span class="nt">-c</span> https://raw.githubusercontent.com/sameersbn/docker-gitlab/master/docker-compose.yml
</code></pre></div></div>

<h3 id="修改配置">修改配置</h3>

<h4 id="镜像版本的设置">镜像版本的设置</h4>

<p>  编辑 docker-compose.yml 配置文件。配置文件包含了对于使用的各个容器镜像的定义，主要有三个：redis、postgresql、gitlab。由于缓存数据库与应用本身没有直接的影响，只是为了加快应用的访问响应速度，所以 redis 镜像一般是使用默认的最新镜像即可，可以使用具体的最新版本号，也可以直接使用 latest 标签。数据库这里采用的 postgresql 数据库，一般来说使用 sameersbn 构建的版本即可。由于 Gitlab 在 13.7.0 版本之后将 postgresql 最低版本的要求升级到了 12，所以现在一般 sammersbn/postgresql 镜像的版本标签都是 12-20200524，以前 postgresql 11 的时候对应的标签就是 11-20200524。gitlab 镜像的版本号主要是跟着 Gitlab 的本身的版本升级而变化，但是由于 Gitlab 的版本更新比较频繁（Gitlab 素来有“版本帝”的称号），所以 sameersbn/gitlab 的版本更新可能不会包含每一个版本，但是已编译的版本标签是符合 Gitlab 官方的版本升级路线图的。</p>

<h4 id="数据持久化">数据持久化</h4>

<p>  这里为了使容器的数据能够持久化，一般来说会把挂载一个本地目录来对应容器的数据目录。当然 Docker 本身提供了 volume 的创建和管理，sameersbn 推荐的也是 volume 的方式挂载，但是考虑到实际的中心存储服务器来存储所有数据，仍然使用最原始的本地目录对应挂载。在下面的配置文件中，三个容器对应的数据目录都做了这项变动。</p>

<h4 id="随机秘钥">随机秘钥</h4>

<p>  由于 Gitlab 应用本身需要有三个随机字符串来分别完成数据库记录生成、密码加密、二次验证生成，所以这里建议使用 uuid 命令生成三个长随机字符串替代 GITLAB_SECRETS_DB_KEY_BASE 、GITLAB_SECRETS_SECRET_KEY_BASE、GITLAB_SECRETS_OTP_KEY_BASE 三个参数，如下所示。</p>

<h4 id="时区设置">时区设置</h4>

<p>  这里使用的时区默认是 sameersbn 所在的时区，如果需要改成中国，则 TZ 为 Asia/Shanghai ，GITLAB_TIMEZONE 为 Beijing。注意，中国时区的表示并不是 Asia/Beijing，而是 Asia/Shanghai。只用一个单词表示时区时，则使用 Beijing （北京时间）。</p>

<h4 id="端口和-ssl-设置">端口和 SSL 设置</h4>

<p>  在 gitlab 容器中实际上是有 Nginx 服务的，所以官方提供了自带的 SSL 加载方式。但是考虑到搭建 Gitlab 的服务器可能还要用于其他服务，所以这里的 80 和 22 端口将会修改成本地其他端口，而在宿主机上使用统一的 Nginx + SSL 来支持 SSL 化。虽然这样不需要把 SSL 证书挂载到容器内，但还是需要告诉容器启动 HTTPS （GITLAB_HTTPS）和实际使用的端口 (GITLAB_PORT 和 GITLAB_SSH_PORT)，否则在 UI 上显示的将是 HTTP 和 容器内部的端口。</p>

<h4 id="自动备份设置">自动备份设置</h4>

<p>  一般来说采用默认的“每天凌晨1点”策略自动备份即可，可以根据实际需求修改为不同的时间点或每周或每月。备份的压缩包会保存在 gitlab-data 目录下的 backups 目录里。</p>

<h4 id="pages-设置">Pages 设置</h4>

<p>  Pages 功能是 Gitlab CE 提供的一个非常实用的内部静态页面托管方案，不像 Github Pages 是完全公开的， Gitlab Pages 也可以根据 Gitlab 本身的用户验证来限制页面的访问权限。这里上面下载的配置文件中默认不包含 Pages 的配置，需要进行添加如下以 GITLAB_PAGES_ 开头的配置节。当开启 Pages 功能后，需要设定好对应的域名（建议二级域名，非主域名），并将该域名对应的通配符解析到 Gitlab 服务器。解析好后，普通项目的访问 URL 是 <a href="https://{username}.pages.example.com/{project}">https://{username}.pages.example.com/{project}</a>，比如项目 zhonger/zhonger 的 Pages 访问 URL 为 <a href="https://zhonger.pages.example.com/zhonger">https://zhonger.pages.example.com/zhonger</a>。如果项目名与前面的域名完全对应，那么就可以直接使用域名访问，无须带子目录，比如项目 zhonger/zhonger.pages.example.com 的 Pages 使用 <a href="https://zhonger.pages.example.com">https://zhonger.pages.example.com</a> 访问即可。</p>

<h4 id="相对路径配置">相对路径配置</h4>

<p>  如果想要把 Gitlab 服务与其他服务共用一个域名对外提供服务，那么就需要设置相对路径 GITLAB_RELATIVE_URL_ROOT。比如想要使用 <a href="https://example.com/git">https://example.com/git</a> 的 URL 访问 Gitlab 服务，那么就需要将相对路径的配置内容设为 /git。这里笔者没有这个需求，所以置空即可。注意，当使用相对路径配置时升级前最好将相对路径置空，待正常升级后再重新设置相对路径编译生效。编译过程可能比较长，大约十分钟左右。</p>

<h4 id="初始-root-密码配置">初始 root 密码配置</h4>

<p>  GITLAB_ROOT_PASSWORD 配置节为初始管理员用户（root）密码，如果置空则为 Gitlab 官方常用默认密码 <strong>5iveL!fe</strong>。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">2.3'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">redis</span><span class="pi">:</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis:6.2</span>
    <span class="na">command</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">--loglevel warning</span>
    <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./redis-data:/data</span>

  <span class="na">postgresql</span><span class="pi">:</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">sameersbn/postgresql:12-20200524</span>
    <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./postgresql-data:/var/lib/postgresql</span>
    <span class="na">environment</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">DB_USER=gitlab</span>
    <span class="pi">-</span> <span class="s">DB_PASS=password</span>
    <span class="pi">-</span> <span class="s">DB_NAME=gitlabhq_production</span>
    <span class="pi">-</span> <span class="s">DB_EXTENSION=pg_trgm,btree_gist</span>

  <span class="na">gitlab</span><span class="pi">:</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">sameersbn/gitlab:14.1.1</span>
    <span class="na">depends_on</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">redis</span>
    <span class="pi">-</span> <span class="s">postgresql</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s2">"</span><span class="s">10080:80"</span>
    <span class="pi">-</span> <span class="s2">"</span><span class="s">10022:22"</span>
    <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">./gitlab-data:/home/git/data</span>
    <span class="na">healthcheck</span><span class="pi">:</span>
      <span class="na">test</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">CMD"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">/usr/local/sbin/healthcheck"</span><span class="pi">]</span>
      <span class="na">interval</span><span class="pi">:</span> <span class="s">5m</span>
      <span class="na">timeout</span><span class="pi">:</span> <span class="s">10s</span>
      <span class="na">retries</span><span class="pi">:</span> <span class="m">3</span>
      <span class="na">start_period</span><span class="pi">:</span> <span class="s">5m</span>
    <span class="na">environment</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">DEBUG=false</span>

    <span class="pi">-</span> <span class="s">DB_ADAPTER=postgresql</span>
    <span class="pi">-</span> <span class="s">DB_HOST=postgresql</span>
    <span class="pi">-</span> <span class="s">DB_PORT=5432</span>
    <span class="pi">-</span> <span class="s">DB_USER=gitlab</span>
    <span class="pi">-</span> <span class="s">DB_PASS=password</span>
    <span class="pi">-</span> <span class="s">DB_NAME=gitlabhq_production</span>

    <span class="pi">-</span> <span class="s">REDIS_HOST=redis</span>
    <span class="pi">-</span> <span class="s">REDIS_PORT=6379</span>

    <span class="pi">-</span> <span class="s">TZ=Asia/Shanghai</span>
    <span class="pi">-</span> <span class="s">GITLAB_TIMEZONE=Beijing</span>

    <span class="pi">-</span> <span class="s">GITLAB_HTTPS=true</span>
    <span class="pi">-</span> <span class="s">SSL_SELF_SIGNED=false</span>

    <span class="pi">-</span> <span class="s">GITLAB_HOST=localhost</span>
    <span class="pi">-</span> <span class="s">GITLAB_PORT=10080</span>
    <span class="pi">-</span> <span class="s">GITLAB_SSH_PORT=10022</span>
    <span class="pi">-</span> <span class="s">GITLAB_RELATIVE_URL_ROOT=</span>
    <span class="pi">-</span> <span class="s">GITLAB_SECRETS_DB_KEY_BASE=fd6d127c-f4ce-11eb-8163-1e008a0e6985</span>
    <span class="pi">-</span> <span class="s">GITLAB_SECRETS_SECRET_KEY_BASE=03221924-f4cf-11eb-a75e-1e008a0e6985</span>
    <span class="pi">-</span> <span class="s">GITLAB_SECRETS_OTP_KEY_BASE=07d5caec-f4cf-11eb-ab3b-1e008a0e6985</span>

    <span class="pi">-</span> <span class="s">GITLAB_ROOT_PASSWORD=root@root</span>
    <span class="pi">-</span> <span class="s">GITLAB_ROOT_EMAIL=root@example.com</span>

    <span class="pi">-</span> <span class="s">GITLAB_NOTIFY_ON_BROKEN_BUILDS=true</span>
    <span class="pi">-</span> <span class="s">GITLAB_NOTIFY_PUSHER=false</span>

    <span class="pi">-</span> <span class="s">GITLAB_EMAIL=notifications@example.com</span>
    <span class="pi">-</span> <span class="s">GITLAB_EMAIL_REPLY_TO=noreply@example.com</span>
    <span class="pi">-</span> <span class="s">GITLAB_INCOMING_EMAIL_ADDRESS=reply@example.com</span>

    <span class="pi">-</span> <span class="s">GITLAB_BACKUP_SCHEDULE=daily</span>
    <span class="pi">-</span> <span class="s">GITLAB_BACKUP_TIME=01:00</span>

    <span class="pi">-</span> <span class="s">GITLAB_SHARED_DIR=/home/git/data/shared</span>
    <span class="pi">-</span> <span class="s">GITLAB_PAGES_ENABLED=true</span>
    <span class="pi">-</span> <span class="s">GITLAB_PAGES_DOMAIN=pages.example.com</span>
    <span class="pi">-</span> <span class="s">GITLAB_PAGES_DIR=$GITLAB_SHARED_DIR/pages</span>
    <span class="pi">-</span> <span class="s">GITLAB_PAGES_PORT=80</span>
    <span class="pi">-</span> <span class="s">GITLAB_PAGES_HTTPS=true</span>

    <span class="s">.....</span>
</code></pre></div></div>

<h3 id="启动与测试">启动与测试</h3>

<p>  在 ~/web/gitlab/ 目录使用以下命令拉取并启动所有容器实例。如果已经在宿主机的 Nginx 上预先配置好 Gitlab 访问域名 git.example.com 以及 SSL 证书，则可以使用 <a href="https://git.example.com">https://git.example.com</a> 直接访问启动好的 Gitlab。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up <span class="nt">-d</span>
</code></pre></div></div>

<h3 id="gitlab-runner">Gitlab Runner</h3>

<p>  Gitlab CE 提供的 Pages 功能必须与 Gitlab Runner 一起联合使用，否则源代码无法编译成静态页面，从而无法正常提供 Pages 功能。虽然 Gitlab Runner 有好几种方式，但是为了避免对于服务器的环境的破坏和支持更多的源码编译环境，这里建议采用 docker 方式启动 Gitlab runner。</p>

<h4 id="启动">启动</h4>

<p>  使用以下命令拉取并启动 gitlab-runner 的最新镜像。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-d</span> <span class="nt">--name</span> gitlab-runner <span class="nt">--restart</span> always <span class="se">\</span>
  <span class="nt">-v</span> /srv/gitlab-runner/config:/etc/gitlab-runner <span class="se">\</span>
  <span class="nt">-v</span> /var/run/docker.sock:/var/run/docker.sock <span class="se">\</span>
  <span class="nt">-n</span> gitlab-runner <span class="se">\</span>
  gitlab/gitlab-runner:latest
</code></pre></div></div>

<h4 id="配置">配置</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 进入 gitlab-runner 容器</span>
docker <span class="nb">exec</span> <span class="nt">-ti</span> gitlab-runner register
<span class="c"># 根据提示输入内容</span>
<span class="c"># 输入 Gitlab 服务的 URL，比如 https://git.example.com</span>
<span class="c"># 输入 Token，可以在 Gitlab 的管理员配置的 Runner 里面看到</span>
<span class="c"># 输入描述，根据实际自行设定，可以是主机别名</span>
<span class="c"># 输入与该 runner 绑定的标签 tag，可以输入一个或空格间隔多个，也可以置空（建议）</span>
<span class="c"># 选择 runner executor 为 docker</span>
<span class="c"># 输入默认的编译环境镜像，比如 python:alpine</span>
</code></pre></div></div>

<h2 id="平台运维">平台运维</h2>

<h3 id="升级">升级</h3>

<h4 id="升级路线规划">升级路线规划</h4>

<p>  前面已经提到过 Gitlab 的升级实际上是要遵循 Gitlab 官方提供的路线图的，即按版本逐步迭代升级，具体可以查看 <a href="https://docs.gitlab.com/ce/update/#upgrade-paths">Upgrade-paths</a>。截止到文章撰写之时，Gitlab 的版本升级主要路线为：8.11.Z -&gt; 8.12.0 -&gt; 8.17.7 -&gt; 9.5.10 -&gt; 10.8.7 -&gt; 11.11.8 -&gt; 12.0.12 -&gt; 12.1.17 -&gt; 12.10.14 -&gt; 13.0.14 -&gt; 13.1.11 -&gt; latest 13.12.Z -&gt; latest 14.0.Z -&gt; 14.1.Z -&gt; latest 14.Y.Z。这里的 Z 指的是该主要版本的最后一个次要版本，Y 指的是最新的主要版本。Gitlab 的版本可以通过 <a href="https://docs.gitlab.com/ce/update/#version-specific-upgrading-instructions">Version-specific upgrading instructions</a> 和 <a href="https://about.gitlab.com/releases/categories/releases/">Releases</a> 来确认。当然，在文档中我们也可以看到一些具体的版本升级路线的示例。如果我们当前的版本符合某一条升级路线，那么可以直接按照示例中的路线逐步升级。如果不符合则需要自行根据主要路线进行确认。</p>

<p>  这里我们以当前版本 13.2.6 想要升级到 13 主要版本的最后一个次要版本 13.12.4 为例进行尝试。首先查阅一下 <a href="https://github.com/sameersbn/docker-gitlab/tags">sameersbn/docker-gitlab</a> 的版本号，发现如下：</p>
<ul>
  <li>13.2.6 为 13.2.Z 的最后一个修补（patch）版本</li>
  <li>自 13.7.0 版本开始 <a href="https://github.com/sameersbn/docker-gitlab">sameersbn/docker-gitlab</a> 采用 Postgresql 12</li>
  <li>13.12.4 是 13 主要（Major）版本中的最后一个次要（Minor）版本</li>
</ul>

<p>  根据以上的升级主要路线可知，从 13.2.6 版本到 13.12.4 其实一步到位升级也是可行的。但是实际上 13.2.6 版本对应的 postgresql 的版本还在 11，而从 13.7.0 版本之后开始升级到 12。根据 Gitlab 遵循的版本号命名规则，地位代表主要版本，第二位代表次要版本，第三位代表修补版本，并且每个次要版本的最后一个修补版本可以认为是稳定版本。在同一个主要版本内，从一个稳定次要版本升级到稳定次要版本被认为是稳定可行的。所以可以设定升级路线为：13.2.6 -&gt; 13.7.4 -&gt; 13.12.4。</p>

<h4 id="边备份边升级">边备份边升级</h4>

<p>  Gitlab 的备份还原需要是在与备份对应的版本上做的。如果因为升级失败而需要使用旧版本的备份还原，需要移除失败版本所用的文件夹及文件，并启动一个对应版本的新实例然后进行备份还原。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 首先对 13.2.6 版本进行备份</span>
docker-compose run <span class="nt">--rm</span> gitlab app:rake gitlab:backup:create <span class="c"># 将会进行手动备份</span>

<span class="c"># 修改 docker-compose.yml 中的 gitlab 镜像版本为 13.7.4，</span>
<span class="c"># 同时修改 postgresql 的镜像版本为 12-20200524</span>
<span class="c"># 销毁旧版本的实例集群并启动新的实例集群</span>
docker-compose down <span class="o">&amp;&amp;</span> docker-compose up <span class="nt">-d</span>
<span class="c"># 等待镜像完成数据库迁移和前端样式库生成，并自动重启各项服务</span>
<span class="c"># 查询应用实例的状态</span>
docker logs gitlab_gitlab_1
<span class="c"># 访问界面，登录验证，确认实例升级成功</span>

<span class="c"># 对 13.7.4 版本进行备份</span>
docker-compose run <span class="nt">--rm</span> gitlab app:rake gitlab:backup:create <span class="c"># 将会进行手动备份</span>

<span class="c"># 修改 dockerc-compose.yml 中的 gitlab 镜像版本为 13.12.4，</span>
<span class="c"># 同时修改 redis 的镜像版本为 6.2，之前 redis 的镜像版本为 5.0.9</span>
<span class="c"># 销毁旧版本的实例集群并启动新的实例集群</span>
docker-compose down <span class="o">&amp;&amp;</span> docker-compose up <span class="nt">-d</span>
<span class="c"># 等待镜像完成数据库迁移和前端样式库生成，并自动重启各项服务</span>
<span class="c"># 查询应用实例的状态</span>
docker logs gitlab_gitlab_1
<span class="c"># 访问界面，登录验证，确认实例升级成功</span>
</code></pre></div></div>

<p>  如果在升级之后发现升级失败或新版本中某些组件有问题想要回滚，就需要利用刚才升级过程中提前备份好的数据还原备份了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 复制刚才备份的所有数据文件到当前工作目录</span>
<span class="nb">cp </span>gitlab/backups/<span class="k">*</span>.tar ./
<span class="c"># 销毁所有实例</span>
docker-compose down
<span class="c"># 移除本地持久化文件夹及文件</span>
<span class="nb">sudo rm</span> <span class="nt">-rf</span> gitlab postgresql redis

<span class="c"># 修改 docker-compose.yml 中的配置到想要回滚的备份数据对应的版本</span>
<span class="c"># 此处注意三个镜像版本的对应修改</span>
<span class="c"># 启动实例集群</span>
docker-compose up <span class="nt">-d</span>
<span class="c"># 复制备份数据到新实例的备份文件夹</span>
<span class="nb">cp</span> ./<span class="k">*</span>.tar gitlab/backups
<span class="c"># 执行恢复数据操作</span>
docker-compose run <span class="nt">--rm</span> gitlab app:rake gitlab:backup:restore <span class="c"># 将会看到可用备份列表</span>
</code></pre></div></div>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://git-scm.com/book/zh/v2/">《Pro Git》</a></li>
  <li><a href="https://github.com/sameersbn/docker-gitlab">sameersbn/docker-gitlab</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="docker" /><category term="Git" /><category term="Gitlab" /><category term="docker" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">JupyterLab 的搭建与运维</title><link href="https://lisz.me/tech/docker/jupyterlab.html" rel="alternate" type="text/html" title="JupyterLab 的搭建与运维" /><published>2021-07-25T08:20:00+09:00</published><updated>2021-07-25T08:20:00+09:00</updated><id>https://lisz.me/tech/docker/jupyterlab</id><content type="html" xml:base="https://lisz.me/tech/docker/jupyterlab.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  <a href="https://jupyter.org/">Jupyter</a>， 想必大家对这个项目都耳熟能详吧。因为能够实时交互、支持异构计算、部署简单、几乎无运维成本，所以得到了很多人的青睐。笔者的身边也有很多从事科学研究的人选择了 Jupyter 作为编写 Python 的工具，当然也有一部分人选择了 <a href="https://www.jetbrains.com/pycharm/">PyCharm</a>。不过笔者还是比较喜欢 <a href="https://code.visualstudio.com/">VS Code</a>，简单的纯文本编辑功能，利用丰富的插件市场来添加各种想要的功能，无缝支持远程开发，简直就是理想中的编辑器了。但是，今天还是要来考虑一下 Jupyter，毕竟 JupyterLab 的服务功能也是非常强大的。</p>

<p>  在 Jupyter 出现之前，也有可以替代 Python 自带的 Python Shell 的 <a href="https://ipython.org/">IPython</a>。笔者在早期也曾使用过，体验还不错。其实，Jupyter 就是2014 年从 IPython 中衍生出来的，所以从 IPython 过渡到 Jupyter 毫无困难。如果说 IPython 是为了 Python 而量身定制的话，那么 Jupyter 则是为包括 Julia、Python、R 在内的几十种编程语言（<a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels">详情连接</a>）的交互式数据科学和科学计算而生的。</p>

<p>  早期的 Jupyter 只包含 Jupyter Kernels 和 Jupyter Notebook，其中 Jupyter Kernels 是用于支持编程语言的内核，Jupyter Notebook 是基于 Web 的交互式计算环境，前身是 IPython Notebook。现在的 Jupyter 除了这两者以外还有 JupyterHub、JupyterHub API 和 JupyterLab。JupyterHub 是一个用于 Jupyter Notebook 的多用户服务器。它通过生成、管理和代理许多单一的 Jupyter Notebook 服务器来支持多用户。JupyterHub API 是以 REST 风格向开发者们提供的 API 接口，可以完成一系列对 Jupyter 的操作，比如生成用户环境、配置环境等。JupyterLab 号称是 Jupyter 项目的下一代用户界面，它以一个灵活且强大的用户界面向用户提供经典的 Jupyter Notebook、终端、编辑器、文件浏览器、丰富输出等模块，俨然像是朝着现代化的理想编辑器的目标进发的。</p>

<p>  无论之前的 Jupyter 是什么样子，现在的 JupyterLab 已经是和曾经的 Cloud9 （一款先进的在线代码编辑器，现已被 AWS 收购）一样的支持多用户多实例的代码运行平台。对于从事科学研究的团队来说，使用 JupyterLab 搭建一个内部科学计算平台成为了可能。当然，个人用户还是可以选择使用 Anaconda 或者 PIP 来安装单用户版本。</p>

<h2 id="搭建">搭建</h2>

<p>  说到搭建平台自然而然想到了使用 Docker，既可以保证用户对自己所需的软件或环境可以修改，又保证不同用户之间互不干扰、宿主机与 Jupyter 之间互不干扰。虽说 Jupyter 官方提供了一个使用 Docker 来部署 Jupyter 各个产品的<a href="https://jupyter-docker-stacks.readthedocs.io/">文档网站</a>，但不得不说即使看了这个文档也很难搞清楚到底怎么部署一套 JupyterLab。可能唯一有用的就是 Jupyter 官方提供的镜像构建 <a href="https://github.com/jupyter/docker-stacks">Dockerfile 集合</a> 吧。</p>

<p>  JupyterLab 提供两种方式启动多用户多实例：</p>
<ul>
  <li><strong>DockerSpawner 方式</strong>：每个用户独享一个 Docker 实例，能有效隔离用户。</li>
  <li><strong>SystemSpawner 方式</strong>：共享同一个 Docker 实例，以系统用户身份运行。</li>
</ul>

<p>  事实上，既然我们选择了用 Docker 来部署，自然而然应该选择 DockerSpawner 方式了。JupyterLab 中主要实现多用户多实例功能的是 JupyterHub 模块（如下图）。JupyterHub 模块为整个 JupyterLab 对外提供了一个共同的 HTTP 接口，并可以进行用户鉴权和为通过鉴权的用户创建一个新的 Docker 实例。笔者在这里主要是使用 Gitlab 方式鉴权登录，图中涉及到 Admin 以及数据库这里不作探讨。</p>

<p><img src="https://jupyterhub.readthedocs.io/en/stable/_images/jhub-fluxogram.jpeg" alt="JupyterHub 架构图" /></p>

<p>  以下为搭建所需的文件的列表：</p>

<p><img src="https://i.vgy.me/4pnx0D.png" alt="vgy.me" /></p>

<h3 id="构建-jupyter-notebook-实例镜像">构建 Jupyter Notebook 实例镜像</h3>

<h4 id="基础镜像-base-notebook">基础镜像 base-notebook</h4>

<p>  这里的基础镜像可以根据需要自行选择，与 <a href="https://github.com/jupyter/docker-stacks/tree/master/base-notebook">jupyter/docker-stacks</a> 相比镜像构建 Dockerfile 有些内容做了修改，本目录下其他文件和 <a href="https://github.com/jupyter/docker-stacks/tree/master/base-notebook">base-notebook 目录</a>一致。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Dockerfile</span>
<span class="s">ARG ROOT_CONTAINER=nvidia/cuda:10.2-devel-ubuntu18.04</span>

<span class="s">ARG BASE_CONTAINER=$ROOT_CONTAINER</span>
<span class="s">FROM $BASE_CONTAINER</span>

<span class="s">ARG NB_USER="ubuntu"</span>
<span class="s">ARG NB_UID="1000"</span>
<span class="s">ARG NB_GID="100"</span>

<span class="c1"># Fix DL4006</span>
<span class="s">SHELL ["/bin/bash", "-o", "pipefail", "-c"]</span>

<span class="s">USER root</span>

<span class="c1"># Install all OS dependencies for notebook server that starts but lacks all</span>
<span class="c1"># features (e.g., download as all possible file formats)</span>
<span class="s">ENV DEBIAN_FRONTEND noninteractive</span>
<span class="s">RUN apt-get update \</span>
    <span class="s">&amp;&amp; apt-get install -yq --no-install-recommends wget htop vim bzip2 ca-certificates sudo locales fonts-liberation run-one \</span>
    <span class="s">&amp;&amp; apt-get clean \</span>
    <span class="s">&amp;&amp; rm -rf /var/lib/apt/lists/*</span>

<span class="s">RUN echo "en_US.UTF-8 UTF-8" &gt; /etc/locale.gen &amp;&amp; \</span>
    <span class="s">locale-gen</span>

<span class="c1"># Configure environment</span>
<span class="s">ENV CONDA_DIR=/opt/conda \</span>
    <span class="s">SHELL=/bin/bash \</span>
    <span class="s">NB_USER=$NB_USER \</span>
    <span class="s">NB_UID=$NB_UID \</span>
    <span class="s">NB_GID=$NB_GID \</span>
    <span class="s">LC_ALL=en_US.UTF-8 \</span>
    <span class="s">LANG=en_US.UTF-8 \</span>
    <span class="s">LANGUAGE=en_US.UTF-8</span>
<span class="s">ENV PATH=$CONDA_DIR/bin:$PATH \</span>
    <span class="s">HOME=/home/$NB_USER</span>

<span class="c1"># Copy a script that we will use to correct permissions after running certain commands</span>
<span class="s">COPY fix-permissions /usr/local/bin/fix-permissions</span>
<span class="s">RUN chmod a+rx /usr/local/bin/fix-permissions</span>

<span class="c1"># Enable prompt color in the skeleton .bashrc before creating the default NB_USER</span>
<span class="s">RUN sed -i 's/^#force_color_prompt=yes/force_color_prompt=yes/' /etc/skel/.bashrc</span>

<span class="c1"># Create NB_USER wtih name ubuntu user with UID=1000 and in the 'users' group</span>
<span class="c1"># and make sure these dirs are writable by the `users` group.</span>
<span class="s">RUN echo "auth requisite pam_deny.so" &gt;&gt; /etc/pam.d/su \</span>
    <span class="s">&amp;&amp; sed -i.bak -e 's/^%admin/#%admin/' /etc/sudoers \</span>
    <span class="s">&amp;&amp; sed -i.bak -e 's/^%sudo/#%sudo/' /etc/sudoers \</span>
    <span class="s">&amp;&amp; useradd -m -s /bin/bash -N -u $NB_UID $NB_USER -g $NB_GID \</span>
    <span class="s">&amp;&amp; mkdir -p $CONDA_DIR \</span>
    <span class="s"># &amp;&amp; chown $NB_USER:$NB_GID  \</span>
    <span class="s">&amp;&amp; chmod g+w /etc/passwd \</span>
    <span class="s">&amp;&amp; fix-permissions $HOME \</span>
    <span class="s">&amp;&amp; fix-permissions $CONDA_DIR \</span>
    <span class="s">&amp;&amp; adduser ubuntu sudo \</span>
    <span class="s">&amp;&amp; echo "ubuntu ALL=(ALL) NOPASSWD</span> <span class="err">:</span> <span class="s">ALL" | tee /etc/sudoers.d/nopasswd4sudo</span>

<span class="s">USER $NB_UID</span>
<span class="s">WORKDIR $HOME</span>
<span class="s">ARG PYTHON_VERSION=default</span>

<span class="c1"># Setup work directory for backward-compatibility</span>
<span class="s">RUN mkdir /home/$NB_USER/work &amp;&amp; \</span>
    <span class="s">fix-permissions /home/$NB_USER</span>

<span class="c1"># Install conda as ubuntu and check the md5 sum provided on the download site</span>
<span class="s">ENV MINICONDA_VERSION=4.9.2 \</span>
    <span class="s">MINICONDA_MD5=122c8c9beb51e124ab32a0fa6426c656 \</span>
    <span class="s">CONDA_VERSION=4.9.2</span>

<span class="s">WORKDIR /tmp</span>
<span class="s">RUN wget --quiet https://repo.continuum.io/miniconda/Miniconda3-py38_${MINICONDA_VERSION}-Linux-x86_64.sh  \</span>
    <span class="s">&amp;&amp; echo "${MINICONDA_MD5} *Miniconda3-py38_${MINICONDA_VERSION}-Linux-x86_64.sh" | md5sum -c -  \</span>
    <span class="s">&amp;&amp; /bin/bash Miniconda3-py38_${MINICONDA_VERSION}-Linux-x86_64.sh -f -b -p $CONDA_DIR \</span>
    <span class="s">&amp;&amp; rm Miniconda3-py38_${MINICONDA_VERSION}-Linux-x86_64.sh \</span>
    <span class="s">&amp;&amp; echo "conda ${CONDA_VERSION}" &gt;&gt; $CONDA_DIR/conda-meta/pinned \</span>
    <span class="s">&amp;&amp; conda config --system --prepend channels conda-forge \</span>
    <span class="s">&amp;&amp; conda config --system --set auto_update_conda </span><span class="no">false</span><span class="s"> \</span>
    <span class="s">&amp;&amp; conda config --system --set show_channel_urls </span><span class="no">true</span><span class="s"> \</span>
    <span class="s">&amp;&amp; conda config --system --set channel_priority strict \</span>
    <span class="s">&amp;&amp; if [ ! $PYTHON_VERSION = 'default' ]; then conda install --yes python=$PYTHON_VERSION; fi \</span>
    <span class="s">&amp;&amp; conda list python | grep '^python ' | tr -s ' ' | cut -d '.' -f 1,2 | sed 's/$/.*/' &gt;&gt; $CONDA_DIR/conda-meta/pinned \</span>
    <span class="s">&amp;&amp; conda install --quiet --yes conda \</span>
    <span class="s">&amp;&amp; conda install --quiet --yes pip \</span>
    <span class="s">&amp;&amp; conda update --all --quiet --yes \</span>
    <span class="s">&amp;&amp; conda clean --all -f -y \</span>
    <span class="s">&amp;&amp; rm -rf /home/$NB_USER/.cache/yarn \</span>
    <span class="s">&amp;&amp; fix-permissions $CONDA_DIR \</span>
    <span class="s">&amp;&amp; fix-permissions /home/$NB_USER</span>

<span class="c1"># Install Tini</span>
<span class="s">RUN conda install --quiet --yes 'tini=0.18.0' \</span>
    <span class="s">&amp;&amp; conda list tini | grep tini | tr -s ' ' | cut -d ' ' -f 1,2 &gt;&gt; $CONDA_DIR/conda-meta/pinned \</span>
    <span class="s">&amp;&amp; conda clean --all -f -y \</span>
    <span class="s">&amp;&amp; fix-permissions $CONDA_DIR \</span>
    <span class="s">&amp;&amp; fix-permissions /home/$NB_USER</span>

<span class="c1"># Install Jupyter Notebook, Lab, and Hub</span>
<span class="c1"># Generate a notebook server config</span>
<span class="c1"># Cleanup temporary files</span>
<span class="c1"># Correct permissions</span>
<span class="c1"># Do all this in a single RUN command to avoid duplicating all of the</span>
<span class="c1"># files across image layers when the permissions change</span>
<span class="s">RUN conda install --quiet --yes \</span>
    <span class="s">'notebook=6.4.0' \</span>
    <span class="s">'jupyterhub=1.4.2' \</span>
    <span class="s">'jupyterlab=3.0.16' \</span>
    <span class="s">&amp;&amp; conda clean --all -f -y \</span>
    <span class="s">&amp;&amp; npm install -g npm@7.20.0 \</span>
    <span class="s">&amp;&amp; npm cache clean --force \</span>
    <span class="s">&amp;&amp; jupyter notebook --generate-config \</span>
    <span class="s">&amp;&amp; rm -rf $CONDA_DIR/share/jupyter/lab/staging \</span>
    <span class="s">&amp;&amp; rm -rf /home/$NB_USER/.cache/yarn \</span>
    <span class="s">&amp;&amp; fix-permissions $CONDA_DIR \</span>
    <span class="s">&amp;&amp; fix-permissions /home/$NB_USER</span>

<span class="s">EXPOSE </span><span class="m">8888</span>

<span class="c1"># Configure container startup</span>
<span class="s">ENTRYPOINT ["tini", "-g", "--"]</span>
<span class="s">CMD ["start-notebook.sh"]</span>

<span class="c1"># Copy local files as late as possible to avoid cache busting</span>
<span class="s">COPY start.sh start-notebook.sh start-singleuser.sh /usr/local/bin/</span>
<span class="s">COPY jupyter_notebook_config.py /etc/jupyter/</span>

<span class="c1"># Fix permissions on /etc/jupyter as root</span>
<span class="s">USER root</span>
<span class="s">RUN fix-permissions /etc/jupyter/</span>
<span class="s">RUN chmod +x /usr/local/bin/start-notebook.sh /usr/local/bin/start-singleuser.sh /usr/local/bin/start.sh</span>

<span class="c1"># Switch back to ubuntu to avoid accidental container runs as root</span>
<span class="s">USER $NB_UID</span>

<span class="s">WORKDIR $HOME</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> base-notebook:latest <span class="nb">.</span>
</code></pre></div></div>

<h4 id="单用户镜像-singleuser">单用户镜像 singleuser</h4>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Dockerfile</span>
<span class="s">ARG BASE_IMAGE=base-notebook:latest</span>
<span class="s">FROM $BASE_IMAGE</span>

<span class="s">ADD install_jupyterhub /tmp/install_jupyterhub</span>
<span class="s">ARG JUPYTERHUB_VERSION=master</span>
<span class="c1"># install pinned jupyterhub and ensure notebook is installed</span>
<span class="s">RUN </span><span class="no">true</span><span class="s"> &amp;&amp; \</span>
    <span class="s">python3 -m pip install notebook jupyterhub</span>
</code></pre></div></div>
<p>install_jupyterhub 脚本文件</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">subprocess</span> <span class="kn">import</span> <span class="n">check_call</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">V</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'JUPYTERHUB_VERSION'</span><span class="p">]</span>

<span class="n">pip_install</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">sys</span><span class="p">.</span><span class="n">executable</span><span class="p">,</span> <span class="s">'-m'</span><span class="p">,</span> <span class="s">'pip'</span><span class="p">,</span> <span class="s">'install'</span><span class="p">,</span> <span class="s">'--no-cache'</span><span class="p">,</span> <span class="s">'--upgrade'</span><span class="p">,</span>
    <span class="s">'--upgrade-strategy'</span><span class="p">,</span> <span class="s">'only-if-needed'</span><span class="p">,</span>
<span class="p">]</span>
<span class="k">if</span> <span class="n">V</span> <span class="o">==</span> <span class="s">'master'</span><span class="p">:</span>
    <span class="n">req</span> <span class="o">=</span> <span class="s">'https://github.com/jupyterhub/jupyterhub/archive/master.tar.gz'</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">version_info</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">V</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'.'</span><span class="p">)</span> <span class="p">]</span>
    <span class="n">version_info</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="s">'.'</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">version_info</span><span class="p">))</span>
    <span class="n">vs</span> <span class="o">=</span> <span class="s">'&gt;=%s,&lt;%s'</span> <span class="o">%</span> <span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">)</span>
    <span class="n">req</span> <span class="o">=</span> <span class="s">'jupyterhub%s'</span> <span class="o">%</span> <span class="n">vs</span>

<span class="n">check_call</span><span class="p">(</span><span class="n">pip_install</span> <span class="o">+</span> <span class="p">[</span><span class="n">req</span><span class="p">])</span>

</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> singleuser:latest <span class="nb">.</span>
</code></pre></div></div>

<h4 id="jupyterlab-单用户镜像-jupyter_lab_singleuser">JupyterLab 单用户镜像 jupyter_lab_singleuser</h4>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">ARG BASE_IMAGE=singleuser:latest</span>
<span class="s">FROM ${BASE_IMAGE}</span>

<span class="c1"># Install jupyterlab</span>
<span class="s">RUN conda update -n base conda \</span>
    <span class="s">&amp;&amp; conda install -c conda-forge jupyterlab</span>
<span class="s">RUN jupyter serverextension enable --py jupyterlab --sys-prefix</span>
<span class="s">USER root</span>
<span class="s">RUN chpasswd &lt;&lt;&lt; "ubuntu:ubuntu" \</span>
    <span class="s">&amp;&amp; sed -i 's/http:\/\/archive.ubuntu.com/https:\/\/mirrors.sjtug.sjtu.edu.cn/g' /etc/apt/sources.list \</span>
    <span class="s">&amp;&amp; apt update \</span>
    <span class="s">&amp;&amp; apt install -y git zsh vim \</span>
    <span class="s">&amp;&amp; usermod -s /bin/zsh ubuntu \</span>
    <span class="s">&amp;&amp; echo 'chown -R ubuntu:users /home/ubuntu/work' &gt;&gt; /usr/local/bin/start-notebook.sh</span>

<span class="c1"># Add supports for zsh and zh-CN language</span>
<span class="s">USER ubuntu</span>
<span class="s">RUN git clone https://gitee.com/mirrors/oh-my-zsh.git ~/.oh-my-zsh \</span>
    <span class="s">&amp;&amp; cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc \</span>
    <span class="s">&amp;&amp; sed -i "s/robbyrussell/bira/" ~/.zshrc \</span>
    <span class="s">&amp;&amp; wget -c https://jfds-1252952517.cos.ap-chengdu.myqcloud.com/jupyterhub/jupyterlab_language_pack_zh_CN-0.0.1.dev0-py2.py3-none-any.whl \</span>
    <span class="s">&amp;&amp; pip install jupyterlab_language_pack_zh_CN-0.0.1.dev0-py2.py3-none-any.whl \</span>
    <span class="s">&amp;&amp; rm jupyterlab_language_pack_zh_CN-0.0.1.dev0-py2.py3-none-any.whl</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> jupyter_lab_single:latest <span class="nb">.</span>
</code></pre></div></div>

<h3 id="构建-jupyterhub-镜像">构建 JupyterHub 镜像</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Dockerfile</span>

<span class="s">ARG BASE_IMAGE=jupyterhub/jupyterhub:latest</span>
<span class="s">FROM ${BASE_IMAGE}</span>

<span class="s">RUN pip install --no-cache --upgrade jupyter \</span>
    <span class="s">&amp;&amp; pip install --no-cache dockerspawner \</span>
    <span class="s">&amp;&amp; pip install --no-cache oauthenticator</span>
<span class="s">EXPOSE </span><span class="m">8000</span>
</code></pre></div></div>

<p>  这里配置挂载的本地目录为根据用户名而区分的目录，当 Gitlab 用户名中包含 <code class="language-plaintext highlighter-rouge">-</code> 时，<code class="language-plaintext highlighter-rouge">-</code> 会被转义为 <code class="language-plaintext highlighter-rouge">2d</code>。另外，这里的本地目录需要预先建立好，否则由于 Docker 自身的安全性而新建立的目录的所有者会是 root 用户，这样就不能够正常使用该目录。以下配置文件需放置在 docker-compose.yml 的同层目录 data 里面。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># jupyterhub_config.py
</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">oauthenticator.gitlab</span> <span class="kn">import</span> <span class="n">GitLabOAuthenticator</span>
<span class="n">c</span><span class="p">.</span><span class="n">JupyterHub</span><span class="p">.</span><span class="n">authenticator_class</span> <span class="o">=</span> <span class="n">GitLabOAuthenticator</span>
<span class="n">c</span><span class="p">.</span><span class="n">GitLabOAuthenticator</span><span class="p">.</span><span class="n">oauth_callback_url</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">"GITLAB_OAUTH_CALLBACK"</span><span class="p">)</span>
<span class="n">c</span><span class="p">.</span><span class="n">GitLabOAuthenticator</span><span class="p">.</span><span class="n">client_id</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">"GITLAB_API_CLIENT"</span><span class="p">)</span>
<span class="n">c</span><span class="p">.</span><span class="n">GitLabOAuthenticator</span><span class="p">.</span><span class="n">client_secret</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">"GITLAB_API_KEY"</span><span class="p">)</span>

<span class="n">c</span><span class="p">.</span><span class="n">JupyterHub</span><span class="p">.</span><span class="n">spawner_class</span> <span class="o">=</span> <span class="s">'dockerspawner.DockerSpawner'</span>
<span class="n">c</span><span class="p">.</span><span class="n">DockerSpawner</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="s">'jupyter_lab_singleuser:latest'</span>
<span class="n">c</span><span class="p">.</span><span class="n">DockerSpawner</span><span class="p">.</span><span class="n">environment</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">'GRANT_SUDO'</span><span class="p">:</span> <span class="s">'1'</span><span class="p">,</span>
  <span class="s">'UID'</span><span class="p">:</span> <span class="s">'0'</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">c</span><span class="p">.</span><span class="n">DockerSpawner</span><span class="p">.</span><span class="n">extra_create_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s">'user'</span><span class="p">:</span> <span class="s">'ubuntu'</span><span class="p">}</span>
<span class="n">c</span><span class="p">.</span><span class="n">DockerSpawner</span><span class="p">.</span><span class="n">extra_create_kwargs</span><span class="p">.</span><span class="n">update</span><span class="p">({</span> <span class="s">'command'</span><span class="p">:</span> <span class="s">"start-singleuser.sh --SingleUserNotebookApp.default_url=/lab"</span> <span class="p">})</span>
<span class="c1"># Mount the real user's Docker volume on the host to the notebook user's
# notebook directory in the container
</span><span class="n">notebook_dir</span> <span class="o">=</span> <span class="s">'/home/ubuntu/work'</span>
<span class="n">c</span><span class="p">.</span><span class="n">DockerSpawner</span><span class="p">.</span><span class="n">notebook_dir</span> <span class="o">=</span> <span class="n">notebook_dir</span>
<span class="n">c</span><span class="p">.</span><span class="n">DockerSpawner</span><span class="p">.</span><span class="n">volumes</span> <span class="o">=</span> <span class="p">{</span> <span class="s">'/home/data/jupyterhub/user-data-{username}'</span><span class="p">:</span> <span class="n">notebook_dir</span> <span class="p">}</span>
<span class="n">c</span><span class="p">.</span><span class="n">DockerSpawner</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s">'--allow-root'</span><span class="p">]</span>
<span class="n">c</span><span class="p">.</span><span class="n">DockerSpawner</span><span class="p">.</span><span class="n">remove_containers</span> <span class="o">=</span> <span class="bp">True</span>

<span class="c1">#network
</span><span class="n">network_name</span> <span class="o">=</span> <span class="s">'jupyterhub_network'</span>
<span class="n">c</span><span class="p">.</span><span class="n">DockerSpawner</span><span class="p">.</span><span class="n">use_internal_ip</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">c</span><span class="p">.</span><span class="n">DockerSpawner</span><span class="p">.</span><span class="n">network_name</span> <span class="o">=</span> <span class="n">network_name</span>
<span class="c1"># Pass the network name as argument to spawned containers
</span><span class="n">c</span><span class="p">.</span><span class="n">DockerSpawner</span><span class="p">.</span><span class="n">extra_host_config</span> <span class="o">=</span> <span class="p">{</span> <span class="s">'network_mode'</span><span class="p">:</span> <span class="n">network_name</span> <span class="p">}</span>

<span class="c1"># IP Configurations
</span><span class="n">c</span><span class="p">.</span><span class="n">JupyterHub</span><span class="p">.</span><span class="n">hub_ip</span>  <span class="o">=</span> <span class="s">'172.18.0.2'</span>
<span class="c1">#c.JupyterHub.port = 8000
</span></code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">2'</span>
<span class="na">services</span><span class="pi">:</span>
    <span class="na">jupyterhub</span><span class="pi">:</span>
        <span class="na">container_name</span><span class="pi">:</span> <span class="s">jupyterlab</span>
        <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
        <span class="na">build</span><span class="pi">:</span> <span class="s">./</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">jupyterhub:latest</span>
        <span class="na">ports</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s2">"</span><span class="s">8000:8000"</span>
        <span class="na">volumes</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">/var/run/docker.sock:/var/run/docker.sock</span>
            <span class="pi">-</span> <span class="s">./data/jupyterhub_config.py:/srv/jupyterhub/jupyterhub_config.py</span>
        <span class="na">networks</span><span class="pi">:</span>
            <span class="na">network</span><span class="pi">:</span>
                <span class="na">ipv4_address</span><span class="pi">:</span> <span class="s">172.18.0.2</span>
        <span class="na">environment</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">GITLAB_HOST=https://{Gitlab Domain}</span>
            <span class="pi">-</span> <span class="s">GITLAB_API_CLIENT=xxxxxx</span>
            <span class="pi">-</span> <span class="s">GITLAB_API_KEY=xxxxxx</span>
            <span class="pi">-</span> <span class="s">GITLAB_OAUTH_CALLBACK=https://{JupyterHub Domain}/hub/oauth_callback</span>
<span class="na">networks</span><span class="pi">:</span>
    <span class="na">network</span><span class="pi">:</span>
        <span class="na">driver</span><span class="pi">:</span> <span class="s">bridge</span>
        <span class="na">ipam</span><span class="pi">:</span>
            <span class="na">driver</span><span class="pi">:</span> <span class="s">default</span>
            <span class="na">config</span><span class="pi">:</span>
                <span class="pi">-</span> <span class="na">subnet</span><span class="pi">:</span> <span class="s">172.18.0.0/24</span>
                  <span class="na">gateway</span><span class="pi">:</span> <span class="s">172.18.0.1</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose up <span class="nt">-d</span>
</code></pre></div></div>

<h2 id="测试">测试</h2>

<p>  访问 <a href="https://{JupyterHub Domain}/">https://{JupyterHub Domain}/</a> 即可，点击登录按钮后跳转到 Gitlab 登录页，如果 Gitlab 已登录会自动跳回。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://zh.wikipedia.org/wiki/Jupyter">Jupyter - 维基百科</a></li>
  <li><a href="http://zsduo.com/archives/244.html">JupyterLab 3.0 正式发布，同时解决中文语言包下载不成功，汉化不成功的问题，jupyterlab-language-pack-zh-CN 安装失败解决方案</a></li>
  <li><a href="https://cyfeng.science/2021/01/15/jupyterlab-error-when-install-chinses-language-pack/">Jupyterlab 安装中文语言包失败</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/258724435">使用JupyterHub向多用户提供jupyter服务的思路</a></li>
  <li><a href="https://www.kaifa99.com/GitHub/article_117797">dockerspawner, 在 Docker 容器中，生成JupyterHub单用户服务器</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="docker" /><category term="JupyterLab" /><category term="Docker" /><category term="Gitlab" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">[原创]远程服务环境与本地环境互联</title><link href="https://lisz.me/tech/webmaster/remote-ssh.html" rel="alternate" type="text/html" title="[原创]远程服务环境与本地环境互联" /><published>2021-06-15T14:30:00+09:00</published><updated>2021-06-15T14:30:00+09:00</updated><id>https://lisz.me/tech/webmaster/remote-ssh</id><content type="html" xml:base="https://lisz.me/tech/webmaster/remote-ssh.html"><![CDATA[<h2 id="前言">前言</h2>

<h3 id="异地组网">异地组网</h3>

<p>  谈到“异地组网”这个问题，其实已经有很多成熟的解决方案，包括最简单的拉光纤物理相连、向日葵异地组网等等。这些解决方案虽然稳定性和使用体验都极度让人舒适，但是实现的代价略微有点大，尤其财大气粗的光纤物理直接相连。不过对于某些大公司的异地数据中心互联，这仍然是最被认可的解决方案。至于向日葵异地组网，有点类似于把远程服务环境和本地环境同时连入一个网络，然后在形式上实现局域网化。由于这一解决方案往往依赖于一个由第三方提供的中心节点服务，这种局域网的带宽、速度和使用体验很大程度上受限于购买的套餐级别。那么，是否存在一种造价较低，速度和使用体验都较佳的解决方案呢？答案自然是存在的，只是有点<strong>曲线</strong>而已。</p>

<h3 id="zerotier-组网">Zerotier 组网</h3>

<p>  在之前的一些文章中，我们已经体验了 Zerotier 带来的软件定义网络。这种软件定义网络方式，在某种程度上会受限于 Zerotier 的 Planet 节点发现路由的效果。如果两个客户端节点到 Planet 节点的路由来自于两条不同的线路，比如一个节点位于移动局域网网络，一个节点位于联通局域网网络，Planet 节点在规划路由的时候会认为两个客户端节点直接无法找到最短的路由，需要通过 Planet 节点来进行转发流量，甚至被认为完全没有可能互通。而实际上，在国内的运营商网络中，移动网络和联通网络之间是存在交换节点的，即可能存在一条最短路由。这种情况下，Zerotier 官方建议自己使用一台国内的公网服务器提供 Moon 服务，从而为 Zerotier 的路由规划提供辅助。从理论上来说，两个客户端节点在 Moon 的帮助下很大可能找到国内网络中的最短路由，并直接建立 UDP 通道。但在实际过程中，客户端节点之间的最短路由可能仍然十分长，且不足以直接建立 UDP 通道，毕竟它们位于两个底层的局域网中。</p>

<p>  那么这样就完全不能让两个客户端节点直接互联吗？实际上还是有方法的。</p>

<p>  <strong>第一种方法</strong>是，将公网服务器与远程服务环境的节点使用 Zerotier 组网互通，通过 SSH 自身提供的代理功能、将本来要发给远程服务环境的节点的 ssh 连接请求发往公网服务器进行转发。因为全程采用了 SSH 无密码登录（密钥登录），所以除非你的私钥被别人窃取否则理论上是绝对安全的，这也是国际上采用的通用安全做法。</p>

<p>  <strong>第二种方法</strong>是，将公网服务器分别与远程服务环境的节点、本地环境的节点使用 Zerotier 组网互通，并设置公网服务器允许转发来自 Zerotier 网卡的流量请求，然后在本地环境的节点上设置将所有发往远程服务环境的节点的网络请求经由公网服务器进行转发。因为这种方法是把公网服务器作为一个软件式的路由器，在网络上实现了本地环境与远程服务环境的完全互联，所以对于本地环境而言，远程服务环境中的任意节点的任意端口是完全可达的。这也存在某种安全上的隐患，一般来说只建议网络或服务管理用户使用这样的方式，对于普通用户来说第一种方法已经完全够用，且安全性较高。</p>

<p><img src="https://i.vgy.me/BCnz9e.png" alt="vgy.me" /></p>

<h2 id="实现">实现</h2>

<h3 id="公网服务器的选择">公网服务器的选择</h3>

<p>  无论是第一种方法还是第二种方法，都需要有一台公网服务器使用 Zerotier 与远程服务节点互通，因此第一步是需要拥有一台公网服务器。</p>

<h4 id="地理位置">地理位置</h4>

<p>  如果远程服务节点和本地客户端节点都在国内，那自然是国内的公网服务器最好。如果远程服务节点位于国内、本地客户端节点位于国外，也是使用国内的公网服务器最佳。因为无论哪种方式，公网服务器与远程服务节点直接都是使用 Zerotier 连接的。当然如果远程服务节点和本地客户端节点都在国外，自然使用国外的公网服务器最佳。</p>

<h4 id="服务商">服务商</h4>

<p>  根据笔者使用过的经验来看，按照推荐先后优先顺序，国内的 VPS 公网服务商推荐阿里云（国内国外路由较短）、腾讯云、Ucloud、华为云、百度云等等，国外的 VPS 公网服务商推荐 AWS（国内国外路由较短）、Azure、Linode、Digital Ocean、Vultr、GCP 等等。</p>

<h3 id="第一种方法">第一种方法</h3>

<h4 id="提前准备">提前准备</h4>

<ul>
  <li>本地客户端节点生成一对公钥和私钥</li>
  <li>公网服务器和远程服务节点都已安装 Zerotier</li>
</ul>

<p>  如何生成一对公钥和私钥以及安装 Zerotier此处不做赘述。</p>

<h4 id="规划网络">规划网络</h4>

<p>  假设现在规划的 Zerotier 网段为 172.18.0.0/24，远程服务节点所在局域网网络为 192.168.1.0/24，：</p>
<ul>
  <li>公网服务器实际 IP：1.1.1.1</li>
  <li>远程服务节点实际 IP：192.168.1.200</li>
  <li>公网服务器 Zerotier 规划 IP：172.18.0.10</li>
  <li>远程服务节点 Zerotier 规划 IP：172.18.0.200</li>
</ul>

<h4 id="配置-zerotier">配置 Zerotier</h4>

<p>  登录 <a href="https://my.zerotier.com">Zerotier Web 控制面板</a>，并将公网服务器和远程服务节点的 zerotier id 加入到同一个 Zerotier 网络中。在 Web 控制面板中设置上面对应的 IP。</p>

<p>  以下为在公网服务器或远程服务节点上的操作：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查询公网服务器或远程服务节点的 zerotier id</span>
<span class="nb">sudo </span>zerotier-cli info

<span class="c"># 加入到同一个 Zerotier 网络中</span>
<span class="nb">sudo </span>zerotier-cli <span class="nb">join</span> &lt;Zerotier Network Id&gt;

<span class="c"># 查询网络状态</span>
<span class="nb">sudo </span>zerotier-cli listnetworks
</code></pre></div></div>

<h4 id="验证组网结果">验证组网结果</h4>

<p>  如下所示可以分别在远程服务节点和公网服务器上验证是否可以互通。一般来说，从远程服务节点上 PING 公网服务器可能较容易 PING 通。如果两边都不通，可以使用直接 PING 公网服务器的公网 IP 来帮助 Zerotier 更快找到最短路由。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 在远程服务节点上 PING 公网服务器</span>
ping <span class="nt">-c</span> 10 172.18.0.10

<span class="c"># 在公网服务器上 PING 远程服务节点</span>
ping <span class="nt">-c</span> 10 172.18.0.200

<span class="c"># 在远程服务节点上 PING 公网服务器的公网 IP</span>
ping <span class="nt">-c</span> 1.1.1.1
</code></pre></div></div>

<h4 id="配置路由转发">配置路由转发</h4>

<p>  经过以上步骤就可以实现公网服务器与远程服务节点之间的互通，但是在远程服务环境中往往存在多个节点，如果每个节点都这么做那将非常冗余。因此，需要借助已经配置好 Zerotier 的远程服务节点来转发所有的请求到远程服务环境的其他节点。</p>

<h5 id="远程服务节点">远程服务节点</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 启动转发功能，编辑 /etc/sysctl.conf 文件</span>
<span class="nb">sudo </span>vim /etc/sysctl.conf

<span class="c"># 在 /etc/sysctl.conf 文件底部添加</span>
net.ipv4.ip_forward <span class="o">=</span> 1

<span class="c"># 使修改的配置立即生效</span>
<span class="nb">sudo </span>sysctl <span class="nt">-p</span>

<span class="c"># 查看当前配置</span>
<span class="nb">sudo </span>sysctl net.ipv4.ip_forward

<span class="c"># 如输出以下内容即为修改的配置已生效</span>
net.ipv4.ip_forward <span class="o">=</span> 1

<span class="c"># 查询网卡信息</span>
ip <span class="nb">link </span>show

<span class="c"># 假设正常上网网卡为 eth0，Zerotier 虚拟网卡为 zt0</span>
<span class="c"># 添加 iptables 规则允许 eth0 网卡转发所有 Zerotier 虚拟网卡 zt0 的流量</span>
<span class="nb">sudo </span>iptables <span class="nt">-t</span> nat <span class="nt">-A</span> POSTROUTING <span class="nt">-o</span> eth0 <span class="nt">-j</span> MASQUERADE
<span class="nb">sudo </span>iptables <span class="nt">-A</span> FORWARD <span class="nt">-m</span> conntrack <span class="nt">--ctstate</span> RELATED,ESTABLISHED <span class="nt">-j</span> ACCEPT
<span class="nb">sudo </span>iptables <span class="nt">-A</span> FORWARD <span class="nt">-i</span> zt0 <span class="nt">-o</span> eth0 <span class="nt">-j</span> ACCEPT

<span class="c"># 由于 iptables 规则会在 VPS 重启后丢失，所以需要使用 iptables-persistent 来保存规则</span>
<span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> iptables-persistent
<span class="c"># 执行以下命令后会自动保存 IPv4 和 IPv6 规则</span>
<span class="nb">sudo </span>netfilter-persistent save

<span class="c"># 查询已保存的规则</span>
<span class="nb">sudo </span>iptables-save
</code></pre></div></div>

<p>  执行以上命令后，远程服务节点就能接受来自其他 Zerotier 节点的流量转发请求了。</p>

<h5 id="公网服务器">公网服务器</h5>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查询公网服务器的网卡</span>
ip <span class="nb">link </span>show

<span class="c"># 假设正常上网网卡为 eth0，Zertiter 虚拟网卡为 zt0</span>
<span class="c"># 添加通往其他远程服务节点的请求交给已配置 Zerotier 的远程服务节点转发</span>
<span class="nb">sudo </span>route add <span class="nt">-net</span> 192.168.1.0/24 gw 172.18.0.200 dev zt0

<span class="c"># 验证其他远程服务节点是否可达</span>
<span class="c"># 假设某一个其他远程服务节点 IP 为 192.168.1.201</span>
ping <span class="nt">-c</span> 10 192.168.1.201
</code></pre></div></div>

<p>  经过以上命令即可配置公网服务器对远程服务环境中的任意节点通过已配置 Zerotier 的远程服务节点可达。</p>

<h4 id="配置-ssh-代理">配置 SSH 代理</h4>

<p>  SSH 是 Linux/Unix 世界中必不可少的一件神器，通常是用来从本地远程连接服务器。由于 SSH 协议本身是基于加密的，所以在连接后的数据流量是难以被攻击或破解的。当然，SSH 连接建立后，本地节点实际上还可以把远程服务节点的端口映射到本地。即使是在远程服务节点开启的是一个 Web 服务器，通过这样的方式也能在本地使用浏览器访问本地映射端口来实现对远程服务节点上的 Web 服务器的访问。而所需要的唯一一个权限就是可以 SSH 连接登录用户成功。这种方法的安全性极佳，既利用了 SSH 本身的安全性，又不暴露远程服务节点上的任何其他端口给别人。</p>

<p>  SSH 代理功能其实是 SSH 端口转发的一种，其原理是利用一台公网可达的 SSH 服务作为跳板进行二次 SSH 登录。事实上，这种代理登录方式理论上可以支持二次及以上。由阮一峰大佬撰写的 <a href="https://wangdoc.com/ssh/port-forwarding.htm">SSH 教程</a> 中，对这一内容和原理做了非常详细的介绍，还包括 SSH 密钥登录、证书登录、scp 命令、rsync 命令等。这些知识在这里有非常大的用处。</p>

<h5 id="公网服务器-1">公网服务器</h5>

<p>  为了保障公网服务器的安全性，SSH 代理所使用的用户应该是一个不提供 SHELL 的用户，也就是说某一个客户端使用代理用户和通过验证的私钥登录公网服务器后会被立即退出，而无法停留在公网服务器上。如果为 SSH 代理用户提供了 SHELL，那么任何一个使用该服务的用户都能在公网服务器上操作，这样极不安全，公网服务器甚至可能被破坏。如下可以配置一个有家目录但不允许登录的用户用于 SSH 代理。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 创建一个用户名为 nologin_user 的不允许登录但有家目录的用户</span>
<span class="nb">sudo </span>useradd <span class="nt">-d</span> /home/nologin_user <span class="nt">-m</span> <span class="nt">-s</span> /sbin/nologin nologin_user

<span class="c"># 添加客户端节点的公钥到 nologin_user 的认证文件中</span>
<span class="nb">sudo mkdir</span> /home/nologin_user/.ssh
<span class="nb">sudo cat </span>id_rsa.pub <span class="o">&gt;&gt;</span> /home/nologin_user/.ssh/authorized_keys
<span class="nb">sudo chown</span> <span class="nt">-R</span> nologin_user:nologin_user /home/nologin_user/.ssh

<span class="c"># （可选，建议）配置 nologin_user 登录时不返回登录信息</span>
<span class="c"># 在家目录创建一个名为 .hushlogin 的空文件</span>
<span class="nb">sudo touch</span> /home/nologin_user/.hushlogin
</code></pre></div></div>

<h5 id="其他远程服务节点">其他远程服务节点</h5>

<p>  为了使用户可以访问其他远程服务节点，在其他远程服务节点上也需要添加客户端节点的公钥到认证文件中，如下所示。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> /home/nologin_user/.ssh
<span class="nb">sudo cat </span>id_rsa.pub <span class="o">&gt;&gt;</span> /home/&lt;username&gt;/.ssh/authorized_keys
<span class="nb">sudo chown</span> <span class="nt">-R</span> &lt;username&gt;:&lt;username&gt; /home/nologin_user/.ssh
</code></pre></div></div>

<h5 id="本地客户端节点">本地客户端节点</h5>

<p>  本地客户端节点为了可以一步直接登录其他远程服务节点，可以像以下方式一样配置本地 ssh。Linux 或者 Unix 的目录是 ~/.ssh/config，Windows 的目录也是 用户主目录/.ssh/config。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ~/.ssh/config</span>

Host remote
    HostName 192.168.1.201
    User ubuntu
    Port 22
    ProxyJump ecs

Host ecs
    HostName 1.1.1.1
    User nologin_user
    Port 22
</code></pre></div></div>

<p>  做好以上配置之后，即可在终端使用 <code class="language-plaintext highlighter-rouge">ssh remote</code> 命令一键无密码连接到其他远程服务节点。</p>

<h3 id="第二种方法">第二种方法</h3>

<h4 id="提前准备-1">提前准备</h4>

<ul>
  <li>本地客户端节点、公网服务器、远程服务节点都已安装 Zerotier</li>
  <li>本地客户端节点 Zerotier 规划 IP 为 172.18.0.11</li>
</ul>

<p>  如何安装 Zerotier此处不做赘述。</p>

<h4 id="配置互通">配置互通</h4>

<p>  由于在这种方案中本地客户端节点、公网服务器、远程服务节点之间要实现网络完全互通，所以公网服务器和远程服务节点这里都要配置允许路由转发，本地客户端节点和公网服务器都要配置访问其他远程节点的路由转发。</p>

<h5 id="远程服务节点-1">远程服务节点</h5>

<p>  和第一种方法中 配置路由转发-远程服务节点 操作一致。</p>

<h5 id="公网服务器-2">公网服务器</h5>

<p>  和第一种方法中 配置路由转发-远程服务节点 操作基本一致，并且添加第一种方法中 配置路由转发-公网服务器 操作。这里不同的是 Zerotier 虚拟网卡需要转发流量，而不是将 Zerotier 虚拟网卡的流量请求转发给主要上网网卡，因此应做如下操作：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 允许 zt0 虚拟网卡转发流量请求</span>
<span class="nb">sudo </span>iptables <span class="nt">-t</span> nat <span class="nt">-A</span> POSTROUTING <span class="nt">-o</span> zt0 <span class="nt">-j</span> MASQUERADE
<span class="nb">sudo </span>iptables <span class="nt">-A</span> FORWARD <span class="nt">-m</span> conntrack <span class="nt">--ctstate</span> RELATED,ESTABLISHED <span class="nt">-j</span> ACCEPT
<span class="c"># 接受一切网卡转发流量请求</span>
<span class="nb">sudo </span>iptables <span class="nt">-P</span> FORWARD  ACCEPT
<span class="c"># 保存修改的 iptables 规则</span>
<span class="nb">sudo </span>netfilter-persistent save
<span class="c"># 查看保存的 iptables 规则</span>
<span class="nb">sudo </span>iptables-save
</code></pre></div></div>

<h5 id="本地客户端节点-1">本地客户端节点</h5>

<p>  和第一种方法中 配置路由转发-公网服务器 操作基本一致。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查询本地客户端的网卡（Linux）</span>
ip <span class="nb">link </span>show
<span class="c"># 查询本地客户端的网卡（Mac）</span>
ifconfig

<span class="c"># 假设正常上网网卡为 eth0，Zertiter 虚拟网卡为 zt0</span>
<span class="c"># 添加通往其他远程服务节点的请求交给已配置 Zerotier 的远程服务节点转发</span>
<span class="nb">sudo </span>route add <span class="nt">-net</span> 192.168.1.0/24 gw 172.18.0.10 dev zt0

<span class="c"># 验证其他远程服务节点是否可达</span>
<span class="c"># 假设某一个其他远程服务节点 IP 为 192.168.1.201</span>
ping <span class="nt">-c</span> 10 192.168.1.201
</code></pre></div></div>

<p>  网络互通之后可以直接使用 192.168.1.201 访问到其他远程服务节点，所以对应的 ssh 配置文件修改为以下内容。然后使用 <code class="language-plaintext highlighter-rouge">ssh remote</code> 命令直接访问其他远程服务节点。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ~/.ssh/config</span>

Host remote
    HostName 192.168.1.201
    User ubuntu
    Port 22
</code></pre></div></div>

<h2 id="总结与讨论">总结与讨论</h2>

<p>  软件定义网络在进行异地组网中发挥了很大的作用，并且有一定的安全性保障。但其中也有一些不足之处，比如说两种方法都需要通过公网服务器到远程服务节点，如果要在远程服务节点和本地客户端节点之间上传下载较大的文章，网速仍然会受到公网服务器带宽的限制。如果有一台上下行比较对称、带宽充足的公网服务器，那么就很容易弥补这一不足。</p>

<p>  另外，在使用公网服务器来作为中介去访问远程服务节点时，还是需要注意其安全性如何，毕竟公网服务器是可以被所有人访问到的，也是可以被所有人攻击到的。</p>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="多地" /><category term="组网" /><category term="互联" /><category term="Zerotier" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">AiiDA 与 Quantum Espresso</title><link href="https://lisz.me/tech/aiida/aiida-qe.html" rel="alternate" type="text/html" title="AiiDA 与 Quantum Espresso" /><published>2021-05-27T15:50:00+09:00</published><updated>2021-05-27T15:50:00+09:00</updated><id>https://lisz.me/tech/aiida/aiida-qe</id><content type="html" xml:base="https://lisz.me/tech/aiida/aiida-qe.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  <a href="https://www.quantum-espresso.org/">Quantum Espresson</a> （以下简称 QE）是一款基于平面波函数的开源第一性原理计算框架，其免费、易安装使用等优点受到了广大第一性原理计算研究人员的喜爱。QE 不仅支持 CPU 的并行高性能计算，还支持 GPU 计算。这看起来有点像是计算机专业里的深度学习框架，有完整的计算加速支持。另外，QE 与 VASP 的使用习惯类似度比较高，不管是输入文件还是赝势文件，都可以类比着使用。对于计算后的输出结果，QE 也有一套完整的工具链辅助用户完成一些常用的分析操作，比如寻找 k 路径、分析能带结构（Band Gap）等等。</p>

<p>  上次我们提到的 AiiDA 这款专门应用于材料计算领域的开源数据管理软件，与 QE 可以非常方便地结合在一起使用，而且 AiiDA 官网上给出的示例就是基于 QE 计算的。现在我们就来体验一下如何把 QE 和 AiiDA 结合起来使用吧。</p>

<h2 id="实践">实践</h2>

<p>  上次介绍的安装部署 AiiDA 的文章中的 <a href="https://quantum-mobile.readthedocs.io/en/latest/index.html">Quantum Mobile</a>，就开发了 AiiDA 与 QE 的一体化虚拟机和 Docker 镜像，直接使用非常方便。这里为了在服务器上部署比较方便，采用了 Docker 部署的方式。为了缩短篇幅，使用 Docker 启动一个 Quantum Mobile 实例的操作就不在此赘述了，请参照 <a href="./aiida-install.html">AiiDA 开源数据管理软件</a> 中的 <strong>Docker 安装</strong> 部分。</p>

<h3 id="进入环境">进入环境</h3>

<p>  如果创建的容器实例名为 quantum-mobile，那么使用 <code class="language-plaintext highlighter-rouge">docker exec -ti -u max quantum-mobile /bin/bash</code> 命令进入容器。由于容器默认是不开启 Anaconda 的虚拟环境的，所以需要使用 <code class="language-plaintext highlighter-rouge">workon aiida</code> 命令开启 AiiDA 专用虚拟环境。</p>

<h3 id="初始化配置">初始化配置</h3>

<p>  quantum-mobile 容器中默认是没有任何配置和数据的，只有已经正常运行的 aiida-core、PostgreSQL 和 RabbitMQ。这里我们可以使用快速配置来完成初始化。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 快速初始化</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi quicksetup
Info: enter <span class="s2">"?"</span> <span class="k">for </span><span class="nb">help
</span>Info: enter <span class="s2">"!"</span> to ignore the default and <span class="nb">set </span>no value
Profile name <span class="o">[</span>quicksetup]: qe
Email Address <span class="o">(</span><span class="k">for </span>sharing data<span class="o">)</span> <span class="o">[</span>aiida@localhost]:
First name <span class="o">[</span>Max]:
Last name <span class="o">[</span>Scientist]:
Institution <span class="o">[</span>Quantum Mobile]:
Trying to become <span class="s1">'postgres'</span> user. You may be asked <span class="k">for </span>your <span class="s1">'sudo'</span> password.
Trying to become <span class="s1">'postgres'</span> user. You may be asked <span class="k">for </span>your <span class="s1">'sudo'</span> password.
Trying to become <span class="s1">'postgres'</span> user. You may be asked <span class="k">for </span>your <span class="s1">'sudo'</span> password.
Trying to become <span class="s1">'postgres'</span> user. You may be asked <span class="k">for </span>your <span class="s1">'sudo'</span> password.
Trying to become <span class="s1">'postgres'</span> user. You may be asked <span class="k">for </span>your <span class="s1">'sudo'</span> password.
Trying to become <span class="s1">'postgres'</span> user. You may be asked <span class="k">for </span>your <span class="s1">'sudo'</span> password.
Success: created new profile <span class="sb">`</span>qe<span class="sb">`</span><span class="nb">.</span>
Info: migrating the database.
Operations to perform:
  Apply all migrations: auth, contenttypes, db
Running migrations:
  Applying contenttypes.0001_initial... OK
  ......
  Applying db.0045_dbgroup_extras... OK
Success: database migration completed.

<span class="c"># 将新建的 qe 配置设置为默认配置</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi profile setdefault qe
Success: qe <span class="nb">set </span>as default profile

</code></pre></div></div>

<h3 id="导入数据">导入数据</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载测试 aiida 数据</span>
wget http://phonondb.mtl.kyoto-u.ac.jp/aiida_tutorial_2020_07_perovskites_v0.9.aiida

<span class="c"># 导入 aiida 数据到数据库</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi import aiida_tutorial_2020_07_perovskites_v0.9.aiida
Info: starting import: aiida_tutorial_2020_07_perovskites_v0.9.aiida
Info: incompatible version detected <span class="k">for </span>aiida_tutorial_2020_07_perovskites_v0.9.aiida, trying migration
Reading archive version
Migration pathway: 0.9 -&gt; 0.10
Extracting archive to work directory
Info: proceeding with import of migrated archive

IMPORT
<span class="nt">--------</span>  <span class="nt">---------</span>
Archive   extracted

Parameters
<span class="nt">--------------------------</span>  <span class="nt">------</span>
Comment rules               newest
New Node Extras rules       import
Existing Node Extras rules  kcl
Links - <span class="nv">label</span><span class="o">=</span>pseudos__O                  39.4%|██████████████████████████████████▋                                                     | 941/2388
Summary
<span class="nt">-----------------------</span>  <span class="nt">---------------</span>
Auto-import Group label  20210527-074131
User<span class="o">(</span>s<span class="o">)</span>                  1 new
Computer<span class="o">(</span>s<span class="o">)</span>              1 new
Node<span class="o">(</span>s<span class="o">)</span>                  1981 new
Group<span class="o">(</span>s<span class="o">)</span>                 6 new
Link<span class="o">(</span>s<span class="o">)</span>                  2388 new

Success: imported archive aiida_tutorial_2020_07_perovskites_v0.9.aiida

<span class="c"># 下载赝势数据</span>
wget http://phonondb.mtl.kyoto-u.ac.jp/SSSP_1.1_PBE_efficiency.tar.gz
<span class="nb">mkdir </span>sssp_pseudos
<span class="nb">tar</span> <span class="nt">-C</span> sssp_pseudos <span class="nt">-zxvf</span> SSSP_1.1_PBE_efficiency.tar.gz

<span class="c"># 导入赝势数据</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi data upf uploadfamily sssp_pseudos <span class="s1">'SSSP'</span> <span class="s1">'SSSP pseudopotential library'</span>
Success: UPF files found: 85. New files uploaded: 74
</code></pre></div></div>

<h3 id="配置主机和-qe">配置主机和 QE</h3>

<p>  使用以下配置文件 computer.yml 和命令 <code class="language-plaintext highlighter-rouge">verdi computer setup --config computer.yml</code> 一键配置本地主机，并使用命令 <code class="language-plaintext highlighter-rouge">verdi computer configure local localhost</code> 配置  localhost 主机为 local 模式连接（相关配置均使用默认即可）。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># computer.yml</span>
<span class="nn">---</span>
<span class="na">description</span><span class="pi">:</span> <span class="s2">"</span><span class="s">localhost"</span>
<span class="na">label</span><span class="pi">:</span> <span class="s2">"</span><span class="s">localhost"</span>
<span class="na">hostname</span><span class="pi">:</span> <span class="s2">"</span><span class="s">localhost"</span>
<span class="na">transport</span><span class="pi">:</span> <span class="s">local</span>
<span class="na">scheduler</span><span class="pi">:</span> <span class="s2">"</span><span class="s">direct"</span>
<span class="na">work_dir</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/home/max/.aiida_run"</span>
<span class="na">mpirun_command</span><span class="pi">:</span> <span class="s2">"</span><span class="s">mpirun</span><span class="nv"> </span><span class="s">-np</span><span class="nv"> </span><span class="s">{tot_num_mpiprocs}"</span>
<span class="na">mpiprocs_per_machine</span><span class="pi">:</span> <span class="s2">"</span><span class="s">2"</span>
<span class="na">shebang</span><span class="pi">:</span> <span class="s2">"</span><span class="s">#!/bin/bash"</span>
<span class="na">prepend_text</span><span class="pi">:</span> <span class="s2">"</span><span class="nv"> </span><span class="s">"</span>
<span class="na">append_text</span><span class="pi">:</span> <span class="s2">"</span><span class="nv"> </span><span class="s">"</span>
</code></pre></div></div>

<p>  使用以下配置文件 code.yml 和命令 <code class="language-plaintext highlighter-rouge">verdi code setup --config code.yml</code> 一键配置本地 QE 程序。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># code.yml</span>
<span class="nn">---</span>
<span class="na">label</span><span class="pi">:</span> <span class="s2">"</span><span class="s">qe-6.5-pw"</span>
<span class="na">description</span><span class="pi">:</span> <span class="s2">"</span><span class="s">quantum_espresso</span><span class="nv"> </span><span class="s">v6.5"</span>
<span class="na">input_plugin</span><span class="pi">:</span> <span class="s2">"</span><span class="s">quantumespresso.pw"</span>
<span class="na">on_computer</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">remote_abs_path</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/usr/local/bin/pw.x"</span>
<span class="na">computer</span><span class="pi">:</span> <span class="s2">"</span><span class="s">localhost"</span>
<span class="na">prepend_text</span><span class="pi">:</span> <span class="s2">"</span><span class="s">ulimit</span><span class="nv"> </span><span class="s">-s</span><span class="nv"> </span><span class="s">unlimited"</span>
<span class="na">append_text</span><span class="pi">:</span> <span class="s2">"</span><span class="nv"> </span><span class="s">"</span>
</code></pre></div></div>

<h3 id="提交计算">提交计算</h3>

<h4 id="确认-aiida-后台状态">确认 aiida 后台状态</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看 aiida 后台状态</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi daemon status
Profile: qe
The daemon is not running

<span class="c"># 若如上未运行 aiida 后台程序，则使用以下命令启动</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi daemon start
Starting the daemon... RUNNING

<span class="c"># 再次查看 aiida 后台状态，已正常运行</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi daemon status
Profile: qe
Daemon is running as PID 102244 since 2021-05-29 12:38:55
Active workers <span class="o">[</span>1]:
   PID    MEM %    CPU %  started
<span class="nt">------</span>  <span class="nt">-------</span>  <span class="nt">-------</span>  <span class="nt">-------------------</span>
102248    0.005        0  2021-05-29 12:38:55
Use verdi daemon <span class="o">[</span>incr | decr] <span class="o">[</span>num] to increase / decrease the amount of workers
</code></pre></div></div>

<h4 id="确认代码配置">确认代码配置</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 如下所示，列举出 qe-6.5，与已配置信息一致</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi code list
<span class="c"># List of configured codes:</span>
<span class="c"># (use 'verdi code show CODEID' to see the details)</span>
<span class="k">*</span> pk 2056 - qe-6.5-pw@localhost
</code></pre></div></div>

<h4 id="准备执行脚本">准备执行脚本</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># cal.py
</span>
<span class="kn">from</span> <span class="nn">aiida</span> <span class="kn">import</span> <span class="n">load_profile</span>

<span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="kn">import</span> <span class="n">Code</span>
<span class="kn">from</span> <span class="nn">aiida.plugins</span> <span class="kn">import</span> <span class="n">DataFactory</span>
<span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="kn">import</span> <span class="n">submit</span>
<span class="kn">from</span> <span class="nn">aiida.orm.nodes.data.upf</span> <span class="kn">import</span> <span class="n">get_pseudos_from_structure</span>

<span class="n">load_profile</span><span class="p">()</span>

<span class="n">StructureData</span> <span class="o">=</span> <span class="n">DataFactory</span><span class="p">(</span><span class="s">'structure'</span><span class="p">)</span>
<span class="n">Dict</span> <span class="o">=</span> <span class="n">DataFactory</span><span class="p">(</span><span class="s">'dict'</span><span class="p">)</span>
<span class="n">KpointsData</span> <span class="o">=</span> <span class="n">DataFactory</span><span class="p">(</span><span class="s">'array.kpoints'</span><span class="p">)</span>

<span class="c1">###########################################
# Set constant values here
</span><span class="n">codename</span> <span class="o">=</span> <span class="s">'qe-6.5-pw@localhost'</span>
<span class="n">pseudo_family</span> <span class="o">=</span> <span class="s">'SSSP'</span>
<span class="c1">###########################################
</span>

<span class="n">code</span> <span class="o">=</span> <span class="n">Code</span><span class="p">.</span><span class="n">get_from_string</span><span class="p">(</span><span class="n">codename</span><span class="p">)</span>
<span class="n">builder</span> <span class="o">=</span> <span class="n">code</span><span class="p">.</span><span class="n">get_builder</span><span class="p">()</span>

<span class="c1"># Metadata settings
</span><span class="n">builder</span><span class="p">.</span><span class="n">metadata</span><span class="p">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">"PW test"</span>
<span class="n">builder</span><span class="p">.</span><span class="n">metadata</span><span class="p">.</span><span class="n">description</span> <span class="o">=</span> <span class="s">"My first AiiDA calc with Quantum ESPRESSO on Si"</span>
<span class="n">builder</span><span class="p">.</span><span class="n">metadata</span><span class="p">.</span><span class="n">options</span><span class="p">.</span><span class="n">resources</span> <span class="o">=</span> <span class="p">{</span><span class="s">'num_machines'</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="n">builder</span><span class="p">.</span><span class="n">metadata</span><span class="p">.</span><span class="n">options</span><span class="p">.</span><span class="n">max_wallclock_seconds</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">60</span>

<span class="c1"># Si structure
</span><span class="n">alat</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># angstorm
</span><span class="n">unit_cell</span> <span class="o">=</span> <span class="p">[[</span><span class="n">alat</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">alat</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="n">alat</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">alat</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="n">alat</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">alat</span><span class="o">/</span><span class="mi">2</span><span class="p">]]</span>
<span class="n">structure</span> <span class="o">=</span> <span class="n">StructureData</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="n">unit_cell</span><span class="p">)</span>
<span class="n">structure</span><span class="p">.</span><span class="n">append_atom</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="n">alat</span><span class="o">/</span><span class="mf">4.</span><span class="p">,</span> <span class="n">alat</span><span class="o">/</span><span class="mf">4.</span><span class="p">,</span> <span class="n">alat</span><span class="o">/</span><span class="mf">4.</span><span class="p">),</span> <span class="n">symbols</span><span class="o">=</span><span class="s">"Si"</span><span class="p">)</span>
<span class="n">structure</span><span class="p">.</span><span class="n">append_atom</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="n">symbols</span><span class="o">=</span><span class="s">"Si"</span><span class="p">)</span>
<span class="n">structure</span><span class="p">.</span><span class="n">store</span><span class="p">()</span>

<span class="c1"># kpoints-mesh
</span><span class="n">kpoints</span> <span class="o">=</span> <span class="n">KpointsData</span><span class="p">()</span>
<span class="n">kpoints</span><span class="p">.</span><span class="n">set_kpoints_mesh</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">kpoints</span><span class="p">.</span><span class="n">store</span><span class="p">()</span>



<span class="c1"># Input file
</span><span class="n">parameters_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'CONTROL'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'calculation'</span><span class="p">:</span> <span class="s">'scf'</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s">'SYSTEM'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'ecutwfc'</span><span class="p">:</span> <span class="mf">30.</span><span class="p">,</span>
        <span class="s">'ecutrho'</span><span class="p">:</span> <span class="mf">200.</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s">'ELECTRONS'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'conv_thr'</span><span class="p">:</span> <span class="mf">1.e-6</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">(</span><span class="nb">dict</span><span class="o">=</span><span class="n">parameters_dict</span><span class="p">)</span>
<span class="n">parameters</span><span class="p">.</span><span class="n">store</span><span class="p">()</span>

<span class="c1"># Builder settings
</span><span class="n">builder</span><span class="p">.</span><span class="n">structure</span> <span class="o">=</span> <span class="n">structure</span>
<span class="n">builder</span><span class="p">.</span><span class="n">kpoints</span> <span class="o">=</span> <span class="n">kpoints</span>
<span class="n">builder</span><span class="p">.</span><span class="n">pseudos</span> <span class="o">=</span> <span class="n">get_pseudos_from_structure</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="s">'SSSP'</span><span class="p">)</span>
<span class="n">builder</span><span class="p">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>
<span class="n">builder</span><span class="p">.</span><span class="n">metadata</span><span class="p">.</span><span class="n">dry_run</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">builder</span><span class="p">.</span><span class="n">metadata</span><span class="p">.</span><span class="n">store_provenance</span> <span class="o">=</span> <span class="bp">True</span>

<span class="c1"># Submit the job
</span><span class="n">calculation</span> <span class="o">=</span> <span class="n">submit</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>
<span class="n">calculation</span><span class="p">.</span><span class="n">set_extra</span><span class="p">(</span><span class="s">"element"</span><span class="p">,</span> <span class="s">"Si"</span><span class="p">)</span>

<span class="c1"># Print the job pk value
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'created calculation with Pk=</span><span class="si">{</span><span class="n">calculation</span><span class="p">.</span><span class="n">pk</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="验证计算及结果">验证计算及结果</h3>

<h4 id="验证计算状态">验证计算状态</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查询任务执行状态，如下为 正在排队等待执行</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi process list
  PK  Created    Process label    Process State    Process status
<span class="nt">----</span>  <span class="nt">---------</span>  <span class="nt">---------------</span>  <span class="nt">---------------</span>  <span class="nt">---------------------------------------</span>
2087  9s ago     PwCalculation    ⏵ Waiting        Monitoring scheduler: job state RUNNING

<span class="c"># 当执行完后上一条命令是无法查询到任务状态的，需加 -a 选项查看所有任务</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi process list <span class="nt">-a</span>
  PK  Created    Process label    Process State     Process status
<span class="nt">----</span>  <span class="nt">---------</span>  <span class="nt">---------------</span>  <span class="nt">----------------</span>  <span class="nt">----------------</span>
 648  2405D ago  PwCalculation    ⏹ Finished <span class="o">[</span>0]
 ......
 ......
2087  27s ago    PwCalculation    ⏹ Finished <span class="o">[</span>0]

Total results: 175

Info: last <span class="nb">time </span>an entry changed state: 16s ago <span class="o">(</span>at 13:45:38 on 2021-05-29<span class="o">)</span>
</code></pre></div></div>

<h4 id="验证结果">验证结果</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查询计算大致信息，如下可知一切正常并已格式化提取所需的输出信息</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi node show 2087
Property     Value
<span class="nt">-----------</span>  <span class="nt">-----------------------------------------------</span>
<span class="nb">type         </span>PwCalculation
state        Finished <span class="o">[</span>0]
pk           2087
uuid         f1762049-4627-4f87-acac-ad6074b87352
label        PW <span class="nb">test
</span>description  My first AiiDA calc with Quantum ESPRESSO on Si
ctime        2021-05-29 13:45:27.167975+00:00
mtime        2021-05-29 13:45:38.615649+00:00
computer     <span class="o">[</span>2] localhost

Inputs      PK    Type
<span class="nt">----------</span>  <span class="nt">----</span>  <span class="nt">-------------</span>
pseudos
    Si      2043  UpfData
code        2056  Code
kpoints     2085  KpointsData
parameters  2086  Dict
structure   2084  StructureData

Outputs              PK  Type
<span class="nt">-----------------</span>  <span class="nt">----</span>  <span class="nt">--------------</span>
output_band        2090  BandsData
output_parameters  2092  Dict
output_trajectory  2091  TrajectoryData
remote_folder      2088  RemoteData
retrieved          2089  FolderData

<span class="c"># 查看计算输入文件</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi calcjob inputcat 2087 | less

<span class="c"># 查看计算输出文件</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi calcjob outputcat 2087 | less

<span class="c"># 查看格式化提取的计算结果</span>
<span class="o">(</span>aiida<span class="o">)</span> max@37440764beb9:~<span class="nv">$ </span>verdi calcjob res 2087
<span class="o">{</span>
    <span class="s2">"beta_real_space"</span>: <span class="nb">false</span>,
    <span class="s2">"charge_density"</span>: <span class="s2">"./charge-density.dat"</span>,
    <span class="s2">"constraint_mag"</span>: 0,
    <span class="s2">"convergence_info"</span>: <span class="o">{</span>
        <span class="s2">"scf_conv"</span>: <span class="o">{</span>
            <span class="s2">"convergence_achieved"</span>: <span class="nb">true</span>,
            <span class="s2">"n_scf_steps"</span>: 5,
            <span class="s2">"scf_error"</span>: 2.4316966484325e-08
        <span class="o">}</span>
    <span class="o">}</span>,
    <span class="s2">"creator_name"</span>: <span class="s2">"pwscf"</span>,
    <span class="s2">"creator_version"</span>: <span class="s2">"6.5"</span>,
    <span class="s2">"dft_exchange_correlation"</span>: <span class="s2">"PBE"</span>,
    <span class="s2">"do_magnetization"</span>: <span class="nb">true</span>,
    <span class="s2">"do_not_use_time_reversal"</span>: <span class="nb">false</span>,
    <span class="s2">"energy"</span>: <span class="nt">-285</span>.72326235425,
    <span class="s2">"energy_accuracy"</span>: 6.80284586265e-07,
    <span class="s2">"energy_accuracy_units"</span>: <span class="s2">"eV"</span>,
    ......
    ......   
<span class="o">}</span>
</code></pre></div></div>

<h2 id="总结">总结</h2>

<p>  如上所示，经过了一系列的操作 AiiDA 可以非常容易搭配 QE 完成第一性原理计算，并且对计算过程中的输入、输出数据都实现了有效的管理。不过在实践过程中发现， AiiDA 对于我们设定的 QE 输入参数并不会进行校验，甚至在 AiiDA 对这些输入参数进行格式化生成 QE 输入文件之后，QE 会视之为非法字符串。虽然参考了 <a href="https://aiida-tutorials.readthedocs.io/en/latest/pages/2020_Intro_Week/sections/running.html#creating-and-launching-calculations">aiida-toturial</a> 的输入参数配置，但是其中的 mickeymouse 字段使得 QE 计算无法正常运行。</p>

<p>  另外，如果我们设置了比较严苛的输入参数值，QE 计算可能会受限无法完成完整的计算，并且无法格式化抽取到预设的重要数据信息。因此只能在设置输入参数时，除必要精度需要外尽量放宽其他计算的限制。我们除了可以通过 AiiDA 提供的 verdi 命令来交互式查询计算结果之外，也可以进入到计算的目录直接查询 QE 计算的原始输入文件和输出文件（默认本地目录是 ~/.aiida_run）。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://aiida-tutorials.readthedocs.io/en/latest/pages/2020_Intro_Week/index.html">2020 AiiDA tutorial week “Virtual Edition”</a></li>
  <li><a href="https://aiida-quantumespresso.readthedocs.io/en/latest/user_guide/get_started/index.html">aiida-quantumespresoo documentation</a></li>
  <li><a href="https://aiida-quantumespresso.readthedocs.io/en/latest/_downloads/2dc19f2e8a6300052734f58bd000d074/pw_short_example.py">example script provided by aiida-quantumespresso</a></li>
  <li><a href="https://github.com/atztogo/aiida-tutorials/wiki">AiiDA virtual hands-on tutorial in 2021 Spring</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="aiida" /><category term="AiiDA" /><category term="Quantum Espresso" /><category term="联机" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">AiiDA 开源数据管理软件</title><link href="https://lisz.me/tech/aiida/aiida-install.html" rel="alternate" type="text/html" title="AiiDA 开源数据管理软件" /><published>2021-05-12T16:30:00+09:00</published><updated>2021-05-12T16:30:00+09:00</updated><id>https://lisz.me/tech/aiida/aiida-install</id><content type="html" xml:base="https://lisz.me/tech/aiida/aiida-install.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  对于机器学习来说，模型和数据是非常重要的。而模型与数据相比，模型即便是优化得再好，数据不够、不好的话，最终也不能得到一个好的预测结果。因此，我们在使用机器学习方法去建立某个领域模型的同时，也要注意相关原始数据的收集和整理。当我们需要通过庞大的计算量来获取数据的时候，通常可能需要使用大型服务器集群，甚至高性能集群、超算等等。这个时候，即使我们提交的计算在一段时间后得到了结果，恐怕也会是很多个结果文件，我们也很难从这些文件中抽取出我们关心的、想要的某些数据，更难将其整理成可直接用于机器学习的数据格式。</p>

<p>  面对着这些问题，通常我们会想到可以建立一个数据库，再写一些脚本去自动解析文件内容、抽取关键字段和数值，甚至说为了编程可达需要给数据库设计一套 RESTful API 或者 GraphQL API。这样听起来工程量略大，但是一旦做好那么就可以建立类似于 Materias Project 等等那样的专业领域数据库。其实，我们并没有必要从零开始去做这些，因为现在已经有了开源数据管理软件 <a href="https://aiida.readthedocs.io">AiiDA</a>。</p>

<p>  AiiDA 是一个使用 Python 编写的开源复杂工作流设计和管理框架，旨在帮助从事计算科学（计算材料学，计算生物学等）的相关研究者可以更好地管理、编写、使用和分享复杂的工作流以及计算产生的有用数据。它使得在研究中复杂的计算流程的可重复性得以保证。AiiDA 实现并支持了 ADES 模式的四大基石： (A)utomation（自动）, (D)ata（数据）, (E)nvironment（社区环境）, 和 (S)haring （分享）. AiiDA 支持的一些典型特性包括：</p>

<ul>
  <li><strong>工作流</strong>： AiiDA 可以用来创建并执行复杂的、自动文档化的工作流来连接本地和远端计算资源上的多个计算代码。</li>
  <li><strong>高通量</strong>： AiiDA 的基于事件的工作流引擎支持成百上千（每小时）的带有检查点的计算例程。</li>
  <li><strong>数据可验证性</strong>： AiiDA 自动追踪所有可验证性图中 (provenance graph) 的输入、输出和元数据，以保证计算的完全可重复性。</li>
  <li><strong>高级的查询检索特性</strong>： AiiDA 的查询语言支持千万个节点的快速图查询。</li>
  <li><strong>插件接口</strong>：: AiiDA 可以通过插件来支持各种计算代码，和各种数据分析工具，各种数据类型，任务调度工具以及远程连接方式等 (参见<a href="https://aiidateam.github.io/aiida-registry/">公共插件库</a>)。</li>
  <li><strong>高性能集群接口</strong>： AiiDA 支持无缝地把你的计算从一个集群转换到另一个集群运行。AiiDA 兼容各种任务调度软件 <a href="https://slurm.schedmd.com/">SLURM</a>, <a href="https://www.pbspro.org/">PBS Pro</a>, <a href="http://www.adaptivecomputing.com/products/torque/">torque</a>, <a href="http://gridscheduler.sourceforge.net/">SGE</a> 或者 <a href="https://www.ibm.com/support/knowledgecenter/SSETD4/product_welcome_platform_lsf.html">LSF</a> ，对这些任务调度工具 AiiDA 都是源生支持的。</li>
  <li><strong>开放科学</strong>： AiiDA 可以将全部或部分的数据库导出，以便于和同行分享，或上传至 <a href="https://www.materialscloud.org/">Materials Cloud</a> 以便 归档 和 检索 。</li>
  <li><strong>开源</strong>： AiiDA 通过 <a href="https://aiida.readthedocs.io/projects/aiida-core/zh_CN/latest/intro/LICENSE.txt">MIT 开源协议</a> 发布。</li>
</ul>

<h2 id="安装">安装</h2>

<p>  AiiDA 官网向用户提供了很多种安装方式，其中最简单的就是使用 Docker 一键式安装。这里不仅介绍由 AiiDA 团队构建的 <a href="https://hub.docker.com/r/aiida-team/aiida-core">aiida-team/aiida-core</a> 镜像，也介绍具有多种集成环境的 <a href="https://hub.docker.com/r/marvelnccr/quantum-mobile">Quantum Mobile</a> 镜像。除了 Docker 方式外，AiiDA 也可以直接在 Linux/Mac 系统上安装。考虑到 AiiDA 部署在 Linux 服务器操作系统上更为合适，这里就分别介绍使用 root 用户和非 root 用户如何安装 AiiDA 整体环境。</p>

<h3 id="docker-安装">Docker 安装</h3>

<h4 id="单独环境">单独环境</h4>

<p>  使用以下 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 文件和命令 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 即可启动一个 aiida-team/aiida-core 容器实例。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># docker-compose.yml</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.9'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">aiida</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">aiidateam/aiida-core:1.3.0</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">aiida</span>
    <span class="na">stdin_open</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">tty</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">volumes</span><span class="pi">:</span> 
      <span class="pi">-</span> <span class="s">./data:/home/aiida/data</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
    <span class="na">networks</span><span class="pi">:</span>
       <span class="na">extnetwork</span><span class="pi">:</span>
          <span class="na">ipv4_address</span><span class="pi">:</span> <span class="s">192.168.18.2</span>

<span class="na">networks</span><span class="pi">:</span>
   <span class="na">extnetwork</span><span class="pi">:</span>
      <span class="na">ipam</span><span class="pi">:</span>
         <span class="na">config</span><span class="pi">:</span>
         <span class="pi">-</span> <span class="na">subnet</span><span class="pi">:</span> <span class="s">192.168.18.0/24</span>
           <span class="na">gateway</span><span class="pi">:</span> <span class="s">192.168.18.1</span>

</code></pre></div></div>

<h4 id="多软件环境">多软件环境</h4>

<p>  使用以下 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 文件和命令 <code class="language-plaintext highlighter-rouge">docker-compose up -d</code> 即可启动一个 quantum-mobile 容器实例。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># docker-compose.yml</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.4'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">quantum-mobile</span><span class="pi">:</span>
    <span class="c1"># using the required tag</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s2">"</span><span class="s">marvelnccr/quantum-mobile:20.11.2a"</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">quantum-mobile</span>
    <span class="na">expose</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8888"</span> <span class="c1"># AiiDa Lab</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8890"</span> <span class="c1"># Jupyter Lab</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5000"</span> <span class="c1"># REST API</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">22"</span>   <span class="c1"># SSH</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="c1"># local:container</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8888:8888"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8890:8890"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">22:22"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5000:5000"</span>
    <span class="c1"># privileged mode and mounting the cgroup are required for correctly running sytsemd inside the container (set as the default command)</span>
    <span class="na">privileged</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">/sys/fs/cgroup:/sys/fs/cgroup:ro"</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">LC_ALL</span><span class="pi">:</span> <span class="s2">"</span><span class="s">en_US.UTF-8"</span>
      <span class="na">LANG</span><span class="pi">:</span> <span class="s2">"</span><span class="s">en_US.UTF-8"</span>
    <span class="na">healthcheck</span><span class="pi">:</span>
      <span class="c1"># check that the daemon has been started for the 'generic' profile</span>
      <span class="c1"># can take a few minutes to start</span>
      <span class="na">test</span><span class="pi">:</span> <span class="s">systemctl is-active --quiet aiida-daemon@generic.service</span>
      <span class="na">interval</span><span class="pi">:</span> <span class="s">30s</span>
      <span class="na">retries</span><span class="pi">:</span> <span class="m">6</span>
      <span class="na">start_period</span><span class="pi">:</span> <span class="s">30s</span>
</code></pre></div></div>

<h3 id="root-用户安装">root 用户安装</h3>

<p>  由于 root 用户对系统具有绝对的管理权限，所以使用 root 用户安装 AiiDA 环境时比较简单，可以直接通过 APT 源安装 PostgreSQL、RabbitMQ 和 AiiDA。如下所示，完成这三种软件的安装。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># AiiDA 是一个 python 编写的软件，所有需要 python 环境和 pip 包管理工具</span>
<span class="nb">sudo </span>apt-get <span class="nb">install </span>git python3-dev python3-pip

<span class="c"># 安装 PostgreSQL 服务器与客户端命令</span>
<span class="nb">sudo </span>apt-get <span class="nb">install </span>postgresql postgresql-server-dev-all postgresql-client

<span class="c"># 安装 RabbitMQ 服务器并查询当前状态</span>
<span class="nb">sudo </span>apt-get <span class="nb">install </span>rabbitmq-server
<span class="nb">sudo </span>rabbitmqctl status

<span class="c"># 安装 AiiDA</span>
pip <span class="nb">install </span>aiida-core
</code></pre></div></div>

<p>  具体配置 PostgreSQL 数据库和 AiiDA 与下一节中非 root 用户安装中相同，请参照下面内容。</p>

<h3 id="非-root-用户安装">非 root 用户安装</h3>

<p>  当我们在使用内网服务器时，很大可能我们只是一个普通用户，并没有管理员权限。所以如果想要以一个非 root 用户的身份来安装部署 AiiDA 服务是否也有可能呢？事实上是可以实现的，因为组成 AiiDA 运行环境的三个软件都可以以非 root 用户安装、启动。为了简化安装软件过程，这里我们采用了 <a href="https://www.anaconda.com">Anaconda</a> 来帮助我们更快、更简单地安装部署环境。（后续，笔者将会为服务器上的 Anaconda 使用特别写一篇文章进行详细介绍，这里默认已安装有 Anaconda。）</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 启动 Anaconda 环境</span>
~/anaconda3/etc/profile.d/conda.sh
</code></pre></div></div>

<h4 id="安装-postgresql">安装 PostgreSQL</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 从 conda-forge 频道安装 PostgreSQL</span>
conda <span class="nb">install</span> <span class="nt">-c</span> conda-forge postgresql
</code></pre></div></div>

<h4 id="配置和启动-postgresql">配置和启动 PostgreSQL</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 创建 PostgreSQL 数据存储目录</span>
<span class="c"># 为了更好地区别是从 conda 安装的 PostgreSQL，特别将存储目录放置在 conda 配置目录下</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> /home/lisz/.conda/envs/pgsql/data

<span class="c"># 指定数据存储目录并后台启动 PostgreSQL，同时也开启日志记录功能</span>
pg_ctl <span class="nt">-D</span> /home/lisz/.conda/envs/pgsql/data <span class="nt">-l</span> logfile start

<span class="c"># 查看是否正常启动并监听端口 5432</span>
<span class="o">(</span>base<span class="o">)</span> ➜  data lsof <span class="nt">-i</span>:5432 
COMMAND    PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
postgres 33906 lisz    3u  IPv6 66936721      0t0  TCP localhost:postgres <span class="o">(</span>LISTEN<span class="o">)</span>
postgres 33906 lisz    4u  IPv4 66936722      0t0  TCP localhost:postgres <span class="o">(</span>LISTEN<span class="o">)</span>

<span class="c"># 使用当前 Linux 用户身份认证直接进入 PostgreSQL 默认数据库</span>
<span class="c"># 进入后是 PostgreSQL 的 shell 交互界面</span>
psql <span class="nt">-d</span>  postgres
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="err">输入以下命令完成创建用户</span> <span class="n">aiida</span><span class="err">、数据库</span> <span class="n">aiidadb</span><span class="err">，并给用户赋给该数据库的完全权限</span>
<span class="k">CREATE</span> <span class="k">USER</span> <span class="n">aiida</span> <span class="k">WITH</span> <span class="n">PASSWORD</span> <span class="s1">'&lt;password&gt;'</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">DATABASE</span> <span class="n">aiidadb</span> <span class="k">OWNER</span> <span class="n">aiida</span> <span class="k">ENCODING</span> <span class="s1">'UTF8'</span> <span class="n">LC_COLLATE</span><span class="o">=</span><span class="s1">'en_US.UTF-8'</span> <span class="n">LC_CTYPE</span><span class="o">=</span><span class="s1">'en_US.UTF-8'</span> <span class="k">TEMPLATE</span><span class="o">=</span><span class="n">template0</span><span class="p">;</span>
<span class="k">GRANT</span> <span class="k">ALL</span> <span class="k">PRIVILEGES</span> <span class="k">ON</span> <span class="k">DATABASE</span> <span class="n">aiidadb</span> <span class="k">to</span> <span class="n">aiida</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 使用 \q 即可退出刚才的 PostgreSQL 提供的 shell</span>
<span class="c"># 测试 aiida 用户是否可以使用密码从本地成功登录 aiidadb 数据库</span>
psql <span class="nt">-h</span> localhost <span class="nt">-d</span> aiidadb <span class="nt">-U</span> aiida <span class="nt">-W</span>
<span class="c"># 输入密码后，出现 PostgreSQL 的 shell 即登录成功</span>
</code></pre></div></div>

<h4 id="安装-rabbitmq">安装 RabbitMQ</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 从 conda-forge 频道安装 RabbitMQ 服务器</span>
conda <span class="nb">install</span> <span class="nt">-c</span> conda-forge rabbitmq-server
</code></pre></div></div>

<h4 id="配置和启动-rabbitmq">配置和启动 RabbitMQ</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 让 RabbitMQ 使用默认配置在后台启动</span>
rabbitmq-server <span class="nt">-detached</span>

<span class="c"># 开启 Web 管理插件</span>
rabbitmq-plugins <span class="nb">enable </span>rabbitmq_management

<span class="c"># 查看状态，验证是否正常启动</span>
rabbitmq-server status

<span class="c"># 查看是否正常监听 5672 端口</span>
<span class="o">(</span>base<span class="o">)</span> ➜  ~ lsof <span class="nt">-i</span>:5672             
COMMAND    PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
beam.smp 33967 lisz   95u  IPv6 66919827      0t0  TCP <span class="k">*</span>:amqp <span class="o">(</span>LISTEN<span class="o">)</span>
</code></pre></div></div>

<p>  由于 RabbitMQ 是消息队列，这里没有持久化和验证的需求，所有可以直接使用默认配置启动即可。验证正常启动后，可浏览 <a href="http://localhost:15627">http://localhost:15627</a> 来访问 RabbitMQ 的 Web 界面，默认管理员账号和密码均为 guest。这里需要注意的是，如果是服务器安装，本地机器是需要使用 ssh 代理端口的功能把服务器端的 15627 端口代理到本地的 15627 端口之后才能正常访问。当然，笔者建议使用 VS Code 来远程连接服务器，然后就可以使用 VS Code 提供的界面简单操作代理远程端口到本地。</p>

<h4 id="安装-aiida">安装 AiiDA</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 从 pypi 安装 AiiDA 核心程序</span>
pip <span class="nb">install </span>aiida-core

<span class="c"># 如果上述安装过程提示 conda 需要 pathlib 的 error，可以直接安装并重载 AiiDA 配置</span>
conda <span class="nb">install </span>pathlib
reentry scan
</code></pre></div></div>

<h4 id="配置和启动-aiida">配置和启动 AiiDA</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 为 AiiDA 配置用户信息、数据库连接信息以及消息队列连接信息</span>
<span class="o">(</span>base<span class="o">)</span> ➜  ~ verdi setup
Info: enter <span class="s2">"?"</span> <span class="k">for </span><span class="nb">help
</span>Info: enter <span class="s2">"!"</span> to ignore the default and <span class="nb">set </span>no value
Profile name: conquest
Email Address <span class="o">(</span><span class="k">for </span>sharing data<span class="o">)</span>: xxxx@xxx.xxx
First name: Ben
Last name: Li
Institution: NIMS
Database engine <span class="o">(</span>postgresql_psycopg2<span class="o">)</span> <span class="o">[</span>postgresql_psycopg2]: 
Database backend <span class="o">(</span>django, sqlalchemy<span class="o">)</span> <span class="o">[</span>django]: 
Database host: localhost
Database port <span class="o">[</span>5432]: 
Database name: aiidadb
Database username: aiida
Database password: 
Broker protocol <span class="o">(</span>amqp, amqps<span class="o">)</span> <span class="o">[</span>amqp]: 
Broker username <span class="o">[</span>guest]: 
Broker password <span class="o">[</span>guest]: 
Broker host <span class="o">[</span>127.0.0.1]: 
Broker port <span class="o">[</span>5672]: 
Broker virtual host name <span class="o">[]</span>:        
Repository directory <span class="o">[</span>/home/lisz/.aiida/repository/conquest]:
</code></pre></div></div>

<p>  至此，AiiDA 的所有软件环境就已经完全配置好了，试试觉得也不是那么难哈。</p>

<h2 id="验证安装">验证安装</h2>

<p>  AiiDA 的验证安装主要是检查：</p>
<ul>
  <li>AiiDA 主程序是否在后台正常运行？</li>
  <li>verdi shell 是否能正常使用？</li>
  <li>AiiDA 与数据库、消息队列是否连接正常？</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># verdi daemon status 检查后台情况</span>
<span class="c"># 如果没有启动使用 verdi daemon start 启动</span>
<span class="o">(</span>base<span class="o">)</span> ➜  ~ verdi daemon status
Profile: conquest
Daemon is running as PID 25383 since 2021-05-12 16:06:03
Active workers <span class="o">[</span>1]:
  PID    MEM %    CPU %  started
<span class="nt">-----</span>  <span class="nt">-------</span>  <span class="nt">-------</span>  <span class="nt">-------------------</span>
25387     0.02        0  2021-05-12 16:06:03
Use verdi daemon <span class="o">[</span>incr | decr] <span class="o">[</span>num] to increase / decrease the amount of workers

<span class="c"># verdi shell 进入 shell，如果无法进入则证明配置仍然存在错误</span>
<span class="o">(</span>base<span class="o">)</span> ➜  ~ verdi shell
Python 3.8.10 | packaged by conda-forge | <span class="o">(</span>default, May 11 2021, 07:01:05<span class="o">)</span> 
Type <span class="s1">'copyright'</span>, <span class="s1">'credits'</span> or <span class="s1">'license'</span> <span class="k">for </span>more information
IPython 7.23.1 <span class="nt">--</span> An enhanced Interactive Python. Type <span class="s1">'?'</span> <span class="k">for </span>help.

In <span class="o">[</span>1]: <span class="nb">exit</span><span class="o">()</span>

<span class="c"># verdi status 查看 AiiDA 的各项配置，包括自身及与其他软件之间的连接</span>
<span class="o">(</span>base<span class="o">)</span> ➜  ~ verdi status
 ✔ config <span class="nb">dir</span>:  /home/lisz/.aiida
 ✔ profile:     On profile conquest
 ✔ repository:  /home/lisz/.aiida/repository/conquest
 ✔ postgres:    Connected as aiida@localhost:5432
 ✔ rabbitmq:    Connected as amqp://guest:guest@127.0.0.1:5672?heartbeat<span class="o">=</span>600
 ✔ daemon:      Daemon is running as PID 25383 since 2021-05-12 16:06:03
</code></pre></div></div>

<h2 id="后续使用">后续使用</h2>

<p>  当我们已经有了 AiiDA 的完整环境之后，我们就会想要知道该如何使用 AiiDA 为计算服务呢。由于笔者是做第一性原理计算和机器学习的研究，所以后续将以 AiiDA 和 CONQUEST 的搭配使用为实例来介绍 AiiDA 的数据管理用法。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://aiida.readthedocs.io/projects/aiida-core/zh_CN/latest/intro/installation.html#installing-the-aiida-core-package">AiiDA 官网中文文档</a></li>
  <li><a href="https://blog.csdn.net/r_nznf/article/details/108056919">Conda 安装 PostgreSQL 数据库</a></li>
  <li><a href="https://segmentfault.com/a/1190000010480589">离线安装 RabbitMQ </a></li>
  <li><a href="https://blog.csdn.net/yufanghu/article/details/80829108">RabbitMQ 后台启动以及关闭</a></li>
</ul>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="aiida" /><category term="AiiDA" /><category term="data management" /><category term="calculation" /><category term="postgresql" /><category term="rabbitmq" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">个人免费博客花式搭建指南 Online Editor 篇</title><link href="https://lisz.me/tech/webmaster/start-blog-online-editor.html" rel="alternate" type="text/html" title="个人免费博客花式搭建指南 Online Editor 篇" /><published>2021-04-11T17:15:00+09:00</published><updated>2021-04-11T17:15:00+09:00</updated><id>https://lisz.me/tech/webmaster/start-blog-online-editor</id><content type="html" xml:base="https://lisz.me/tech/webmaster/start-blog-online-editor.html"><![CDATA[<h2 id="前言">前言</h2>

<p>  近些年，随着 Markdown 的蓬勃发展，越来越多地支持 Markdown 语法的在线编辑器和托管服务提供商出现。比如国外的 <a href="https://readthedocs.org/">Read the Docs</a>、<a href="https://gitbook.com">Gitbook</a> 等等，国内的 <a href="https://www.kancloud.cn/">看云</a> 等等。这种方式的好处主要有几点：</p>

<ul>
  <li>不需要任何环境配置，只需要浏览器就可以完成编辑和预览；</li>
  <li>当完成编辑时即发布，无须考虑手动部署或者自动部署的问题；</li>
  <li>可以直接把编辑的内容直接放在一起导出一本 PDF 电子书。</li>
  <li>由于运行资源没有限制，完全与平台相关，访问速度及最大并发访问量可能较高。</li>
</ul>

<p>当然，这种方式也会有一定的缺点：</p>

<ul>
  <li>无法定制呈现内容的样式，更无法修改模板；</li>
  <li>平台提供的在线编辑器的体验可能并没有离线编辑器的体验这么好，比如优秀的 <a href="https://typora.io">Typora</a>；</li>
  <li>对于页面权限的控制受限，无法像博客那样可以自由控制；</li>
  <li>不一定支持自定义域名，或需付费才支持自定义域名。</li>
</ul>

<p>  个人觉得比起搭建博客这类方式更适合搭建文档，比如说写产品文档、API 文档等等，而且其导出 PDF 的特点更加适合需求。</p>

<h2 id="体验与评价">体验与评价</h2>

<h3 id="read-the-docs">Read the Docs</h3>

<h4 id="登录">登录</h4>

<p>访问 <a href="https://readthedocs.org/">Read the Docs</a> 点击<strong>登录</strong>按钮，这里支持直接使用 Github 登录（推荐）。</p>

<p><img src="https://i.vgy.me/WiYCRb.png" alt="vgy.me" /></p>

<p><img src="https://i.vgy.me/ef4cKr.png" alt="vgy.me" /></p>

<h4 id="导入项目">导入项目</h4>

<p>由于是 Github 方式登录，可以直接从 Github 中导入项目，如下图所示。</p>

<p><img src="https://i.vgy.me/PaSfl7.png" alt="vgy.me" /></p>

<p>点击右侧加号按钮完成导入。</p>

<p><img src="https://i.vgy.me/TQYwpR.png" alt="vgy.me" /></p>

<p><img src="https://i.vgy.me/i0DQXU.png" alt="vgy.me" /></p>

<h4 id="预览项目">预览项目</h4>

<p>  由于这里导入的项目是 Jekyll，所以 Read the Docs 无法对其进行编译并显示预览页面。事实上，如果将 Jekylll 换成 Mkdocs，会发现能够通过编译并在线预览成功，但是 PDF 生成还是会有问题。所以最好的就是在 Github 建一个空的项目，将空的项目导入到 Read the Docs 中即可。</p>

<p>  其实，Read the Docs 还不能算得上是完整的在线编辑平台，毕竟它不提供所谓的 Online Editor。我们仍然需要使用 Github 自身提供的在线编辑功能，或者利用本地编辑器 Typora 这样的编辑然后上传更新到 Github。当然，如果 Github 的内容发生了更新，Read the Docs 将会拉取最新的内容进行编译并激活预览。</p>

<h3 id="gitbook">Gitbook</h3>

<h4 id="登录-1">登录</h4>

<p>访问 <a href="https://gitbook.com">Gitbook</a> ，可以选择 Sign Up With Github 进行快速注册。</p>

<p><img src="https://i.vgy.me/DDsCsE.png" alt="vgy.me" /></p>

<h4 id="创建项目">创建项目</h4>

<p>点击 create a new space 按钮，输入项目名称完成创建。</p>

<p><img src="https://i.vgy.me/mR46gg.png" alt="vgy.me" /></p>

<h4 id="导入内容">导入内容</h4>

<p>  如下图所示，可以直接导入 Markdown 文件。由于本站是采用 Jekyll 静态生成器的，所有只需将 _posts 目录下的 Markdown 文件全部拖拽到这里导入即可完成 Gitbook 的转换。</p>

<p><img src="https://i.vgy.me/3lGk46.png" alt="vgy.me" /></p>

<p><img src="https://i.vgy.me/J25FIN.png" alt="vgy.me" /></p>

<h4 id="预览项目-1">预览项目</h4>

<p>Gitbook 采用的是 https://用户名.gitbook.io/项目名/ 的方式预览，当然也支持自定义域名。</p>

<h3 id="评价">评价</h3>

<p>  Read the Docs 与 Gitbook 相比，后者支持完整的在线编辑功能和自定义主题功能，操作也略显复杂，前者则只负责编译生成和托管页面，不具有编辑能力。从笔者个人角度来看， Read the Docs 的方式更加方便快捷，操作性强，而 Gitbook 复杂的操作让本来编辑内容的时间都花在了一步一步的操作上了。虽然两者都支持 PDF 导出功能，但是 Read the Docs 导出的 PDF 格式更加像是一本电子书，排版精美，而 Gitbook 则是普通的格式。另外，在网页预览上，Gitbook 则更加大方、美观，比 Read the Docs 更具现代感，两者优势各异。当然也可以同时使用两种，取长而用。</p>]]></content><author><name>zhonger</name></author><category term="tech" /><category term="webmaster" /><category term="blog" /><category term="free" /><category term="static" /><category term="jekyll" /><category term="gitbook" /><category term="readthedoc" /><category term="ftp" /><category term="github" /><summary type="html"><![CDATA[前言]]></summary></entry></feed>